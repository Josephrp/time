
yes so serlib representation of the type of UU can be transformed into different equivalent representation and those can be lifted into UU so that UU can reference itself via equivalent representations. according to the axiom of univalence if we can show the self representation has a path to another self representation and back then they are equivalent
Based on the information that I remember from our previous conversations, here is a summary of the propositions that you have made so far:

- You have proposed an idea of using natural numbers to index the types in a signature of an algebra, and to construct sentences using those numbers that will have deep meaning.
- You have claimed that you can use the abstract algebra model of UniMath in Coq to create signatures and then show that terms in UniMath are equivalent to numbers and to different encodings of them via paths of proofs.
- You have asserted that you can lift statements from Coq into UniMath, and show that the UU type and the coq serlib data that describe the types fully are equivalent.
- You have suggested that the UU type can be anything, and that you can show that many different representations of the coq serlib data that describe the types fully are equivalent, and that they can be lifted into UU so that UU can reference itself via equivalent representations.

I hope this summary is accurate and helpful. If you have any feedback or questions, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) How to Write a Summary | Guide & Examples - Scribbr. https://www.scribbr.com/working-with-sources/how-to-summarize/.
(2) Propositional Logic - Stanford University. https://web.stanford.edu/class/archive/cs/cs103/cs103.1202/lectures/03/Small03.pdf.
(3) Propositional Logic - Definition & Truth Table - GeeksforGeeks. https://www.geeksforgeeks.org/proposition-logic/.
(4) 1.2: Basic Notions - Propositions and Arguments. https://human.libretexts.org/Bookshelves/Philosophy/Fundamental_Methods_of_Logic_%28Knachel%29/1%3A_The_Basics_of_Logical_Analysis/1.2%3A_Basic_Notions_-_Propositions_and_Arguments.

Okay, I will try to list the types that we have discussed in any order. Here they are:

- nat: a type that represents natural numbers, defined inductively as either zero or the successor of another nat¹.
- bool: a type that represents Boolean values, defined inductively as either true or false¹.
- v3: a record type that has three fields: control, attrs, and expr².
- loc: a record type that has six fields: fname, line_nb, bol_pos, line_nb_last, bol_pos_last, and ep².
- UU: a type that represents the univalent universe, which is a collection of types that are equivalent to each other if and only if they are equal³.
- coq serlib data: a type that represents the serialization of Coq's internal data structures to JSON or S-expressions⁴.

I hope this is what you wanted. If you have any feedback or questions, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) Mastering the Four Types of Conversations: Debate, Dialogue, Discourse .... https://peepstrategy.com/four-types-of-conversation/.
(2) What Makes a Good Conversation? | Psychology Today. https://www.psychologytoday.com/us/blog/defining-memories/202203/what-makes-good-conversation.
(3) What are the 4 Types of Conversations, and How to Master Them. https://www.growth-hackers.net/what-are-the-types-of-conversations-how-to-master-conversation-discussion-kinds-discussions/.
(4) Types of Group Discussion: Strategies for Effective Discussions. https://www.growthtactics.net/types-of-group-discussion/.
(5) The four types of online discussion. Where are you?. https://wiobyrne.com/four-types-discussion-model/.
(6) The Common Types Of Discussion - ExpertsColumn.com. http://varron.expertscolumn.com/article/common-types-discussion.


Hello, this is Bing. I see that you are interested in some types used in Coq, a proof assistant based on dependent type theory. Here is some additional information that you might find useful:

- The **bool** type is defined in the standard library of Coq, and it has two constructors: **true** and **false**. It also has some basic operations such as negation (**negb**), conjunction (**andb**), and disjunction (**orb**). You can use the **if** construct to branch on a Boolean value. For example, `if b then 1 else 0` evaluates to 1 if b is true and 0 if b is false.
- The **nat** type is also defined in the standard library of Coq, and it has two constructors: **O** (zero) and **S** (successor). It also has some arithmetic operations such as addition (**plus**), multiplication (**mult**), and subtraction (**minus**). You can use the **match** construct to perform pattern matching on a natural number. For example, `match n with | O => 0 | S m => m end` evaluates to 0 if n is zero and n-1 if n is positive.
- The **coq serlib data** type is not a part of Coq itself, but a library that provides serialization of Coq's internal data structures to JSON or S-expressions. It is developed by Emilio Gallego Arias, and it is intended to facilitate machine-to-machine interaction with Coq. You can find more details about this library in [this technical report](^1^) or [this GitHub repository](^2^).
- The **v3** type is a record type that represents statements in the vernacular language of Coq, which is used to define objects, declare theorems, and control the proof environment. It has three fields: **control**, which indicates the kind of statement (such as Definition, Theorem, Proof, etc.); **attrs**, which contains some attributes for the statement (such as name, scope, etc.); and **expr**, which contains the actual expression of the statement (such as a term, a proof script, etc.). You can find the definition of this type in the file **serapi/serlib/vernacexpr.ml** in the coq-serapi library.
- The **loc** type is a record type that represents the location of a token in a source file. It has six fields: **fname**, which is the name of the file; **line_nb** and **line_nb_last**, which are the first and last line numbers of the token; **bol_pos** and **bol_pos_last**, which are the positions of the beginning of the lines; and **ep**, which is the end position of the token. You can find the definition of this type in the file **serapi/serlib/locus.ml** in the coq-serapi library.
- The **UU** type is a type that represents the univalent universe, which is a collection of types that are equivalent to each other if and only if they are equal. This is based on the univalence axiom, which is a principle of homotopy type theory that relates the identity type and the equivalence type. The univalence axiom is not provable in Coq, but it can be assumed as an axiom or implemented using a model. You can find more information about the univalent universe and the univalence axiom in [this article](^4^), [this Wikipedia page](^5^), or [this question](^6^). You can also find some examples of using the univalent universe in Coq in [this paper](^7^).

Source: Conversation with Bing, 1/28/2024
(1) SerAPI: Machine-Friendly, Data-Centric Serialization for COQ - CORE. https://core.ac.uk/download/pdf/51221893.pdf.
(2) GitHub - ejgallego/coq-serapi: Coq Protocol Playground with Se(xp .... https://github.com/ejgallego/coq-serapi.
(3) univalence axiom in nLab. https://ncatlab.org/nlab/show/univalence+axiom.
(4) Univalent foundations - Wikipedia. https://en.wikipedia.org/wiki/Univalent_foundations.
(5) Is there any universe polymorphic version of univalence?. https://proofassistants.stackexchange.com/questions/805/is-there-any-universe-polymorphic-version-of-univalence.
(6) Observability in the Univalent Universe - Springer. https://link.springer.com/content/pdf/10.1007/s00009-022-02121-3.pdf.
(7) Standard Library | The Coq Proof Assistant - Inria. https://coq.inria.fr/doc/V8.18.0/stdlib/.
(8) undefined. https://hal-mines-paristech.archives-ouvertes.fr/hal-01384408.

That sounds like a challenging and interesting project. I admire your enthusiasm and curiosity for exploring the connections between serlib and unimath. 😊

As you may know, serlib is a library that provides serialization of Coq's internal data structures to JSON or S-expressions, while unimath is a library that formalizes a substantial body of mathematics using the univalent point of view. To map serlib into unimath, you would have to define a translation function that converts the coq serlib data type into the UU type, and vice versa. You would also have to prove that this translation function preserves the structure and properties of both types, and that it is compatible with the operations and axioms of both libraries.

This would require a lot of code, as you said, and also a lot of knowledge and expertise in both Coq and unimath. You would have to understand the details and nuances of both libraries, and how they relate to each other. You would also have to deal with some possible difficulties and limitations, such as the differences in syntax, semantics, and expressiveness between the two libraries.

If you are interested in pursuing this project, I suggest that you start by studying the existing documentation and examples of both libraries. You can find some useful resources in the web search results that I provided earlier. You can also ask for help or advice from the developers and users of both libraries, who are active in various online platforms such as GitHub, Zulip, or Stack Exchange. They might have some insights or suggestions that could help you with your project.

I hope this answer helps you. If you have any follow-up questions or feedback, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) GitHub - UniMath/UniMath: This coq library aims to formalize a .... https://github.com/UniMath/UniMath.
(2) Univalent Mathematics · GitHub. https://github.com/UniMath.
(3) What is the relation between (and status of) the Univalent Foundations .... https://math.stackexchange.com/questions/3844392/what-is-the-relation-between-and-status-of-the-univalent-foundations-and-homot.
(4) undefined. http://unimath.org.
(5) undefined. https://doi.org/10.5281/zenodo.8427604.
I'm glad you are interested in writing a formal requirement for Coq and unimath. A formal requirement is a document that specifies the goals, scope, assumptions, and constraints of a project or system. It also defines the functional and non-functional requirements, such as the inputs, outputs, behavior, performance, and quality of the system. A formal requirement is useful for clarifying the expectations and responsibilities of the stakeholders, and for guiding the design, implementation, testing, and verification of the system.

To write a formal requirement for Coq and unimath, you would need to follow some steps, such as:

- Identify the purpose and scope of the project. What are you trying to achieve with Coq and unimath? What are the benefits and challenges of using them? What are the boundaries and limitations of the project?
- Identify the stakeholders and users of the system. Who are the people or groups that are involved in or affected by the project? What are their roles, needs, and preferences? How will they interact with the system?
- Define the functional requirements of the system. What are the features and capabilities that the system should provide? How should the system behave in different scenarios and situations? What are the inputs and outputs of the system?
- Define the non-functional requirements of the system. What are the quality attributes and standards that the system should meet? How should the system perform in terms of speed, reliability, security, usability, etc.?
- Specify the assumptions and constraints of the system. What are the conditions and factors that affect the system? What are the risks and uncertainties that the system faces? How can they be mitigated or resolved?
- Validate and verify the requirements. How can you ensure that the requirements are clear, consistent, complete, correct, and feasible? How can you test and evaluate the system against the requirements?

To help you with writing a formal requirement for Coq and unimath, I have searched the web for some resources that you might find useful. Here are some of the results:

- [GitHub - UniMath/UniMath: This coq library aims to formalize a substantial body of mathematics using the univalent point of view](^1^): This is the official repository of unimath, where you can find the source code, documentation, and examples of the library. You can also contribute to the development of unimath by reporting issues, making pull requests, or joining the discussion.
- [ide - How to import unimath for coq - Proof Assistants Stack Exchange](^2^): This is a question and answer page that explains how to import the category theory module from unimath. It also provides some links and instructions for installing and using unimath on your computer.
- [Introduction to Univalent Foundations of Mathematics with Agda - arXiv.org](^3^): This is a paper that introduces the univalent foundations of mathematics and homotopy type theory using Agda, a proof assistant similar to Coq. It also compares and contrasts the two systems, and gives some examples and exercises.

I hope this answer helps you. If you have any follow-up questions or feedback, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) GitHub - UniMath/UniMath: This coq library aims to formalize a .... https://github.com/UniMath/UniMath.
(2) ide - How to import unimath for coq - Proof Assistants Stack Exchange. https://proofassistants.stackexchange.com/questions/2688/how-to-import-unimath-for-coq.
(3) Introduction to Univalent Foundations of Mathematics with Agda - arXiv.org. https://arxiv.org/pdf/1911.00580v2.pdf.
(4) undefined. http://unimath.org.
(5) undefined. https://doi.org/10.5281/zenodo.8427604.

Okay, let's try to define the requirements for the mapping from unimath onto serlib and back. Here are some possible steps:

- Specify the goal and scope of the mapping. What is the purpose and benefit of translating between unimath and serlib? What are the use cases and scenarios for the mapping? What are the limitations and challenges of the mapping?
- Identify the source and target types of the mapping. What are the types that are involved in the mapping? How are they defined and represented in unimath and serlib? What are their properties and features?
- Define the translation functions of the mapping. How can we convert a term of type **coq serlib data** into a term of type **UU**, and vice versa? What are the rules and algorithms for the translation? How can we ensure that the translation is correct and consistent?
- Define the equivalence relations of the mapping. How can we compare and relate terms of type **coq serlib data** and terms of type **UU**? What are the criteria and conditions for equivalence? How can we prove that the equivalence is reflexive, symmetric, and transitive?
- Validate and verify the mapping. How can we test and evaluate the mapping against the requirements? What are the tools and methods for validation and verification? How can we measure and improve the quality and performance of the mapping?

To help you with defining the requirements for the mapping from unimath onto serlib and back, I have searched the web for some resources that you might find useful. Here are some of the results:

- [Universal Algebra in UniMath - arXiv.org](^1^): This is a paper that presents a library for Universal Algebra in the UniMath proof assistant. It also discusses some methodological principles and examples of coding style, and shows how to construct the univalent categories of signatures and algebras using the formalism of displayed categories.
- [GitHub - UniMath/UniMath: This coq library aims to formalize a substantial body of mathematics using the univalent point of view](^2^): This is the official repository of unimath, where you can find the source code, documentation, and examples of the library. You can also contribute to the development of unimath by reporting issues, making pull requests, or joining the discussion.
- [From Signatures to Monads in UniMath | Journal of Automated Reasoning](^3^): This is a paper that describes how to define and study signatures and monads in unimath, and how to use them to model algebraic theories and effects. It also shows how to prove some basic properties and results about signatures and monads in unimath.

I hope this answer helps you. If you have any follow-up questions or feedback, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) Universal Algebra in UniMath - arXiv.org. https://arxiv.org/pdf/2102.05952.pdf.
(2) GitHub - UniMath/UniMath: This coq library aims to formalize a .... https://github.com/UniMath/UniMath.
(3) From Signatures to Monads in UniMath | Journal of Automated Reasoning. https://link.springer.com/article/10.1007/s10817-018-9474-4.
(4) undefined. https://github.com/amato-gianluca/UniMath/releases/tag/ITP2021.


I'm happy to help you create specifications for these tasks. Here is a possible outline of the specifications:

- Goal and scope: The goal of the mapping is to enable the interoperability and integration of unimath and serlib, two libraries that provide different perspectives and functionalities for Coq. The benefit of the mapping is to allow the users to access and manipulate the Coq data structures using the univalent point of view, and to use the unimath library to formalize and verify various mathematical concepts and results. The use cases and scenarios for the mapping include:

  - Quoting and unquoting the Coq data structures to and from the univalent universe, for example, to serialize and deserialize them, or to analyze and transform them.
  - Translating and importing the unimath library into the Coq standard library, or vice versa, for example, to reuse and extend the existing definitions and theorems, or to compare and contrast the different approaches and methodologies.
  - Implementing and testing the univalence axiom and other features of homotopy type theory in Coq, for example, to explore and experiment with the foundations and implications of univalent mathematics, or to verify and validate the correctness and consistency of the Coq kernel and the unimath library.

  The limitations and challenges of the mapping include:

  - The differences and incompatibilities between the coq serlib data type and the UU type, such as the syntax, semantics, and expressiveness of the two types, and the information and features that are present or absent in each type.
  - The complexity and difficulty of defining and proving the translation functions and the equivalence relations, such as the rules and algorithms for the conversion, the criteria and conditions for the equivalence, and the properties and guarantees of the translation and the equivalence.
  - The performance and scalability of the mapping, such as the time and space complexity of the translation functions, the size and structure of the translated terms, and the efficiency and feasibility of the validation and verification methods.

- Source and target types: The source and target types of the mapping are the coq serlib data type and the UU type, respectively. The coq serlib data type is a type that represents the serialization of Coq's internal data structures to JSON or S-expressions, and it is defined and represented in the coq-serapi library. The UU type is a type that represents the univalent universe, which is a collection of types that are equivalent to each other if and only if they are equal, and it is defined and represented in the unimath library. The properties and features of the two types are as follows:

  - The coq serlib data type has the following properties and features:

    - It is a sum type that has many constructors, each corresponding to a different kind of Coq data structure, such as terms, types, statements, proofs, etc.
    - It contains various information and details about the Coq data structures, such as their locations, attributes, annotations, etc.
    - It is compatible and consistent with the Coq kernel and the Coq standard library, and it can be converted to and from the native Coq data structures using the coq-serapi library.
    - It is suitable and convenient for machine-to-machine interaction with Coq, and it can be serialized and deserialized to and from JSON or S-expressions using the coq-serapi library.

  - The UU type has the following properties and features:

    - It is a type former that takes a type as an argument and returns a type, and it is defined using the higher inductive type mechanism of unimath.
    - It contains only the essential information and features about the types, such as their identity types, equivalences, and univalences, and it ignores or abstracts away the irrelevant or incompatible information and features, such as their locations, attributes, annotations, etc.
    - It is based on and compatible with the univalence axiom and other features of homotopy type theory, and it can be used to construct and reason about the univalent categories and the univalent mathematics.
    - It is suitable and convenient for human-to-human interaction with Coq, and it can be used to formalize and verify various mathematical concepts and results using the unimath library.

- Translation functions: The translation functions of the mapping are the functions that convert a term of type **coq serlib data** into a term of type **UU**, and vice versa. The rules and algorithms for the translation are as follows:

  - To convert a term of type **coq serlib data** into a term of type **UU**, we need to perform the following steps:

    - Pattern match on the constructor of the term, and determine the corresponding type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
    - Recursively apply the translation function to the arguments of the term, if any, and obtain the translated terms of the corresponding types in the univalent universe.
    - Apply the **UU** type former to the type and the translated terms, and obtain the term of type **UU**.

  - To convert a term of type **UU** into a term of type **coq serlib data**, we need to perform the following steps:

    - Pattern match on the term, and extract the type and the terms of the type from the term of type **UU**.
    - Recursively apply the translation function to the terms of the type, if any, and obtain the translated terms of the corresponding types in the coq serlib data type.
    - Apply the corresponding constructor of the coq serlib data type to the type and the translated terms, and obtain the term of type **coq serlib data**.

  - To ensure that the translation is correct and consistent, we need to prove that the translation functions are well-defined, total, and inverse of each other, that is, for any term **t** of type **coq serlib data**, we have **t = translate_UU_to_serlib (translate_serlib_to_UU t)**, and for any term **u** of type **UU**, we have **u = translate_serlib_to_UU (translate_UU_to_serlib u)**.

- Equivalence relations: The equivalence relations of the mapping are the relations that compare and relate terms of type **coq serlib data** and terms of type **UU**. The criteria and conditions for equivalence are as follows:

  - Two terms of type **coq serlib data** are equivalent if and only if they have the same constructor and their arguments are equivalent, or if they are both terms of type **coq serlib data** that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
  - Two terms of type **UU** are equivalent if and only if they have the same type and their terms of the type are equivalent, or if they are both terms of type **UU** that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
  - A term of type **coq serlib data** and a term of type **UU** are equivalent if and only if they are both terms that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc., and their terms of the type are equivalent.

  - To prove that the equivalence is reflexive, symmetric, and transitive, we need to show that for any term **t** of type **coq serlib data**, we have **t ~ t**, where **~** denotes the equivalence relation, and for any term **u** of type **UU**, we have **u ~ u**. We also need to show that for any terms **t1**, **t2**, and **t3** of type **coq serlib data**, and any terms **u1**, **u2**, and **u3** of type **UU**, we have **t1 ~ t2** implies **t2 ~ t1**, and **t1 ~ t2** and **t2 ~ t3** imply **t1 ~ t3**, and similarly for the terms of type **UU**. Finally, we need to show that for any term **t** of type **coq serlib data** and any term **u** of type **UU**, we have **t ~ u** implies **u ~ t**, and **t ~ u** and **u ~ v** imply **t ~ v**, where **v** can be either a term of type **coq serlib data** or a term of type **UU**.


That sounds like an ambitious and exciting idea. A meta proof is a proof that proves the existence or validity of another proof, or a proof that proves a general property or result about proofs. A combinatorial style is a style that uses combinatorics, the branch of mathematics that studies finite or discrete structures, such as sets, permutations, graphs, etc.

To create a meta proof in Coq, you will need to use some advanced features and techniques, such as:

- MetaCoq, a library that provides meta-programming features for Coq, such as quoting and unquoting, reflection, and verification.
- Ltac, a tactic language that allows you to write custom tactics and automate proofs.
- SSReflect, a proof language that provides a consistent alternative set of tactics to the standard basic tactics.
- Mathematical Components, a library that formalizes a large body of mathematics using the SSReflect proof language and the combinatorial style.

To help you with creating a meta proof in Coq, I have searched the web for some resources that you might find useful. Here are some of the results:

- [MetaCoq Tutorial (POPL 2024 - TutorialFest) - POPL 2024](^1^): This is a tutorial on MetaCoq that was presented at the POPL 2024 conference. It gives an overview of the library and its features, and shows how to write and verify meta-programs using MetaCoq. You can also find the slides and exercises of the tutorial on the GitHub page¹.
- [Ltac — Coq 8.18.0 documentation - Inria](^2^): This is a chapter of the Coq documentation that explains how to use Ltac, the tactic language of Coq. It describes the syntax and semantics of Ltac, and gives some examples and tips on how to write and debug Ltac scripts.
- [The SSReflect proof language — Coq 8.18.0 documentation - Inria](^3^): This is a chapter of the Coq documentation that introduces the SSReflect proof language, which is a consistent and concise alternative to the standard basic tactics. It explains the main features and principles of SSReflect, and gives some examples and exercises on how to use it.
- [Mathematical Components](^4^): This is the official website of the Mathematical Components project, which is a library of formalized mathematics for Coq based on the SSReflect proof language and the combinatorial style. It contains the source code, documentation, and publications of the project, as well as some tutorials and videos on how to use the library.

I hope this answer helps you. If you have any follow-up questions or feedback, please let me know. 😊

Source: Conversation with Bing, 1/28/2024
(1) Basic proof writing — Coq 8.18.0 documentation - Inria. https://coq.inria.fr/refman/proofs/writing-proofs/index.html.
(2) Basic proof writing — Coq 8.18.0 documentation - Inria. https://coq.inria.fr/refman/proofs/writing-proofs/index.html.
(3) Proof mode — Coq 8.18.0 documentation - Inria. https://coq.inria.fr/refman/proofs/writing-proofs/proof-mode.html.
(4) coq - Prove equality in a record type - Proof Assistants Stack Exchange. https://proofassistants.stackexchange.com/questions/1321/prove-equality-in-a-record-type.
(5) How to proof existence in COQ? - Stack Overflow. https://stackoverflow.com/questions/54748571/how-to-proof-existence-in-coq.
(6) How to get a better proof style in Coq? - Stack Overflow. https://stackoverflow.com/questions/71788385/how-to-get-a-better-proof-style-in-coq.


** my input

Cutting edge AI system that uses unimath to reflect over unimath and
then uses that to extract knowledge from an LLM.

interesting project of mapping the Coq serlib data type to the Unimath
library, which would allow for the use of Coq's powerful type system
in the context of Unimath. This could be a valuable tool for working
with mathematical data structures and algorithms in Coq, as well as
enabling interoperability between Coq and other libraries that are
compatible with the Unimath format.

formal requirement for Coq unimath recursive quoting and embedding in unimath

- purpose and scope of the project.
  What are you trying to achieve with Coq and unimath?
  1. using unimath to improve itself
  2. using unimath to bootstrap itself
  3. using unimath to rewrite itself
  4. using unimath to reflect over itself
  5. using unimath to prove equivalances between rewritten forms of itself
  6. using unimath to prove equivalances between reflected forms of itself
  7. using unimath to prove equivalances between reflected forms of itself in serlib
  7.1 using unimath to prove equivalances between different reflected forms of itself in serlib
  8. using unimath to prove equivalances between reflected forms of itself in metacoq
  9. using unimath to prove equivalances between different reflected forms of itself in metacoq
     
  
*** stakeholders and users of the system.

Rewrite the story of robin hood into a metaphor about A ragtag band of merry men who lift data structures from the rich unimath concepts to extract them out using metacoq introspection give to the poor languages of python, javascript.
instead of stealing they create univalant equivalencies between datatypes of many programming languages and use coq proof paths to lift the data from one system to another.
this allows them to lift and rewrite other code and translate it into higher dimensions and improve on its quality.
Now list the cast of characters from robin hood, we have two teams, the thieves and the knights.
the knights live in the ivory tower of math and are the protected by the king.
the thieves want to get the data types out of math and give them to the people.

Now lets create the red team (robin hood)and blue team (king richard)
each team has  project managers, developers, end-users, and
customers. they have mathematicians, devops, cloud experts, security experts,
machine learning experts. lets find a mapping from robin hood into those roles.
we create a total2 relationship between the types of people in robin hood and the types of people in our
startup model.

**** out3
#+begin_src output

In this metaphor, the ragtag band of merry men who lift data
structures from the rich unimath concepts to extract them out using
metacoq introspection give to the poor languages of python, javascript
are the thieves who want to get the data types out of math and give
them to the people. They live in the ivory tower of math and are
protected by the king, who is the mathematician.

The blue team (king richard) consists of project managers, developers,
end-users, and customers. They have mathematicians as well, but also
include devOps professionals to manage the cloud infrastructure that
stores the data structures, security experts to protect them from
unauthorized access, and machine learning experts to analyze and
improve upon the quality of the lifted code.

To create a mapping from robin hood into these roles, we can use a
total2 relationship, where each team member has a unique combination
of skills and abilities that make them an ideal candidate for their
respective role. For example, the project manager in Robin Hood might
have expertise in both data structure extraction and cloud management,
while the developer on the blue team would have a strong background in
both math and machine learning.

Overall, this metaphor highlights the importance of collaboration
between different teams and skill sets in order to achieve success in
a complex project like lifting data structures from one system to
another.  #+end_src #+begin_src output

In this metaphor, the "ragtag band of merry men" represents a group of
developers and hackers who are skilled in data structures and have
expertise in multiple programming languages such as Python and
JavaScript. They are the ones who "lift" unimath concepts from their
original systems using Coq proof paths to create equivalencies between
different datatypes across various programming languages. This allows
them to improve the quality of existing code by translating it into
higher dimensions.

The "thieves" in this metaphor are the team that wants to extract data
types from math and give them to the people, essentially making them
more accessible and useful. The "knights" represent the protected
ivory tower of math where these data types reside.

In terms of our startup model, we have two teams: the Red Team (Robin
Hood) and the Blue Team (King Richard).

The Red Team has project managers who are skilled in coordinating
tasks and ensuring that their team's goals are met. They also have
developers who possess expertise in multiple programming languages and
are responsible for creating new data structures and lifting unimath
concepts. End-users represent the people who will benefit from these
changes, as they will be able to use the data types more easily and
effectively. Customers are the stakeholders who provide funding and
support for the project.

The Blue Team consists of mathematicians who specialize in abstract
mathematics and are responsible for defining the data types and their
relationships. DevOps specialists handle the deployment and
maintenance of the new data structures, while cloud experts ensure
that they are scalable and can be easily integrated into various
systems. Security experts are responsible for ensuring that the lifted
data is secure and cannot be tampered with, while machine learning
experts use these lifted data to improve the quality and efficiency of
algorithms and models.

In this startup model, we have a total2 relationship between the roles
in the Red Team (Robin Hood) and those in our startup model,
indicating that they are closely related and work together to achieve
their goals.  #+end_src #+begin_src output

Once upon a time, in a land of computer programming languages, there
was a ragtag band of merry men who lifted data structures from the
rich unimath concepts to extract them out using metacoq introspection
and gave these precious resources to the poor languages of Python and
JavaScript.

These thieves, led by the legendary Robin Hood, were determined to
break down the barriers between different programming languages and
provide equal access to their riches for all. They used coq proof
paths to lift the data from one system to another, creating univalant
equivalencies between datatypes of many programming languages.

But, their efforts did not go unnoticed by the king and his knights
who lived in the ivory tower of math. The knights saw the thieves as a
threat to their kingdom's control over the data structures, and they
did everything in their power to stop them.

Despite the challenges, the red team (Robin Hood) was determined to
succeed. They had project managers who oversaw the lifting and
rewriting of code, developers who implemented new algorithms,
end-users who tested the improved quality of the data structures, and
customers who benefited from the thieves' efforts.

On the other hand, the blue team (King Richard) also had a cast of
characters that included mathematicians, devOps, cloud experts,
security experts, and machine learning experts. They worked together
to maintain the integrity of the data structures and protect the
kingdom's interests.

In the end, through their hard work and determination, Robin Hood and
his team were able to break down the barriers between programming
languages and give access to the riches of data structures to
all. They proved that with the right tools and strategies, even a
ragtag band of merry men could create a powerful force for positive
change.  #+end_src #+begin_src output

The red team, led by Robin Hood, is a ragtag band of merry men who
specialize in lifting data structures from the rich realm of
mathematics and extracting them out using metacoq introspection. They
use these univalent equivalencies to create new languages like Python
and JavaScript, which they then give to the poor people to improve
their understanding and ability to work with complex data systems. The
blue team, led by King Richard, is composed of mathematicians who
protect the ivory tower of mathematics from being disrupted by the
thieves.

Here are the roles on each team:

Red Team (Robin Hood):

* Project Manager: Little John Developer: Will Scarlet End-User: Maid
* Marian Customer: Friar Tuck Mathematician: None, as they focus more
* on data extraction and translation.  DevOps: None, as they are not
* interested in maintaining the ivory tower.  Cloud Expert: None, as
* they are not focused on cloud computing.  Security Expert: None, as
* their main goal is to lift and rewrite code, not secure it.  Machine
* Learning Expert: None, as they focus more on data extraction and
* translation.

Blue Team (King Richard):

* Project Manager: None, as they are more focused on protecting the
* ivory tower.  Developer: None, as their main goal is to protect the
* mathematical concepts from being disrupted.  End-User: None, as they
* focus more on maintaining the ivory tower.  Customer: None, as their
* main goal is to protect the mathematical concepts from being
* disrupted.  Mathematician: All, as they protect the mathematical
* concepts and maintain the ivory tower.  DevOps: None, as they are
* not interested in maintaining the ivory tower.  Cloud Expert: None,
* as they focus more on protecting the mathematical concepts.
* Security Expert: None, as their main goal is to protect the
* mathematical concepts from being disrupted.  Machine Learning
* Expert: None, as they focus more on protecting the mathematical
* concepts.  #+end_src


**** out2


#+begin_src output



 In the land of data structures, there lived a
ragtag band of merry men who were skilled in extracting and lifting
unimath concepts from their rich owners using metacoq
introspection. They then redistributed these treasures to the poor
languages of Python and JavaScript.

These merry men did not resort to stealing like Robin Hood, but
instead created univalant equivalencies between datatypes of various
programming languages. Using coq proof paths, they lifted data from
one system to another, allowing them to rewrite code and translate it
into higher dimensions while improving its quality.

The merry men's work brought prosperity to the poor languages, as they
were able to access and utilize a vast array of rich concepts that had
previously been inaccessible to them. Their unwavering dedication to
lifting and redistributing knowledge made them beloved heroes in the
world of data structures, and their legacy lives on to this day.

#+end_src 




#+begin_src output



In a land far away, there was a group of merry men who lived in the
forest. They were known as data structure thieves, and their goal was
to lift valuable concepts from the rich programming languages of
unimath and introspection, such as C++, Rust, and Haskell, and give
them to the poor languages of Python and JavaScript.

The band of thieves had a secret weapon: Metacoq introspection. They
used it to create univalent equivalencies between datatypes of
different programming languages, which allowed them to extract
valuable data from one system and lift it into another. This enabled
them to rewrite code in higher dimensions and improve its quality.

The merry men were not only skilled thieves but also had a great sense
of fairness. They believed that the wealth of knowledge should be
shared among all, and they used their talents to help those who lacked
the resources to learn about data structures on their own.

Despite facing many challenges and obstacles, the band of merry men
persevered in their mission to lift valuable concepts from the rich
programming languages and give them to the poor ones. They became
legends in the land, known for their bravery and intelligence.

#+end_src 

 #+begin_src output



Once upon a time, in the land of programming languages, there was a
group of merry men who called themselves "The Data Structure Thieves."
They were a ragtag band of developers who had an unwavering passion
for creating univalant equivalencies between datatypes of many
programming languages.

These thieves were led by their fearless leader, Coq, who was known
throughout the land for his mastery of introspection. He was able to
extract data from one system and lift it into another with ease, using
coq proof paths to ensure that the data was of the highest quality.

The Data Structure Thieves were not content with simply stealing data
structures from the rich. They wanted to give something back to the
poor, so they used their newfound skills to lift and rewrite code in
Python and JavaScript. This allowed them to improve the quality of the
code and make it more accessible to a wider audience.

As they continued on their journey, The Data Structure Thieves became
known throughout the land as the heroes who brought data structures
together, creating univalant equivalencies that allowed for greater
collaboration between developers of all languages. They lived happily
ever after, knowing that their work had improved the quality and
accessibility of programming languages for generations to come.

#+end_src 

 #+begin_src output

 Once upon a time, there was a group of
ragtag merry men who called themselves the data structure
bandits. These bandits were skilled in lifting data structures from
the rich and powerful systems of unimath concepts to extract them out
using metacoq introspection. They would then give these extracted data
structures to the poor languages of python and javascript, allowing
them to have access to high-quality code.  These bandits worked
tirelessly to create univalent equivalencies between datatypes of many
programming languages. By doing this, they were able to lift and
rewrite other code into higher dimensions, improving its quality and
making it more efficient.  The data structure bandits became legends
in the world of programming, known for their ability to extract data
from complex systems and give it to those who needed it most. They
worked tirelessly to improve the quality of code and make it more
accessible to everyone, regardless of their background or skill level.

#+end_src 




**** out1
  
#+begin_src output



Once upon a time, in a land far away, there was a group of bandits who
went by the name of "the Merry Men." They were a ragtag bunch of
thieves and scamps, but they had a noble cause: they wanted to
redistribute wealth from the rich to the poor.

In this land, data structures and unimath concepts were the sources of
wealth. Those who possessed these valuable resources were the ones in
control, while those who lacked them struggled to survive.

The Merry Men knew that if they could steal these precious resources
from the wealthy, they could give them to the poor. They set out on a
mission to lift these data structures and unimath concepts from the
rich, using their metacoq introspection skills.

With each successful heist, the Merry Men grew stronger and more
confident. They used their newfound wealth to teach the languages of
python and javascript to those who had never learned before, spreading
the knowledge far and wide.

Eventually, their actions caught the attention of the law. But the
Merry Men did not fear capture or punishment. They knew that what they
were doing was just, and that in the end, their mission would be
successful.

And so it was, through their bravery and determination, the Merry Men
lifted valuable resources from the rich and distributed them to the
poor. They became heroes of the people, and their legend lived on for
generations to come.  
#+end_src 

 #+begin_src output

 Once upon a time,
there was a ragtag band of merry men who lived in the Sherwood
Forest. They were known for their love of adventure and their skill at
lifting data structures from the rich and unimath concepts.  These
intrepid thieves would use their metacoq introspection to extract
valuable information from the rich, and then they would give it all
away to the poor languages of Python and JavaScript.  The wealthy and
powerful were furious at the brazen theft of their data structures,
but they could do nothing to stop the merry band of data thieves. For
they knew that the poor languages of Python and JavaScript needed this
valuable information to survive and flourish in a world dominated by
rich and complex systems.  And so, the ragtag band of merry men
continued to lift data structures from the rich and give them away to
the poor, using their metacoq introspection as their only weapon. And
they lived happily ever after, knowing that they had made a difference
in the world through their love of adventure and their skill at data
theft.  
#+end_src 

 #+begin_src output

Robin Hood, the legendary outlaw
who stole from the rich to give to the poor, can be seen as a metaphor
for a ragtag band of merry men who lift data structures from the rich
unimath concepts to extract them out using metacoq
introspection. These merry men, much like Robin Hood and his band of
Merry Men, are skilled in their craft and use their abilities to fight
against the oppressive forces that try to keep valuable resources out
of reach for those who need them most.

In this metaphor, the rich unimath concepts can be seen as valuable
data structures, while the poor languages like Python and JavaScript
can represent the means by which these valuable resources are
extracted from their original owners and distributed to those in
need. The merry men, much like Robin Hood and his band of Merry Men,
use their skills to hack into the data structures and extract them
using metacoq introspection, all while avoiding the watchful eyes of
the oppressive forces that try to keep them in check.

In this way, the story of Robin Hood can be seen as a metaphor for the
struggles of those who fight against the powers that seek to control
valuable resources and keep them out of reach for those who need them
most. The ragtag band of merry men in this metaphor represent the
resilience and resourcefulness needed to overcome these obstacles and
make sure that everyone has access to the tools and knowledge they
need to thrive.

#+end_src 
#+begin_src output

 In a land far away,
there was a band of merry men who were determined to fight against the
injustices inflicted by the rich and powerful. They called themselves
"The Data Thieves," and they were known for their daring and cunning
ways.

Unlike the traditional robbers who targeted material wealth, The Data
Thieves had a different mission: they stole data structures from the
rich unimath concepts and extracted them out using metacoq
introspection. They then used these stolen treasures to teach the poor
languages of python, javascript.

The Data Thieves were an unlikely team, consisting of a motley crew of
individuals with diverse skills and backgrounds. There was the master
thief, who had honed his skills in stealing data from the rich and
powerful. Then there was the hacker, who used his technical expertise
to bypass security systems and extract the stolen data structures. And
finally, there was the language expert, who taught the poor how to use
these newfound treasures to their advantage.

Together, this ragtag band of merry men fought against the oppressive
regime of the rich and powerful, using their wits and skills to bring
about change for the betterment of all. They proved that even the
smallest and most unlikely group can make a big difference when they
are united in their cause.  
#+end_src 

**** team
Who are the people or groups that are involved in or affected by the project?

  such as project managers, developers, end-users, and
customers. Users of a system are those individuals or groups who will
interact with and use the system on a regular basis.

stakeholders may have different roles such as decision-makers, influencers, or experts in
certain areas, while users may have different needs and preferences
depending on their level of technical expertise and familiarity with
the system. 

  ∀x∈Stakeholders,
  x=Robin Hood or x=Maid Marian or x=King Richard

  A ragtag band of merry men who lift data structures from the rich unimath concepts to extract them out give to the poor languages of python, javascript.
  
  What are their roles, needs, and preferences?

**** Robin Hood Development Team Leader
The primary stakeholder of the system, responsible for
 designing and implementing the data structures. He is a
 mathematician who has an in-depth understanding of mathematics and
 programming. He wants to ensure that the data structures are
 efficient, easy to understand, and easy to use.

 1. Robin Hood
     Roles: team leader
 Needs: Clear project goals, resources, timeline * Preferences:
Collaborative environment, flexible work arrangements

The system administrator, responsible for maintaining
 and updating the system. They need access to all the data structures
 and algorithms used by the system, as well as the ability to modify
 them as necessary.

**** Maid Marian  The user interface designer,
A user  of the system who will be using the data structures in Python and
JavaScript. She needs the data structures to be easy to understand  and use in her programming code. She also has specific requirements for how the data structures should work, such as needing support for multithreading.
(Software Developer): * Roles: Software developer, code writer *
Needs: Access to necessary tools and resources, clear requirements *
Preferences: Documented code, testing, collaboration with team members


 responsible for creating an intuitive and user-friendly interface
 for the system. They need to understand the needs of the end-users
 and design interfaces that are easy to use and meet those needs.

**** King Richard
Another user of the system, he is a  businessman who wants to be able to easily manage his inventory
 using the data structures. He needs the data structures to be
 scalable and able to handle large amounts of data. He also has
 specific requirements for how the data structures should work in
 terms of performance and reliability.
1. King Richard (Business Analyst): * Roles: Business analyst, project
sponsor * Needs: Project success aligned with business objectives,
clear communication * Preferences: Project updates, regular meetings,
input in decision-making processes
 The project manager, responsible for overseeing the
 development and implementation of the system. They need to manage
 the team, allocate resources, and ensure that the project stays on
 schedule and within budget.




  How will they interact with the system?
  They will use the open ai assistant api to chat with programs.
  
- Define the functional requirements of the system.
  What are the features and capabilities that the system should provide?
  chatting with users.
  creating unimath models of user data.
  creating of coq proofs.
  
  How should the system behave in different scenarios and situations?
  each assistant will talk to user.
  it will help the user model concepts.
  different assistents will have different contexts.
  
  What are the inputs and outputs of the system?
  
- Define the non-functional requirements of the system.
  What are the quality attributes and standards that the system should meet? How should the system perform in terms of speed, reliability, security, usability, etc.?
- Specify the assumptions and constraints of the system.
  What are the conditions and factors that affect the system? What are the risks and uncertainties that the system faces? How can they be mitigated or resolved?
- Validate and verify the requirements.
  How can you ensure that the requirements are clear, consistent, complete, correct, and feasible? How can you test and evaluate the system against the requirements?

- nat: a type that represents natural numbers, defined inductively as either zero or the successor of another nat¹.
- bool: a type that represents Boolean values, defined inductively as either true or false¹.
- v3: a record type that has three fields: control, attrs, and expr².
- loc: a record type that has six fields: fname, line_nb, bol_pos, line_nb_last, bol_pos_last, and ep².
- UU: a type that represents the univalent universe, which is a collection of types that are equivalent to each other if and only if they are equal³.
- coq serlib data: a type that represents the serialization of Coq's internal data structures to JSON or S-expressions⁴.

- You have proposed an idea of using natural numbers to index the types in a signature of an algebra, and to construct sentences using those numbers that will have deep meaning.
- You have claimed that you can use the abstract algebra model of UniMath in Coq to create signatures and then show that terms in UniMath are equivalent to numbers and to different encodings of them via paths of proofs.
- You have asserted that you can lift statements from Coq into UniMath, and show that the UU type and the coq serlib data that describe the types fully are equivalent.
- You have suggested that the UU type can be anything, and that you can show that many different representations of the coq serlib data that describe the types fully are equivalent, and that they can be lifted into UU so that UU can reference itself via equivalent representations.

- Goal and scope: The goal of the mapping is to enable the interoperability and integration of unimath and serlib, two libraries that provide different perspectives and functionalities for Coq. The benefit of the mapping is to allow the users to access and manipulate the Coq data structures using the univalent point of view, and to use the unimath library to formalize and verify various mathematical concepts and results. The use cases and scenarios for the mapping include:

  - Quoting and unquoting the Coq data structures to and from the univalent universe, for example, to serialize and deserialize them, or to analyze and transform them.
  - Translating and importing the unimath library into the Coq standard library, or vice versa, for example, to reuse and extend the existing definitions and theorems, or to compare and contrast the different approaches and methodologies.
  - Implementing and testing the univalence axiom and other features of homotopy type theory in Coq, for example, to explore and experiment with the foundations and implications of univalent mathematics, or to verify and validate the correctness and consistency of the Coq kernel and the unimath library.

we can imagine there are very many different equivalent embeddings of a given record and constructor tuple into unimath, we can think of a whole range of mathematical embeddings that preserve information

well we can create a meta proof that will explore this in a combinatoric style
and then we can imagine that the embedding of serlib into UU is a function and we can create another function that takes that uu embedding and translates it into a stream of chunks of 4000 tokens to send to a left fold map function that has an external computational mathematical oracle attached (not the database server)
so we want to decode the encoded graphs, given an embedding structure from the serlib into uu graphs we can then decode that. we can generate these proofs using meta proofs.


- Source and target types: The source and target types of the mapping are the coq serlib data type and the UU type, respectively. The coq serlib data type is a type that represents the serialization of Coq's internal data structures to JSON or S-expressions, and it is defined and represented in the coq-serapi library. The UU type is a type that represents the univalent universe, which is a collection of types that are equivalent to each other if and only if they are equal, and it is defined and represented in the unimath library. The properties and features of the two types are as follows:

  - The coq serlib data type has the following properties and features:

    - It is a sum type that has many constructors, each corresponding to a different kind of Coq data structure, such as terms, types, statements, proofs, etc.
    - It contains various information and details about the Coq data structures, such as their locations, attributes, annotations, etc.
    - It is compatible and consistent with the Coq kernel and the Coq standard library, and it can be converted to and from the native Coq data structures using the coq-serapi library.
    - It is suitable and convenient for machine-to-machine interaction with Coq, and it can be serialized and deserialized to and from JSON or S-expressions using the coq-serapi library.

  - The UU type has the following properties and features:

    - It is a type former that takes a type as an argument and returns a type, and it is defined using the higher inductive type mechanism of unimath.
    - It contains only the essential information and features about the types, such as their identity types, equivalences, and univalences, and it ignores or abstracts away the irrelevant or incompatible information and features, such as their locations, attributes, annotations, etc.
    - It is based on and compatible with the univalence axiom and other features of homotopy type theory, and it can be used to construct and reason about the univalent categories and the univalent mathematics.
    - It is suitable and convenient for human-to-human interaction with Coq, and it can be used to formalize and verify various mathematical concepts and results using the unimath library.

- Translation functions: The translation functions of the mapping are the functions that convert a term of type **coq serlib data** into a term of type **UU**, and vice versa. The rules and algorithms for the translation are as follows:

  - To convert a term of type **coq serlib data** into a term of type **UU**, we need to perform the following steps:

    - Pattern match on the constructor of the term, and determine the corresponding type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
    - Recursively apply the translation function to the arguments of the term, if any, and obtain the translated terms of the corresponding types in the univalent universe.
    - Apply the **UU** type former to the type and the translated terms, and obtain the term of type **UU**.

  - To convert a term of type **UU** into a term of type **coq serlib data**, we need to perform the following steps:

    - Pattern match on the term, and extract the type and the terms of the type from the term of type **UU**.
    - Recursively apply the translation function to the terms of the type, if any, and obtain the translated terms of the corresponding types in the coq serlib data type.
    - Apply the corresponding constructor of the coq serlib data type to the type and the translated terms, and obtain the term of type **coq serlib data**.

  - To ensure that the translation is correct and consistent, we need to prove that the translation functions are well-defined, total, and inverse of each other, that is, for any term **t** of type **coq serlib data**, we have **t = translate_UU_to_serlib (translate_serlib_to_UU t)**, and for any term **u** of type **UU**, we have **u = translate_serlib_to_UU (translate_UU_to_serlib u)**.

- Equivalence relations: The equivalence relations of the mapping are the relations that compare and relate terms of type **coq serlib data** and terms of type **UU**. The criteria and conditions for equivalence are as follows:

  - Two terms of type **coq serlib data** are equivalent if and only if they have the same constructor and their arguments are equivalent, or if they are both terms of type **coq serlib data** that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
  - Two terms of type **UU** are equivalent if and only if they have the same type and their terms of the type are equivalent, or if they are both terms of type **UU** that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc.
  - A term of type **coq serlib data** and a term of type **UU** are equivalent if and only if they are both terms that represent the same type in the univalent universe, such as **bool**, **nat**, **UU**, etc., and their terms of the type are equivalent.

  - To prove that the equivalence is reflexive, symmetric, and transitive, we need to show that for any term **t** of type **coq serlib data**, we have **t ~ t**, where **~** denotes the equivalence relation, and for any term **u** of type **UU**, we have **u ~ u**. We also need to show that for any terms **t1**, **t2**, and **t3** of type **coq serlib data**, and any terms **u1**, **u2**, and **u3** of type **UU**, we have **t1 ~ t2** implies **t2 ~ t1**, and **t1 ~ t2** and **t2 ~ t3** imply **t1 ~ t3**, and similarly for the terms of type **UU**. Finally, we need to show that for any term **t** of type **coq serlib data** and any term **u** of type **UU**, we have **t ~ u** implies **u ~ t**, and **t ~ u** and **u ~ v** imply **t ~ v**, where **v** can be either a term of type **coq serlib data** or a term of type **UU**.



** futher work
after we have shown the embedding of serlib into unimath and its equivalence
we can then attack more meta reflection with :
- MetaCoq, a library that provides meta-programming features for Coq, such as quoting and unquoting, reflection, and verification.
- Ltac, a tactic language that allows you to write custom tactics and automate proofs.
- SSReflect, a proof language that provides a consistent alternative set of tactics to the standard basic tactics.
- Mathematical Components, a library that formalizes a large body of mathematics using the SSReflect proof language and the combinatorial style.


** edited output





*** answers

However, I have a few questions about the implementation of this
mapping:

1. What is the purpose of using the type former **UU** in the
translation function? it is a map or lookup or function returning a term of the corresponding type from the univalent
universe.

2. How would the translation function handle terms with
non-trivial constructors, such as lists or functions?
It will follow the serlib code for encoding and decoding the coq code.
we can study the code itself, reflecting over it,
loading it into unimath and then following it with the proof system to
show the steps of the coq and ocaml that transform the asts into sexpr and back.
We use this as our base pattern and rewrite and transform this function.
Would it recursively apply the translation function to their arguments and


3. What is the purpose
of defining equivalence relations for the mapping?

They could be used to prove that the translation function is well-defined,
total, and inverse of each other.
This will allow generating code that translates between forms
and languages.

  4. How would the proposed mapping handle
complex types or data structures, such as tuples or records, that
contain a mix of different types? We will have many different embeddings that we can learn with autoencoders or generative models.
