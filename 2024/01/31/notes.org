
grep -P '(mk[A-Z][a-z]+)' -o  mk.txt  |sort |uniq -c |sort -n
      1 mkConcise
      1 mkLambda
      1 mkPointed
      2 mkEnviron
      2 mkProd
      3 mkComponent
     13 mkElims
     29 mkApps


grep -P '(t[A-Z][A-Za-z]+)' -o  mk.txt  |sort |uniq -c |sort -n
      1 tCoFix
      1 tConstruct
      1 tFix
      1 tLambda
      1 tProj
      2 tInd
      2 tSymb
      3 tIn
      3 tRel
      5 tApp

Extracted from many COQ projects
see the counts of the types of terms.
give a narrative about programs that use
these terms in this frequency. What can we we say about them?
find ./*/* -name \*.v   -exec grep -P -o ' (t[A-Z][A-Za-z]+)'   {} \; | sort |uniq -c | sort -n > tnames.txt


      1  tNG
      1  tPxi
      1  tXC
      2  tAnd
      2  tCongApp
      2  tCongEq
      2  tCongLambda
      2  tCongPair
      2  tCongProd
      2  tCongRefl
      2  tCongSum
      2  tEq
      2  tEqToHeq
      2  tFunext
      2  tHeq
      2  tHeqRefl
      2  tHeqSym
      2  tHeqToEq
      2  tHeqTrans
      2  tHeqTransport
      2  tHeqTypeEq
      2  tIQ
      2  tMeta
      2  tNlam
      2  tOr
      2  tPack
      2  tPn
      2  tPnt
      2  tProjTe
      2  tRefl
      2  tSucc
      2  tTOk
      2  tTransport
      2  tUs
      3  tArrow
      3  tComparable
      3  tCtxDef
      3  tCtxType
      3  tFixCoFix
      3  tRels
      3  tSum
      3  tWty
      4  tCongPi
      4  tLe
      4  tOk
      4  tPi
      4  tProjT
      6  tImpl
      6  tTerm
      6  tUnit
      7  tCaseBrsType
      9  tGt
      9  tRle
     10  tRe
     11  tCtxCoFix
     11  tCtxEvar
     11  tCtxFix
     11  tCtxProj
     12  tOT
     13  tCtxHead
     13  tCtxTail
     14  tFixType
     14  tPair
     15  tCasePredProp
     16  tGl
     16  tRy
     16  tSigma
     18  tFloat
     18  tPs
     18  tSs
     19  tInt
     19  tNat
     20  tDef
     21  tFOF
     21  tTranslate
     22  tCtxLambda
     22  tCtxProd
     24  tST
     27  tCtxApp
     28  tBounded
     31  tSymb
     33  tCtxLetIn
     36  tDummy
     38  tCtxCase
     54  tSpecialize
     56  tPrim
     62  tCtxHole
     70  tCaseBrsProp
     93  tFixProp


Extracted from many COQ projects
see the counts of the types of terms.
lets examine a single term you choose and show how it relates to the others if at all.

these terms in this frequency. 
find ./*/* -name \*.v   -exec grep -P -o ' (t[A-Z][A-Za-z]+)'   {} \; | sort |uniq -c | sort -n > tnames.txt
     
    180  tIntro
    190  tCast
    234  tVar
    241  tBox
    324  tInd
    329  tConst
    359  tEvar
    374  tConstruct
    411  tCoFix
    469  tFix
    496  tProj
    549  tCase
    598  tLambda
    606  tLetIn
    678  tProd
    679  tRel
    790  tApp
    796  tSort



#+begin_src output


"tCase" is likely used in COQ projects to define cases for patterns or conditions within a system. For example, in a system that has multiple states,
"tCase" could be used to define the specific behavior of the system when it transitions from one state to another.





#+end_src



#+begin_src output

tInd (type declaration) and tApp (application) are both used in object-oriented programming to define the behavior of classes and instantiate them. However, tInd is typically used to declare a class with its properties and methods, while tApp is used to apply an object of that class to specific functions or operations.

tCast and tCoFix are related to type checking and type conversion. tCast is used to convert one data type to another, while tCoFix is used to check if a variable's value is of a certain type.

tVar (type variable) is often used in type theory and formal verification to represent variables that can take on any type. It allows for more generic programming and reasoning about the types involved.

tBox and tEvar are related to higher-order functions, which allow functions to accept other functions as arguments or return them as values. tBox is used to create a closure around a function, effectively creating a new function that takes no arguments but returns the original function applied to an argument. tEvar is used to represent a generic type variable in a higher-order function definition.

tFix (fixed) and tProj (projection) are related to pattern matching and function composition. tFix is used to create a new function that applies a fixed value to an expression, effectively creating a projection of the original function onto a specific argument. tProj is used to extract a single argument from a tuple or other structured data type.

GOOD!
tCase (pattern match) and tLambda are related to functional programming constructs for handling patterns and defining lambda functions.
tCase is used to perform pattern matching on an expression, allowing for different actions to be taken based on the structure of the input. tLambda is used to define a function that takes one or more arguments and returns a new function that applies those arguments to the original function.

tLetIn (let in) and tSort are related to functional programming constructs for defining recursive functions and sorting algorithms, respectively. tLetIn is used to define a recursive function with an accumulator argument that can be passed as an argument to itself. tSort is used to define various sorting algorithms based on comparison functions or other criteria.

#+end_src



#+begin_src output

tIntro: This term refers to the introduction of a new type in a COQ project. It typically includes information such as the name of the type, its purpose, and any necessary imports or dependencies. tCast is related to tIntro in that it may be used to cast an object of one type to another.

tVar: This term refers to a variable in a COQ program. It typically includes information such as its type, name, and usage within the program. tBox: This term likely refers to a data container or class in a COQ project. It may be used to encapsulate related variables and functions and provide a controlled way of accessing them.

tInd: This term could refer to an index in a COQ program. It may be used to reference specific elements within a data structure, such as an array or list. tConst: This term likely refers to a constant value in a COQ project. It may be defined and used throughout the program without being modified.

tEvar: This term could refer to an expression involving variables in a COQ program. It may include operations such as arithmetic, logical, or string manipulation. tConstruct is related to tEvar in that it may involve constructing new objects from existing ones using various operators and expressions.

tCoFix: This term likely refers to a function used to fix or correct errors in a COQ program. It may be used to identify and correct bugs, improve performance, or optimize code. tFix: This term is similar to tCoFix in that it may refer to a function used to fix errors or issues within a COQ program.

tProj: This term likely refers to a projection of data in a COQ program. It may involve selecting specific elements from a larger data structure or extracting relevant information from a set of values.


tLambda: This term likely refers to a lambda function in a COQ program. Lambda functions are anonymous functions that can be defined within an expression or assignment. They are often used for concise, functional programming.

tLetIn: This term could refer to a let-in statement in a COQ program. Let-in statements allow for the temporary assignment of a value to a variable while also allowing other statements to access that value without modifying it. tProd: This term likely refers to a product of two or more values in a COQ program. It may involve multiplication, division, or other arithmetic operations.

tRel: This term could refer to a relationship between two or more data elements in a COQ program. It may involve linking objects, associating values with keys, or defining hierarchical relationships between different types. tApp: This term likely refers to an application of a function or operation to a set of values in a COQ program. It may involve calling functions, applying operators, or iterating over data structures.

tSort: This term could refer to sorting a set of values in a COQ program. Sorting algorithms are commonly used to arrange data in a specific order based on certain criteria, such as numerical value or alphabetical order.

#+end_src



#+begin_src output

Term | Count
-----|-------
tIntro | 180
tCast | 190
tVar | 234
tBox | 241
tInd | 324
tConst | 329
tEvar | 359
tConstruct | 374
tCoFix | 411
tFix | 469
tProj | 496
tCase | 549
tLambda | 598
tLetIn | 606
tProd | 678
tRel | 679
tApp | 790
tSort | 796

#+end_src



#+begin_src output

I see that you've provided a list of term frequencies extracted from COQ projects. Based on this information, one term that stands out is "tBox". It has a frequency of 241, which is relatively high compared to the other terms listed.

To understand how "tBox" relates to the other terms, we can examine its definition and usage in the context of COQ projects. A "tBox" is a term used in the COQ language to define a new type or value type. It allows developers to create custom types that can be used throughout their codebase.

In terms of how it relates to other terms, "tBox" is often used in conjunction with other terms such as "tVar", "tInd", and "tEvar".
These terms are also used to define new types or value types,
but they have different characteristics.
 For example, "tVar" is used to define variables, "tInd" is used to define indices, and "tEvar" is used to define enumeration values.

Overall, "tBox" is an important term in the COQ language that allows developers to create custom types that can be used throughout their codebase. Its frequency in this particular list suggests that it is a commonly used term in many COQ projects.

#+end_src



#+begin_src output
It seems like you have extracted a list of terms from various COQ
projects and counted their frequencies. The list includes terms such
as `tIntro`, `tCast`, `tVar`, `tBox`, etc.

One term that stands out is `tLambda`. It has the highest frequency
count of 598, which means it appears the most frequently in these COQ
projects. This suggests that lambda functions are a commonly used
construct in these projects.

It's also worth noting that some terms have similar counts, such as
`tInd` and `tEvar`, both with a frequency count of 359. This suggests
that these terms may be related or have similar functionality in the
context of COQ projects.

Overall, examining the frequencies of these terms can provide insights
into the common constructs and patterns used in COQ projects.


#+end_src



#+begin_src output

From the given command, we can see that the terms are extracted from
various COQ projects and counted in a file named tnames.txt. The
command uses grep to search for all occurrences of specific terms in
files with a .v extension. The resulting terms are then sorted,
counted, and sorted again in descending order of frequency.

Let's examine the term "tLambda" in relation to the others. From the
tnames.txt file, we can see that it has a count of 598, which makes it
one of the most common terms.

When comparing "tLambda" with other terms, we can see that it is used
for defining lambda functions in COQ. Lambda functions are commonly
used to define anonymous functions and higher-order functions in COQ
programs.

In contrast, terms like "tInd" and "tCoFix" may be related to the
Inductive and Coq Fixpoint rules respectively, which are used to prove
the correctness of mathematical functions in COQ.

Overall, the frequency and usage of each term may vary depending on
the specific context and requirements of the COQ project it is being
used in.

#+end_src



#+begin_src output

One term that stands out in this frequency list is "tFix". This term
occurs 496 times, which is the second-most frequent term on the list
after "tProj" (which occurs 549 times).

It's worth noting that "tFix" and "tProj" are both related to type
constructors in Coq. Specifically, "tFix" represents a fixed point of
a type constructor (i.e., a type that cannot be instantiated by an
instantiation of the constructor), while "tProj" represents a
projection operation on a record type (i.e., selecting one or more
fields from a record).

It's possible that the high frequency of "tFix" and "tProj" in this
dataset reflects the prevalence of type constructors in Coq
projects. Alternatively, it could be that these terms are particularly
difficult to handle in automated testing or analysis, which would
explain why they occur more frequently than other types in the
dataset.

Overall, the frequency list provides a useful snapshot of the types
that are most commonly found in Coq projects. It's possible that
analyzing the distribution of these types could provide insights into
common coding patterns or areas for improvement in automated testing
and analysis tools.

#+end_src



Consider the following statistics from coq metaprogamming examples
lets reinterpret them as metaphors for archtypes of human culture and meme patterns.
invoke the muses and thier mother mnemosyne and grandmother gaia and then consider athenas wisdom.
uranus represents the second type created and all other types are grandchildren of that type.
we can think of him as the first inductive type.

Consider the following statistics about the type of inductive types extracted
from coq metaprogramming examples
lets reinterpret them as stories about data types. 


#+begin_src shell  :results output
grep tInd tnames_usage.txt  | sed -e's;  ;;g' |sort |uniq -c |sort -n -r

#+end_src



#+RESULTS:
#+begin_example
     18 | tInd _ _
     12 | tInd (mkInd i k) u =>
     10 | tInd _ _ => true
      9 | tInd i univs => lookup_tsl_table' E (IndRef i)
      8 | tInd i univs =>
      6 | tInd i u' => tInd i (subst_instance_instance u u')
      6 | tInd _ _ as t
      5 | tInd i u => "Ind(" ++ string_of_inductive i ++ "," ++ string_of_universe_instance u ++ ")"
      4 | tInd _ u => closedu_instance k u
      4 | tInd (mkInd ind i) u => lookup_ind_type Σ ind i u
      4 | tInd i u, tInd i' u' => eq_inductive i i' && eqb_univ_instance φ u u'
      4 | tInd i u, tInd i' u' =>
      4 | tInd i _ => tmDefinition "sigma_ind" i
      4 | tInd ind u => Some (ind, u)
      3 | tRel _ | tVar _ | tSort _ | tConst _ _ | tInd _ _ | tConstruct _ _ _ => t
      3 tProd x x0 x1 = it_mkProd_or_LetIn x2 (mkApps (tInd i u) x3) -> exists (L' : context) (l' : list term), x1 = it_mkProd_or_LetIn L' (mkApps (tInd i u) l').
      3 | tInd (mkInd ind i) u =>
      3 | tInd i u => true
      3 | tInd i u => tInd i u
      3 | tInd i univs => lookup_tsl_table' (snd ΣE) (IndRef i)
      3 | tInd ind u => Some ind
      3 | tInd ind u =>
      3 | tInd (ind : inductive) (u : universe_instance)
      3 | tInd ind args =>
      3 | tApp (tInd _ _) _ => true
      3 | Ast.tInd c u => tInd c u
      2 | tInd _ u => closedu_instance u
      2 | tInd _ _ => ret _
      2 | tInd i u, tInd i' u' => eq_ind i i' && eqb_univ_instance φ u u'
      2 | tInd i u => "Ind(" ^ string_of_inductive i ^ "," ^ string_of_universe_instance u ^ ")"
      2 | tInd i _ => tmMsg (string_of_kername i.(inductive_mind))
      2 | tInd i _ => tmDefinition "prod_ind" i
      2 | tInd ind u => fun wf =>
      2 | tInd ind u
      2 | tInd (ind : inductive) (u : Instance.t)
      2 | tInd ind []
      2 | tConst _ _ | tInd _ _ | tConstruct _ _ _ => True
      2 | tConst _ _ | tInd _ _ | tConstruct _ _ _ => true
      1 | tInd _ _ => true;
      1 | tInd _ _ | tConstruct _ _ _ => t
      1 | tInd _ _ => ret true
      1 | tInd (mkInd nm i) u , [] => match (plookup_env Σb nm) with
      1 | tInd (mkInd nm i) _ => match (plookup_env Σb nm) with
      1 | tInd (mkInd name i) u => tInd (mkInd (name_after_dot name) i)u
      1 | tInd (mkInd (modp, n) _) _ => "type_" ++ String.of_string (name_after_dot (String.to_string n))
      1 | tInd kn u := !%prg
      1 | tInd i _ => tmMsg i.(inductive_mind)
      1 | tInd ind u => tmReturn (IndRef ind)
      1 | tInd ind u => t
      1 | tInd ind u => Some (ind, [])
      1 | tInd ind _ => unit
      1 | tInd ind u := et_view_ind ind u;
      1 | tInd {| inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat"); inductive_ind := 0 |} _ =>
      1 | tInd {| inductive_mind := id ; inductive_ind := _ |} [] =>
      1 | tInd ind _=> isSome (lookup_inductive Σ ind)
      1 | tInd (ind : inductive) (ui : universe_instance)
      1 | tInd ind _ => ind.(inductive_mind)
      1 | tInd ind _ => fun _ => TInd ind
      1 | tInd _ _ := False;
      1 | tInd c u => tInd c u
      1 | tInd c u => inductive_mind c
      1 | tInd a _ =>tmPrint a;;tmFail "tInd is not supported (probably there is a type not in prenex-normal form)" 
      1 | tInd _ _ => []

#+end_example

** out 2


#+begin_src output

The statistics provided seem to be related to a programming language
called Coq and its metaprogramming capabilities. Here are some
possible metaphors that could help explain the meaning of the numbers:

* `18 | tInd _ _`: There are 18 instances where the term `tInd`
* appears with two arguments, both of which are underscores (i.e.,
* empty identifiers). This may indicate that the code being analyzed
* is defining or using a term called `tInd` that takes two arguments
* and does not perform any operations on them.  `12 | tInd (mkInd i k)
* u =>`: There are 12 instances where the term `tInd` appears with
* three arguments, one of which is a function call to another term
* called `mkInd`. This may suggest that the code being analyzed is
* defining or using a term called `tInd` that takes three arguments
* and performs some operation on them.  `10 | tInd _ _ => true`: There
* are 10 instances where the term `tInd` appears with two arguments,
* both of which are underscores, followed by a boolean value (i.e.,
* either true or false). This may indicate that the code being
* analyzed is defining or using a term called `tInd` that takes two
* arguments and returns a boolean value based on those arguments.  `9
* | tInd i univs => lookup_tsl_table' E (IndRef i)`: There are 9
* instances where the term `tInd` appears with three arguments, one of
* which is an identifier `i`, followed by two arguments that are both
* references to some other term or object. This may suggest that the
* code being analyzed is defining or using a term called `tInd` that
* takes three arguments and performs some operation on them based on
* those arguments, including looking up information in a table.  `8 |
* tInd i univs =>`: There are 8 instances where the term `tInd`
* appears with two arguments, one of which is an identifier `i`,
* followed by another argument that is a reference to some other term
* or object. This may suggest that the code being analyzed is defining
* or using a term called `tInd` that takes two arguments and performs
* some operation on them based on those arguments.  `6 | tInd i u' =>
* tInd i (subst_instance_instance u u')`: There are 6 instances where
* the term `tInd` appears with two arguments, one of which is an
* identifier `i`, followed by another argument that is a function call
* to another term called `subst_instance_instance`. This may indicate
* that the code being analyzed is defining or using a term called
* `tInd` that takes two arguments and performs some operation on them
* based on those arguments.  `6 | tInd _ _ as t`: There are 6
* instances where the term `tInd` appears with three arguments, one of
* which is an identifier `_`, followed by two other arguments. One of
* these arguments is an identifier called `as`, followed by another
* argument that is a reference to some other term or object. This may
* suggest that the code being analyzed is defining or using a term
* called `tInd` that takes three arguments and performs some operation
* on them based on those arguments, including assigning a new name
* (i.e., an alias) to one of the arguments.  `6 inds ind u l =
* List.rev (mapi (fun i _ => tInd {| inductive_mind := ind;
* inductive_ind := i |} u) l).`: There are 6 instances where the term
* `tInd` appears with four arguments, one of which is an identifier
* called `ind`, followed by three other arguments. One of these
* arguments is a function call to another term called `mapi`, followed
* by a list of three elements. This may suggest that the code being
* analyzed is defining or using a term called `tInd` that takes four
* arguments and performs some operation on them based on those
* arguments, including reversing the order of the elements in a list.
* `5 | tInd i u => "Ind(" ++ string_of_inductive i ++ "," ++
* string_of_universe_instance u ++ ")"`: There are 5 instances where
* the term `tInd` appears with two arguments, one of which is an
* identifier `i`, followed by another argument that is a reference to
* some other term or object. This may indicate that the code being
* analyzed is defining or using a term called `tInd` that takes two
* arguments and performs some operation on them based on those
* arguments, including constructing a string representation of the
* arguments.  `5 | Some (tInd i _univ) =>`: There are 5 instances
* where the term `tInd` appears with one argument, an identifier
* called `i`, followed by an underscore and another term or
* object. This may suggest that the code being analyzed is defining or
* using a term called `tInd` that takes one argument and performs some
* operation on it based on that argument.  `4 Σ ;;; Γ |- c : mkApps
* (tInd ind u) args ->`: There are 4 instances where the 
#+end_src


* 
#+begin_src output

1. The number of lines that contain "tInd" is 27. This represents the
number of occurrences of the term "tInd" in a given codebase or
document.  2. The most common line containing "tInd" has a count of 6,
indicating that this term is used frequently throughout the codebase.
3. The second-most common line containing "tInd" has a count of 5,
indicating that it is also a commonly used term in the codebase.
4. The third-most common line containing "tInd" has a count of 4,
indicating that it is still a relatively frequently used term in the
codebase.  5. The line containing "Σ ;;; Γ |- c : mkApps (tInd ind u)
args ->" has the highest count of 4, indicating that this line is an
important one in the context of the codebase or document.  6. The line
containing "tRel _ | tVar _ | tSort _ | tConst _ _ | tInd _ _ |
tConstruct _ _ _ => t" has a count of 3, indicating that this term is
used less frequently than some other terms in the codebase.  7. The
line containing "tProd x x0 x1 = it_mkProd_or_LetIn x2 (mkApps (tInd i
u) x3) -> exists (L' : context) (l' : list term), x1 =
it_mkProd_or_LetIn L' (mkApps (tInd i u) l')." has a count of 3,
indicating that this term is used less frequently than some other
terms in the codebase.  8. The line containing "tInd (mkInd ind i) u
=> lookup_ind_type Σ ind i u" has a count of 1, indicating that this
term is used infrequently in the context of the codebase or document.

#+end_src

 
#+begin_src output

* The number of lines with "tInd" as a symbol indicates the number of
* times the term constructor for inductive types was used.  The number
* of lines with a specific argument, such as "(mkInd i k)" or "u",
* being passed to the "tInd" constructor, gives an idea of how often
* those arguments were used.  The number of lines with "as" and "=>"
* indicates the number of times the "as" keyword was used in
* metaprogramming expressions.  The number of lines with "Some (tInd i
* _univ)" and "exact" indicate that some constructors or properties of
* "tInd" were being used to define terms.  The number of lines with "Σ
* ;;; Γ |- c : mkApps (tInd ind u) args ->", "tRel", and "tProd"
* indicate the use of type theory concepts such as types,
* constructors, and product types.  
#+end_src

 
#+begin_src output

Based on the given statistics, here are some possible metaphors:

3. tmDefinition "sigma\_ind" i represents a term
definition for a specific inductive type, using a given index variable
i.

5. lookup\_tsl\_table' E (IndRef i) represents a
function that looks up information about a specific term, based on its
index variable i, in a table of terms associated with a given
environment E.

6. mapi (fun i _ => tInd {| inductive\_mind := ind;
inductive\_ind := i |} u) l represents a function that maps each
element of a list l to a specialized instance of a term, using the
given index variable i and a specific universe variable u.

7. Some
(tInd i _univ) represents an existential quantifier that asserts the
existence of a specific term t, with a specific index variable i and a
specific universe variable univ.

8. exact (IndRef (mkInd kn i), tInd
(mkInd kn' i) []). represents a proof that two terms are equivalent,
based on their construction using a specific inductive type, index
variable i, and universe variables u and u'.


#+end_src




**out1

#+begin_src output The given Coq code declares a Coq module called
"Vectors" with various definitions and properties for vectors. The
module includes types like "Vector" and "VectorMap", as well as
functions for basic vector operations such as addition,
multiplication, and conversion to and from other data structures.

Here is a summary of the main definitions in the Vectors module:

* `Vector`: A type for vectors with a fixed dimension (or length) and
* elements of arbitrary type. The vector has a constructor that takes
* an array of its elements.  `VectorMap`: A type for dictionaries
* (i.e., associative maps) where keys are unique and have a
* corresponding value in the dictionary. It uses a fixed-size array to
* store key-value pairs.  `Vectors.vector_eq`: An equality relation
* for vectors, which compares two vectors of the same dimension and
* type.  `Vectors.vector_add`: A function that takes two vectors of
* the same dimension and type, and returns their element-wise sum.
* `Vectors.vector_mul`: A function that takes a vector and a scalar
* value, and returns the product of the vector elements multiplied by
* the scalar.  `Vectors.vector_map`: A function that takes a vector
* and a function, and returns a new vector with the elements
* transformed by the given function.  `Vectors.to_vec_from_dict`: A
* function that takes a dictionary and a vector size (i.e., a
* fixed-size array of keys), and returns the corresponding values from
* the dictionary as a vector of the same length.
* `Vectors.from_vec_to_dict`: A function that takes a vector and a set
* of key-value pairs, and returns a new dictionary with the specified
* keys and values.

The Vectors module also includes other helper functions for working
with vectors and dictionaries, such as `vector_length`, `vector_elem`,
`map_filter`, and others.  
#+end_src

 


#+begin_src output
 ```scala object CoqCodeGenerator {

  // Generate a Coq code for a given type signature def
  generateCode(signature: TypeSignature): String = { val (name, args,
  returnType) = signature.decompose()

    // Check if the type is an inductive type val isInductive =
    signature.isInductive

    // Generate the Coq code for the type declaration val code =
    s"Coq.Init.Datatypes.$name (${args.mkString(", ")})
    $returnType${\n}"

    // If the type is inductive, generate the induction axiom if
    (isInductive) { val inductionAxiom = s"
    Coq.Init.Datatypes.inductive\n" code += s" (${args.mkString(",
    ")}) $returnType${\n}" code += s" \t$inductionAxiom" }

    // If the type is defined recursively, generate the recursion
    relation if (signature.isRecursive) { val recursionRelation = s"
    Coq.Init.Datatypes.recursive\n" code += s" (${args.mkString(",
    ")}) $returnType${\n}" code += s" \t$recursionRelation" }

    // If the type has a parameter, generate the Coq code for the
    parameter declaration and instantiation if
    (signature.hasParameter) { val paramName =
    signature.parameter.name val paramType = signature.parameter.type

      code += s" Coq.Init.Datatypes.param\n" code += s" (${paramName}:
      $paramType)${\n}" }

    code } } ``` To use the `generateCode` method, you need to provide
  a type signature as an argument. For example: ```scala val signature
  = TypeSignature("List", List[Int], Option[Int]) val coqCode =
  CoqCodeGenerator.generateCode(signature) println(coqCode) ``` This
  will generate the following Coq code: ```css Coq.Init.Datatypes.List
  (A, B) Coq.Init.Datatypes.Option A Coq.Init.Datatypes.param (x0 : A)
  Coq.Init.Datatypes.A Coq.Init.Datatypes.inductive (A, B)
  Coq.Init.Datatypes.Option A ``` 
#+end_src




*new pattern

9. `tInd i u => "Ind(" ++ string_of_inductive i ++ "," ++ string_of_universe_instance u ++ ")"` - This is a type that takes two arguments: an induction pattern `i`, and a universe instance `u`. It returns the name of the inductive type with the given kernel function, which may be used to access information about the inductive type or to perform operations on it.

         5 | tInd i u => "Ind(" ++ string_of_inductive i ++ "," ++ string_of_universe_instance u ++ ")"

	 now lets look for patterns like string_of


#+begin_src shell
grep string_of tnames_usage.txt

#+end_src




Lets consider the following results.
we are considering usage of metacoq tInd inductive types and TApp application and other types of ASts.
Around those lines we look for string_of.
lets expand on each term with our knowledge and creativity. 
#+begin_src shell  :results output
grep -P -o "(string_of_[a-z_]+)" tnames_usage.txt | sed -e 's;  ;;g' |sort |uniq -c  | sort -n -r
#+end_src

#+RESULTS:
#+begin_example
    180 string_of_term
    120 string_of_nat
     64 string_of_name
     49 string_of_list
     45 string_of_inductive
     36 string_of_kername
     34 string_of_universe_instance
     20 string_of_def
     12 string_of_sort
      5 string_of_aname
      4 string_of_branch
      3 string_of_relevance
      2 string_of_prim_int
      2 string_of_prim
      2 string_of_predicate
      2 string_of_float
      2 string_of_env_error
      2 string_of_case_info
      1 string_of_term_tree
      1 string_of_int
#+end_example


** good output

*** edited part 1
This can be used for,This can be useful ->t_c_b_use
A string representation of -> a_str_r_o
which is a special type of term that represents an -> s_typ_o_term_t_rep_a

`string_of_term`: a_str_r_o a term in the system. t_c_b_use easy printing and displaying of terms.
`string_of_nat`: a_str_r_o a natural number value. t_c_b_use when dealing with integer values, especially in arithmetic operations.
`string_of_name`: a_str_r_o a name, s_typ_o_term_t_rep_aentity or object in the system. t_c_b_use easy identification and manipulation of names.
`string_of_list`: a_str_r_o a list, s_typ_o_term_t_rep_a collection of values. t_c_b_use when dealing with lists of values.
`string_of_inductive`: a_str_r_o an inductive type, s_typ_o_term_t_rep_a set of values based on certain rules or properties. This can be used to work with inductive types and their associated functions.
`string_of_kername`: a_str_r_o a kername, which is a unique identifier for a term. Kernames are used for efficient referencing of terms in the system.
`string_of_universe_instance`: a_str_r_o a universe instance, which is an object that represents the current context or scope in which terms are defined. t_c_b_use when working with different scopes or universes in the system.
`string_of_def`: a_str_r_o a definition of a term or function. t_c_b_use for easy identification and manipulation of definitions.
`string_of_sort`: a_str_r_o a sort, which is an ordering relation that defines how terms are related to each other. t_c_b_use when working with sorted types and their associated functions.
`string_of_aname`: a_str_r_o an aname, which is an abbreviation for a term. Anames are used for convenient referencing of frequently used terms in the system.
`string_of_branch`: a_str_r_o a branch, which is a separate line of development or research within a theory. t_c_b_use when working with different branches of mathematics in the system.
`string_of_relevance`: a_str_r_o the relevance of a term or function. Relevance is a measure of how important or significant a term or function is in a given context. t_c_b_use for prioritizing terms and functions in certain operations.
`string_of_prim_int`: a_str_r_o a primitive integer value, which is an integer value that cannot be decomposed into smaller integers. t_c_b_use when dealing with basic integer values.
`string_of_prim`: a_str_r_o a primitive value, which is a value that cannot be derived from other values. t_c_b_use for basic values such as integers and floats.
`string_of_predicate`: a_str_r_o a predicate, which is a function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
`string_of_float`: a_str_r_o a floating point value. Floats are useful for representing real numbers with decimal values.
`string_of_env_error`: a_str_r_o an environment error, which is an error that occurs when a term or function cannot be found in the current environment. t_c_b_use for diagnosing issues with the system.

`string_of_term_tree`: a_str_r_o a term tree, which is a hierarchical structure that represents the relationships between terms in the system. t_c_b_use for visualizing the structure of the system.
`string_of_int`: a_str_r_o an integer value. t_c_b_use when dealing with basic integer values.

**** outpu1

#+begin_src output

This is a list of string representations of various types of terms that can be used in the system. Each term is represented by a special type term called `string_of_term`. The `t_c_b_use` notation indicates what each term is useful for. Here's a brief explanation of each term:

* `a_str_r_o`: A string representation of an entity or object in the system. This term can be used for easy identification and manipulation of names.
* `a_nat`: A natural number value that can be used when dealing with integer values, especially in arithmetic operations.
* `s_typ_o_term_t_rep_a`: An object representing a term in the system. This term is used for printing and displaying of terms.
* `string_of_inductive`: A string representation of an inductive type, which is a set of values based on certain rules or properties. This term can be used to work with inductive types and their associated functions.
* `kername`: A unique identifier for a term that is used for efficient referencing of terms in the system.
* `universe_instance`: An object representing the current context or scope in which terms are defined. This term can be used when working with different scopes or universes in the system.
* `def`: A string representation of a definition of a term or function. This term is useful for easy identification and manipulation of definitions.
* `sort`: An ordering relation that defines how terms are related to each other. This term can be used when working with sorted types and their associated functions.
* `aname`: An abbreviation for a term that is used for convenient referencing of frequently used terms in the system.
* `branch`: A separate line of development or research within a theory. This term can be used when working with different branches of mathematics in the system.
* `relevance`: A measure of how important or significant a term or function is in a given context. This term can be used for prioritizing terms and functions in certain operations.
* `prim_int`: A primitive integer value that cannot be decomposed into smaller integers. This term can be used when dealing with basic integer values.
* `prim`: A primitive value that cannot be derived from other values. This term can be used for basic values such as integers and floats.
* `predicate`: A function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
* `float`: A floating point value. Floats are useful for representing real numbers with decimal values.
* `env_error`: An environment error that occurs when a term or function cannot be found in the current environment. This term can be used for diagnosing issues with the system.

* `term_tree`: A hierarchical structure that represents the relationships between terms in the system. This term can be used for visualizing the structure of the system.
* `int`: An integer value that can be used when dealing with basic integer values.
#+end_src
#+begin_src output

The `string_of_term` function is a term representation in the system that can be used for easy printing and displaying of terms. It takes a term as its input and returns a string representation of the term, which can be useful in various contexts. For example, when you need to print out the value of a term or display it in a report, you can use `string_of_term` function to get a readable string representation of the term.

The `string_of_nat` function is similar to `string_of_term`, but it takes an integer value as its input and returns a string representation of the value. This can be useful when dealing with arithmetic operations or comparing values in arithmetic expressions.

The `string_of_name` function takes a name (either an entity or object in the system) as its input and returns a string representation of the name. This can be useful for easy identification and manipulation of names, especially when dealing with complex structures or hierarchies of entities or objects.

The `string_of_list` function takes a list (a collection of values) as its input and returns a string representation of the list. This can be useful when dealing with lists of values in various contexts, such as sorting or comparing lists, or passing lists as arguments to functions.

The `string_of_inductive` function takes an inductive type (a set of values based on certain rules or properties) as its input and returns a string representation of the inductive type. This can be useful when working with inductive types and their associated functions, such as proving theorems about the properties of the inductive type.

The `string_of_kername` function takes a kername (a unique identifier for a term) as its input and returns a string representation of the kername. Kernames are used for efficient referencing of terms in the system, especially when dealing with large or complex systems where naming conventions may be difficult to maintain.

The `string_of_universe_instance` function takes a universe instance (an object that represents the current context or scope in which terms are defined) as its input and returns a string representation of the universe instance. This can be useful when working with different scopes or universes in the system, as it allows you to easily identify which universe is being used.

The `string_of_def` function takes a definition of a term or function as its input and returns a string representation of the definition. This can be useful for easy identification and manipulation of definitions, especially when working with large or complex systems where definitions may be scattered across different files or modules.

The `string_of_sort` function takes a sort (an ordering relation that defines how terms are related to each other) as its input and returns a string representation of the sort. Sorts are used in various contexts, such as sorting lists or comparing values, and it can be useful to have a string representation of the sort for easy identification and manipulation.

The `string_of_aname` function takes an aname (an abbreviation for a term) as its input and returns a string representation of the aname. Anames are often used for frequently used terms in the system, to make it easier to write and read code.

The `string_of_branch` function takes a branch (a separate line of development or research within a theory) as its input and returns a string representation of the branch. Branches can be useful when working with different branches of mathematics in the system, as they allow you to organize your work into logical units.

The `string_of_relevance` function takes a term or function as its input and returns a string representation of the relevance of the term or function. Relevance is a measure of how important or significant a term or function is in a given context, and it can be useful for prioritizing terms and functions in certain operations.

The `string_of_prim_int` function takes a primitive integer value as its input and returns a string representation of the value. Primitive integers are
#+end_src
#+begin_src output

*** edited part 2

These are useful string representations of various types of terms and values in the system:

* `string_of_term`: A representation of a term in the system. This can be used for easy printing and displaying of terms.
* `string_of_nat`: A representation of a natural number value. This is useful when dealing with integer values, especially in arithmetic operations.
* `string_of_name`: A representation of a name, entity or object in the system. This can be used for easy identification and manipulation of names.
* `string_of_list`: A representation of a list, which is a collection of values. This can be used when dealing with lists of values.
* `string_of_inductive`: A representation of an inductive type, which is a set of values based on certain rules or properties. This can be used to work with inductive types and their associated functions.
* `string_of_kername`: A representation of a kername, which is a unique identifier for a term. Kernames are used for efficient referencing of terms in the system.
* `string_of_universe_instance`: A representation of a universe instance, which is an object that represents the current context or scope in which terms are defined. This can be used when working with different scopes or universes in the system.
* `string_of_def`: A representation of a definition of a term or function. This can be used for easy identification and manipulation of definitions.
* `string_of_sort`: A representation of a sort, which is an ordering relation that defines how terms are related to each other. This can be used when working with sorted types and their associated functions.
* `string_of_aname`: A representation of an aname, which is an abbreviation for a term. Anames are used for convenient referencing of frequently used terms in the system.
* `string_of_branch`: A representation of a branch, which is a separate line of development or research within a theory. This can be used when working with different branches of mathematics in the system.
* `string_of_relevance`: A representation of the relevance of a term or function. Relevance is a measure of how important or significant a term or function is in a given context. This can be used for prioritizing terms and functions in certain operations.
* `string_of_prim_int`: A representation of a primitive integer value, which is an integer value that cannot be decomposed into smaller integers. This can be used when dealing with basic integer values.
* `string_of_prim`: A representation of a primitive value, which is a value that cannot be derived from other values. This can be used for basic values such as integers and floats.
* `string_of_predicate`: A representation of a predicate, which is a function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
* `string_of_float`: A representation of a floating point value. Floats are useful for representing real numbers with decimal values.
* `string_of_env_error`: A representation of an environment error, which is an error that occurs when a term or function cannot be found in the current environment. This can be used for diagnosing issues with the system.

* `string_of_term_tree`: A representation of a term tree, which is a hierarchical structure that represents the relationships between terms in the system. This can be used for visualizing the structure of the system.
#+end_src
#+begin_src output

* string\_of\_term: a string representation of a term in the system. It can be used for easy printing and displaying of terms.
* string\_of\_nat: a string representation of a natural number value. It is useful when dealing with integer values, especially in arithmetic operations.
* string\_of\_name: a string representation of a name or entity or object in the system. It can be used for easy identification and manipulation of names.
* string\_of\_list: a string representation of a list of values. It is useful when dealing with lists of values.
* string\_of\_inductive: a string representation of an inductive type, which is a set of values based on certain rules or properties. It can be used to work with inductive types and their associated functions.
* string\_of\_kername: a string representation of a kername, which is a unique identifier for a term. Kernames are used for efficient referencing of terms in the system.
* string\_of\_universe\_instance: a string representation of a universe instance, which is an object that represents the current context or scope in which terms are defined. It can be used when working with different scopes or universes in the system.
* string\_of\_def: a string representation of a definition of a term or function. It can be used for easy identification and manipulation of definitions.
* string\_of\_sort: a string representation of a sort, which is an ordering relation that defines how terms are related to each other. It can be used when working with sorted types and their associated functions.
* string\_of\_aname: a string representation of an abbreviation for a term. Anames are used for convenient referencing of frequently used terms in the system.
* string\_of\_branch: a string representation of a branch, which is a separate line of development or research within a theory. It can be used when working with different branches of mathematics in the system.
* string\_of\_relevance: a string representation of the relevance of a term or function. Relevance is a measure of how important or significant a term or function is in a given context. It can be used for prioritizing terms and functions in certain operations.
* string\_of\_prim\_int: a string representation of a primitive integer value, which is an integer value that cannot be decomposed into smaller integers. It can be used when dealing with basic integer values.
* string\_of\_prim: a string representation of a primitive value, which is a value that cannot be derived from other values. It can be used for basic values such as integers and floats.
* string\_of\_predicate: a string representation of a predicate, which is a function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
* string\_of\_float: a string representation of a floating point value. Floats are useful for representing real numbers with decimal values.
* string\_of\_env\_error: a string representation of an environment error, which is an error that occurs when a term or function cannot be found in the current environment. It can be used for diagnosing issues with the system.

* string\_of\_term\_tree: a string representation of a term tree, which is a hierarchical structure that represents the relationships between terms in the system. It can be used for visualizing the structure of the system.
* string\_of\_int: a string representation of an integer value. It can be used when dealing with basic integer values.
#+end_src
#+begin_src output


#+end_src

****
please shorten
These strings are used to represent different types of terms in a mathematical system. The string representation makes it easier to print, display, and manipulate these terms using standard Python functions such as `str()` and `print()`. The following list provides an explanation of each type of term and its corresponding string representation:

1. `string_of_term` - A string representation of a term in the system.
2. `string_of_nat` - A string representation of a natural number value.
3. `string_of_name` - A string representation of a name, entity or object in the system.
4. `string_of_list` - A string representation of a list, which is a collection of values.
5. `string_of_inductive` - A string representation of an inductive type, which is a set of values based on certain rules or properties.
6. `string_of_kername` - A string representation of a kername, which is a unique identifier for a term.
7. `string_of_universe_instance` - A string representation of a universe instance, which is an object that represents the current context or scope in which terms are defined.
8. `string_of_def` - A string representation of a definition of a term or function.
9. `string_of_sort` - A string representation of a sort, which is an ordering relation that defines how terms are related to each other.
10. `string_of_aname` - A string representation of an aname, which is an abbreviation for a term. Anames are used for convenient referencing of frequently used terms in the system.
11. `string_of_branch` - A string representation of a branch, which is a separate line of development or research within a theory.
12. `string_of_relevance` - A string representation of the relevance of a term or function. Relevance is a measure of how important or significant a term or function is in a given context.
13. `string_of_prim_int` - A string representation of a primitive integer value, which is an integer value that cannot be decomposed into smaller integers.
14. `string_of_prim` - A string representation of a primitive value, which is a value that cannot be derived from other values.
15. `string_of_predicate` - A string representation of a predicate, which is a function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
16. `string_of_float` - A string representation of a floating point value. Floats are useful for representing real numbers with decimal values.
17. `string_of_env_error` - A string representation of an environment error, which is an error that occurs when a term or function cannot be found in the current environment.

19. `string_of_term_tree` - A string representation of a term tree, which is a hierarchical structure that represents the relationships between terms in the system.

**** output

1. String representation of a term in the system.
2. String representation of a natural number value.
3. String representation of a name, entity or object in the system.
4. String representation of a list, which is a collection of values.
5. String representation of an inductive type, which is a set of values based on certain rules or properties.
6. String representation of a kername, which is a unique identifier for a term.
7. String representation of a universe instance, which is an object that represents the current context or scope in which terms are defined.
8. String representation of a definition of a term or function.
9. String representation of a sort, which is an ordering relation that defines how terms are related to each other.
10. String representation of an aname, which is an abbreviation for a term. Anames are used for convenient referencing of frequently used terms in the system.
11. String representation of a branch, which is a separate line of development or research within a theory.
12. String representation of the relevance of a term or function. Relevance is a measure of how important or significant a term or function is in a given context.
13. String representation of a primitive integer value, which is an integer value that cannot be decomposed into smaller integers.
14. String representation of a primitive value, which is a value that cannot be derived from other values.
15. String representation of a predicate, which is a function that takes one or more arguments and returns true or false. Predicates are used to define properties and relationships between terms in the system.
16. String representation of a floating point value. Floats are useful for representing real numbers with decimal values.
17. String representation of an environment error, which is an error that occurs when a term or function cannot be found in the current environment.

19. String representation of a term tree, which is a hierarchical structure that represents the relationships between terms in the system.

*** Rest
#+begin_src output

From the given results, it looks like the Coq library has a variety of string\_of types. Here is a brief explanation of each type:

* `string_of_term`: This type represents a string representation of a term in the Coq language.
* `string_of_nat`: This type represents a string representation of a natural number, which can be used to represent integers in Coq.
* `string_of_name`: This type represents a string representation of a name in the Coq library.
* `string_of_list`: This type represents a string representation of a list in Coq.
* `string_of_inductive`: This type represents a string representation of an inductive type in Coq.
* `string_of_kername`: This type represents a string representation of a kernel name in Coq.
* `string_of_universe_instance`: This type represents a string representation of a universe instance in Coq.
* `string_of_def`: This type represents a string representation of a definition in Coq.
* `string_of_sort`: This type represents a string representation of a sort in Coq.
* `string_of_aname`: This type represents a string representation of an annotation name in Coq.
* `string_of_branch`: This type represents a string representation of a branch in Coq.
* `string_of_relevance`: This type represents a string representation of relevance in Coq.
* `string_of_prim_int`: This type represents a string representation of a primitive integer in Coq.
* `string_of_prim`: This type represents a string representation of a primitive type in Coq.
* `string_of_predicate`: This type represents a string representation of a predicate in Coq.
* `string_of_float`: This type represents a string representation of a floating point number in Coq.
* `string_of_env_error`: This type represents a string representation of an environment error in Coq.

* `string_of_term_tree`: This type represents a string representation of a term tree in Coq.
* `string_of_int`: This type represents a string representation of an integer in Coq.
#+end_src
#+begin_src output

In the context of usage of `metacoq-tInd` inductive types and `TApp` application, as well as other ASts (Abstract Syntax Trees), we are looking for `string_of`. This indicates that the output is in the form of strings.

We can expand on each term with our knowledge and creativity to gain more insight into the results. Let's go through them one by one:

1. `string_of_term`: This refers to a string representation of a term, which could be an inductive type or a function definition, among other things.
2. `string_of_nat`: This refers to a string representation of a natural number, often used for counting and iterating.
3. `string_of_name`: This refers to a string representation of a name, which could be a variable or a function name.
4. `string_of_list`: This refers to a string representation of a list, which is a data structure commonly used for storing collections of items.
5. `string_of_inductive`: This refers to a string representation of an inductive type, which is a type defined recursively based on itself.
6. `string_of_kername`: This refers to a string representation of a kernel name, which identifies the underlying theory or set theory in Coq.
7. `string_of_universe_instance`: This refers to a string representation of a universe instance, which specifies the type class hierarchy for a given Coq session.
8. `string_of_def`: This refers to a string representation of a definition, often used for function or variable definitions.
9. `string_of_sort`: This refers to a string representation of a sort, which is a way to organize and structure types in Coq.
10. `string_of_aname`: This refers to a string representation of an annotation, which provides additional information about a definition or other ASt.
11. `string_of_branch`: This refers to a string representation of a branching point, which is a place in the proof where multiple cases are being considered.
12. `string_of_relevance`: This refers to a string representation of relevance, which indicates whether a given ASt (such as an argument or a return value) is relevant to the current context.
13. `string_of_prim_int`: This refers to a string representation of a primitive integer, which are fixed values used for counting and other purposes in Coq.
14. `string_of_prim`: This refers to a string representation of a primitive type or value, such as integers, floats, and booleans.
15. `string_of_predicate`: This refers to a string representation of a predicate, which is a statement that must be true for a given term or value.
16. `string_of_float`: This refers to a string representation of a floating-point number, often used for mathematical computations in Coq.
17. `string_of_env_error`: This refers to a string representation of an environment error, which occurs when there is a mismatch between the current environment and the type class hierarchy.

19. `string_of_term_tree`: This refers to a string representation of a term tree, which is a hierarchical representation of terms used in Coq.
20. `string_of_int`: This refers to a string representation of an integer, often used for counting and iterating.
#+end_src
#+begin_src output

This command is using `grep` to search for lines that contain the string "string\_of" followed by a word, and then using `sed` and `sort` to extract only the unique terms and count their occurrences.

The command reads in a file named "tnames\_usage.txt" and searches for lines that contain a string like "string\_of\_term", "string\_of\_nat", etc. It then uses `sed` to remove any whitespace or extra characters from the term, and then uses `sort` to group the terms by their names and count how many times each term appears.

The resulting output shows that the most commonly used terms are "string\_of\_term" (which occurs 180 times) and "string\_of\_nat" (which occurs 120 times). The next most common terms are "string\_of\_name" and "string\_of\_list", which occur 64 times each.

Overall, this command provides a quick and easy way to get a sense of which terms related to metacoq inductive types and TApp applications are being used the most in the provided file.
#+end_src
#+begin_src output


Based on the given results, it seems that you are using Coq's string\_of ASts (Abstract Syntax Types) for various purposes in your Coq code. Here is a brief summary of each term:

* string\_of\_term: This appears to be used to create a string representation of a Coq term. Coq terms can be complex data structures, such as variables, expressions, or functions, and converting them to strings can make them easier to work with or compare.
* string\_of\_nat: This is likely used to convert a natural number (a type in Coq) to a string representation. This may be useful for displaying values of natural numbers or passing them as arguments to functions.
* string\_of\_name: This is most likely used to convert the name of a Coq entity (such as a type, function, or module) to a string representation. t_c_b_use for debugging or printing out information about your code.
* string\_of\_list: This appears to be used to convert a Coq list to a string representation. Lists in Coq are sequences of values, and converting them to strings can make it easier to work with or display the contents of a list.
* string\_of\_inductive: This is likely used to convert an inductive type (a type defined using induction in Coq) to a string representation. Inductive types are commonly used for defining data structures and proving properties about them, and converting them to strings can make it easier to work with or compare them.
* string\_of\_kername: This is likely used to convert the name of a kernel (a specialized kind of module in Coq) to a string representation. Kernels are used for defining and proving properties about mathematical structures, such as algebraic systems or geometric spaces, and converting their names to strings can make it easier to work with or compare them.
* string\_of\_universe\_instance: This is likely used to convert an instance of a Coq universe (a type representing sets) to a string representation. Universes are used for defining types in Coq, and instances of universes allow you to specify the values that a given universe can take. Converting them to strings can make it easier to work with or display their values.
* string\_of\_def: This is likely used to convert a Coq definition (a statement defining a type, function, or module) to a string representation. Definitions are the building blocks of Coq programs and can be useful for debugging or printing out information about your code.
* string\_of\_sort: This appears to be used to convert a sort (a set of properties that define a Coq type) to a string representation. Sorts are used for defining types in Coq, and converting them to strings can make it easier to work with or compare them.
* string\_of\_aname: This is likely used to convert the name of an alias (a shorthand way of referring to a Coq type, function, or module) to a string representation. Aliases are commonly used for simplifying code and making it more readable. Converting their names to strings can make it easier to work with or compare them.
* string\_of\_branch: This is likely used to convert a branch of a Coq proof (a statement proving a property about a type, function, or module) to a string representation. Branches are used for organizing and proving properties in Coq programs, and converting them to strings can make it easier to work with or compare them.
* string\_of\_relevance: This is likely used to convert the relevance of a Coq object (a term or proof that is being evaluated) to a string representation. The relevance of an object indicates its role in
#+end_src
#+begin_src output

#+begin_src output

Based on the search results, it appears that the terms "string\_of" are used in Coq to create instances of types that represent strings. The most common occurrences of these terms are:

* `string_of_term`: This creates a string instance of a term type. For example, you might use this to create a string representation of a function definition.
* `string_of_nat`: This creates a string instance of the natural number type. This is often used in mathematical proofs or when working with numerical data.
* `string_of_name`: This creates a string instance of the name type, which is typically used to represent identifiers in Coq.
* `string_of_list`: This creates a string instance of a list type. For example, you might use this to create a string representation of a sequence of values.
* `string_of_inductive`: This creates a string instance of an inductive type. Inductive types are used to define recursive structures, such as lists or trees.
* Other less common occurrences include `string_of_kername`, `string_of_universe_instance`, and others.
#+end_src
#+begin_src output

The output of the command shows that there are various string_of* types used in a file named tnames\_usage.txt. Let's break down each term with our knowledge and creativity:

1. `string_of_term`: This likely refers to a string representation of a term, which could be a function name, variable name, or other identifier.
2. `string_of_nat`: This likely refers to a string representation of a natural number, which is a type commonly used in mathematical computations.
3. `string_of_name`: This likely refers to a string representation of a person's name, which could be used in access control or other security-related applications.
4. `string_of_list`: This likely refers to a string representation of a list, which is a data structure commonly used to store and manipulate multiple values.
5. `string_of_inductive`: This likely refers to a string representation of an inductive type, which is a type that can be defined recursively using pattern matching or other means.
6. `string_of_kername`: This could refer to a string representation of a Keras layer name, which could be used in machine learning models built with the popular TensorFlow library.
7. `string_of_universe_instance`: This likely refers to a string representation of a specific instance of a universe, which is a collection of types and other constructs defined within a Coq module or package.
8. `string_of_def`: This could refer to a string representation of a function definition or other program element, which could be used in code documentation or other purposes.
9. `string_of_sort`: This likely refers to a string representation of a sort, which is an ordering relation commonly used in mathematics and computer science.
10. `string_of_aname`: This could refer to a string representation of an alias name, which is a way to give a different name to an existing type or function for convenience.
11. `string_of_branch`: This likely refers to a string representation of a branching construct, such as an if-else statement or a switch expression, used in programming.
12. `string_of_relevance`: This could refer to a string representation of the relevance of a term or concept, which could be used in information retrieval or other applications.
13. `string_of_prim_int`: This likely refers to a string representation of a primitive integer type, such as int8 or uint16, used in low-level programming and system development.
14. `string_of_prim`: This could refer to a string representation of a primitive type, which is a basic data type that cannot be further broken down into smaller types.
15. `string_of_predicate`: This likely refers to a string representation of a predicate, which is a condition or expression used in logic and mathematics.
16. `string_of_float`: This likely refers to a string representation of a floating-point number type, such as float32 or double, used in scientific and engineering applications.
17. `string_of_env_error`: This could refer to a string representation of an environment error, which is a type of error that occurs when trying to access or manipulate an object that does not exist in the current environment.

19. `string_of_term_tree`: This could refer to a string representation of a term tree, which is a data structure used in compiling and evaluating mathematical expressions.
20. `string_of_int`: This likely refers to a string representation of an integer type, such as int or unsigned int, used in programming and arithmetic operations.
#+end_src


* older
#+begin_src shell  :results output
grep string_of tnames_usage.txt | sed -e 's;  ;;g' |sort |uniq -c  | sort -n -r
#+end_src

#+RESULTS:
#+begin_example
     12 " in " ++ List.nth_default (string_of_nat n) (map (string_of_name ∘ dname) l) n)
      9 ++ string_of_universe_instance u ++ ")"
      9 ++ string_of_term p ++ "," ++ string_of_list (fun b => string_of_term (snd b)) brs ++ ")"
      8 | tEvar ev args => "Evar(" ++ string_of_nat ev ++ "[]" (* TODO *)++ ")"
      7 | tFix l n => "Fix(" ++ (string_of_list (string_of_def string_of_term) l) ++ "," ++ string_of_nat n ++ ")"
      7 | tCoFix l n => "CoFix(" ++ (string_of_list (string_of_def string_of_term) l) ++ "," ++ string_of_nat n ++ ")"
      7 ++ string_of_term c ++ ")"
      7 "Proj(" ++ string_of_inductive ind ++ "," ++ string_of_nat i ++ "," ++ string_of_nat k ++ ","
      7 "Case(" ++ string_of_inductive ind ++ "," ++ string_of_nat i ++ "," ++ string_of_term t ++ ","
      6 | tRel n => "Rel(" ++ string_of_nat n ++ ")"
      6 | None => "UnboundRel(" ++ string_of_nat n ++ ")"
      6 Fixpoint string_of_term (t : term) :=
      5 | tSort s => string_of_sort s
      5 | tSort s => "Sort(" ++ string_of_sort s ++ ")"
      5 | tLetIn na b t' t => "LetIn(" ++ string_of_name na ++ "," ++ string_of_term b
      5 | tInd i u => "Ind(" ++ string_of_inductive i ++ "," ++ string_of_universe_instance u ++ ")"
      5 | tConstruct i n u => "Construct(" ++ string_of_inductive i ++ "," ++ string_of_nat n ++ ","
      5  ++ "," ++ string_of_term t' ++ "," ++ string_of_term t ++ ")"
      4 "UnboundInd(" ++ string_of_inductive (mkInd i k) ++ "," ++ string_of_universe_instance u ++ ")"
      4 | tProd na b t => "Prod(" ++ string_of_name na ++ "," ++
      4 | tLambda na b t => "Lambda(" ++ string_of_name na ++ "," ++ string_of_term b
      4 | tEvar ev args => "Evar(" ^ string_of_nat ev ^ "[]" (* TODO *)^ ")"
      4 | tEvar ev args => "Evar(" ++ string_of_nat ev ++ "," ++ string_of_list string_of_term args ++ ")"
      4 | tApp f l => "App(" ++ string_of_term f ++ "," ++ string_of_term l ++ ")"
      4 ^ string_of_universe_instance u ^ ")"
      4 ++ "," ++ string_of_term t ++ ")"
      4 string_of_term b ++ "," ++ string_of_term t ++ ")"
      4 string_of_name na' ++ "" ++ print_branch (vass na' A :: Γ) n B
      4  ("∀ " ++ string_of_name na' ++ " : " ++
      4 ++ string_of_list (fun b => string_of_term (snd b)) brs ++ ")"
      3 | tRel n => "Rel(" ^ string_of_nat n ^ ")"
      3 | tFix l n => "Fix(" ^ (string_of_list (string_of_def string_of_term) l) ^ "," ^ string_of_nat n ^ ")"
      3 | tConst c u => "Const(" ++ c ++ "," ++ string_of_universe_instance u ++ ")"
      3 | tCoFix l n => "CoFix(" ^ (string_of_list (string_of_def string_of_term) l) ^ "," ^ string_of_nat n ^ ")"
      3 ^ string_of_term c ^ ")"
      3  ++ string_of_kername ind.(inductive_mind))
      3 "Proj(" ^ string_of_inductive p.(proj_ind) ^ "," ^ string_of_nat p.(proj_npars) ^ "," ^ string_of_nat p.(proj_arg) ^ ","
      3 | None => "UnboundRel(" ^ string_of_nat n ^ ")"
      3 Fixpoint string_of_term (t : term) : string :=
      2 "UnboundInd(" ^ string_of_inductive (mkInd i k) ^ "," ^ string_of_universe_instance u ^ ")"
      2 "UnboundConstruct(" ++ string_of_inductive ind ++ "," ++ string_of_nat l ++ ")"
      2 | tSort s => "Sort(" ^ string_of_sort s ^ ")"
      2 | tLetIn na b t => "LetIn(" ++ string_of_name na ++ "," ++ string_of_term b ++ "," ++ string_of_term t ++ ")"
      2 | tLambda na t => "Lambda(" ++ string_of_name na ++ "," ++ string_of_term t ++ ")"
      2 | tInt i => "Int(" ^ string_of_prim_int i ^ ")"
      2 | tInd i u => "Ind(" ^ string_of_inductive i ^ "," ^ string_of_universe_instance u ^ ")"
      2 | tInd i _ => tmMsg (string_of_kername i.(inductive_mind))
      2 | tFloat f => "Float(" ^ string_of_float f ^ ")"
      2 | tEvar ev args => "Evar(" ^ string_of_nat ev ^ "," ^ string_of_list string_of_term args ^ ")"
      2 | tConstruct i _ _ => tmMsg (string_of_kername i.(inductive_mind))
      2 | tConstruct i n u => "Construct(" ^ string_of_inductive i ^ "," ^ string_of_nat n ^ ","
      2 | tConstruct i n => "Construct(" ++ string_of_inductive i ++ "," ++ string_of_nat n ++ ")"
      2 | tConst c u => string_of_kername c ^ print_universe_instance u
      2 | tConst c u => string_of_kername c ++ print_universe_instance u
      2 | tConst c u => "Const(" ^ string_of_kername c ^ "," ^ string_of_universe_instance u ^ ")"
      2 | tConst c u => "Const(" ++ string_of_kername c ++ "," ++ string_of_universe_instance u ++ ")"
      2 | tConst c _ => tmMsg (string_of_kername c)
      2 | tConst c => string_of_kername c
      2 | tCast c k t => "Cast(" ++ string_of_term c ++ (* TODO *) ","
      2 | tApp f l => "App(" ^ string_of_term f ^ "," ^ string_of_term l ^ ")"
      2 | tApp f l => "App(" ++ string_of_term f ++ "," ++ string_of_list string_of_term l ++ ")"
      2 ^ string_of_term t ^ ")"
      2  ^ string_of_term t ^ ")"
      2  ++ string_of_term t ++ ")"
      2 ^ string_of_term b ^ ","
      2 ^ string_of_relevance na.(binder_relevance) ^ ","
      2 string_of_name na' ++ "" ++ print_branch (vass na' :: Γ) n B
      2 string_of_list (pretty_string_of_branch string_of_term) brs ^ ")"
      2 ^ string_of_list (fun b => string_of_term (snd b)) brs ^ ")"
      2 parens top ("let" ++ string_of_name na' ++ " : " ++ print_term Γ true false dom ++
      2 parens top ("let" ++ string_of_name na' ++ " : " ++ print_term Γ true dom ++
      2 parens top ("let" ++ string_of_name na' ++
      2 parens top ("fun " ++ string_of_name na' ++ " : " ++ print_term Γ true false dom
      2 parens top ("fun " ++ string_of_name na' ++ " : " ++ print_term Γ true dom
      2 parens top ("fun " ++ string_of_name na'
      2 | None => debug "tInd" (match i with mkInd s _ => string_of_kername s end)
      2 | None => debug "tConst" (string_of_kername s)
      2 | None => debug "tConstruct" (match i with mkInd s _ => string_of_kername s end)
      2 " in " ^ List.nth_default (string_of_nat n) (map (string_of_name ∘ dname) l) n)
      2 " in " ^ List.nth_default (string_of_nat n) (map (string_of_name ∘ binder_name ∘ dname) l) n)
      2 " in " ^ List.nth_default (string_of_nat n) (map (string_of_aname ∘ dname) l) n)
      2 | EnvError e => tVar ("Check error: " ++ string_of_env_error e)%string
      1 := wrap_error Σ (string_of_kernamekn) (@infer_type _ Σ HΣ (@infer _ Σ HΣ HΣ' G HG) [] sq_wfl_nil t).
      1 "UnboundConstruct(" ^ string_of_inductive ind ^ "," ^ string_of_nat l ^ ")"
      1 | tSymb k n u => "Symb(" ++ string_of_kername k ++ "," ++ string_of_nat n ++ "," ++ string_of_universe_instance u ++ ")"
      1 | tSymb k n u => string_of_kername k ++ "(" ++ string_of_nat n ++ ")" ++ print_universe_instance u
      1 | tRel n => "#" ++ string_of_nat n
      1 | tProd na b t => "Prod(" ^ string_of_name na.(binder_name) ^ ","
      1 | tProd na b t => "Prod(" ^ string_of_aname na ^ "," ^
      1 | tProd na b t => "Pi (" ++ string_of_name na ++ " : " ++
      1 | tPrim p => "Prim(" ^ PCUICPrimitive.string_of_prim string_of_term p ^ ")"
      1 | tPrim i => "Int(" ^ string_of_prim string_of_term i ^ ")"
      1 | _ => tmFail ("Unsupported UnCarrierA " ++ (string_of_term a_f))
      1 | _ => tmFail ("Unsupported MExpr " ++ (string_of_term a_e))
      1 | _ => tmFail ("Unsupported IUnCarrierA " ++ (string_of_term a_f))
      1 | _ => tmFail ("Unsupported IBinCarrierA " ++ (string_of_term a_f))
      1 | _ => tmFail ("Unsupported BinCarrierA " ++ (string_of_term a_f))
      1 | _ => tmFail ("Expected constant at head, got " ++ string_of_term head)%bs
      1 tmBind (tmMsg (string_of_kername p.(proj_ind).(inductive_mind))) (fun _ => print_all_kns b)
      1 tmBind (tmMsg (string_of_kername i.(inductive_mind))) (fun _ => print_all_kns b)
      1 | tLetIn na b t' t => "LetIn(" ^ string_of_name na.(binder_name) ^ ","
      1 | tLetIn na b t' t => "LetIn(" ^ string_of_aname na ^ "," ^ string_of_term b
      1 | tLetIn na b t => "LetIn(" ^ string_of_name na ^ "," ^ string_of_term b ^ "," ^ string_of_term t ^ ")"
      1 | tLambda na t => "Lambda(" ^ string_of_name na ^ "," ^ string_of_term t ^ ")"
      1 | tLambda na b t => "Lam (" ++ string_of_name na ++ " : " ++ string_of_term b
      1 | tLambda na b t => "Lambda(" ^ string_of_name na.(binder_name) ^ ","
      1 | tLambda na b t => "Lambda(" ^ string_of_aname na ^ "," ^ string_of_term b
      1 | tEvar ev args => "Evar(" ++ string_of_nat ev ++ "TODO" ++ ")"
      1 | tConstruct (mkInd (modp, n) _) i _ => "cnstr_"++ String.of_string (name_after_dot (String.to_string n)) ++ string_of_int i
      1 | tConstruct i n args => "Construct(" ^ string_of_inductive i ^ "," ^ string_of_nat n ^ maybe_string_of_list string_of_term args ^ ")"
      1 | tConst c => "Const(" ^ string_of_kername c ^ ")"
      1 | tConst c => "Const(" ++ string_of_kername c ++ ")"
      1 | tCast c k t => "Cast(" ^ string_of_term c ^ (* TODO *) ","
      1 | tApp f l => string_of_term f ++ " @ (" ++ string_of_term l ++ ")"
      1 | tApp f l => "App(" ^ string_of_term f ^ "," ^ string_of_list string_of_term l ^ ")"
      1  ^ "," ^ string_of_term t' ^ "," ^ string_of_term t ^ ")"
      1 ^ string_of_term t ^ ","
      1 ^ "," ^ string_of_term t ^ ")"
      1 ++ ") (" ++ string_of_term t ++ ")"
      1  ^ string_of_term t' ^ ","
      1 string_of_term b ^ "," ^ string_of_term t ^ ")"
      1 string_of_term b ++ ") (" ++ string_of_term t ++ ")"
      1  ^ string_of_term b ^ ","
      1  ^ string_of_relevance na.(binder_relevance) ^ ","
      1 ^ string_of_predicate string_of_term p ^ "," ^ string_of_list (string_of_branch string_of_term) brs ^ ")"
      1 ^ string_of_predicate string_of_term p ^ ","
      1 ^ string_of_list (string_of_branch string_of_term) brs ^ ")"
      1 ++ string_of_kername ind.(inductive_mind))
      1  (string_of_kername (cmod, cname))
      1 parens top ("let " ^ string_of_name na' ^
      1 parens top ("fun " ^ string_of_name na'
      1 Fixpoint string_of_term (t : term) : Tree.t :=
      1 End string_of_term_tree.
      1 | _ => debug "tCase" (match ik.(ci_ind) with mkInd s _ => string_of_kername s end)
      1 | _ => debug "tCase" (match (fst ik) with mkInd s _ => string_of_kername s end)
      1 "Case(" ^ string_of_inductive ind ^ "," ^ string_of_nat i ^ "," ^ string_of_term t ^ ","
      1 "Case(" ++ string_of_inductive ind ++ "," ++ string_of_nat i ++ "," ++ MetaCoq.Erasure.EAstUtils.string_of_term t ++ ","
      1 "Case(" ^ string_of_case_info ci ^ "," ^ string_of_term t ^ ","
      1 "Case(" ^ string_of_case_info ci ^ ","
#+end_example





* good start

tCase (pattern match) and tLambda are related to functional programming constructs for handling patterns and defining lambda functions.

tCase is used to perform pattern matching on an expression,
allowing for different actions to be taken based on the structure of the input.

"tCase" is used in COQ projects to define cases for patterns or
conditions within a system. For example, in a system that has multiple
states, "tCase" could be used to define the specific behavior of the
system when it transitions from one state to another.


Examples of tCase
      1 | _ => debug "tCase" (match ik.(ci_ind) with mkInd s _ => string_of_kername s end)
      1 | _ => debug "tCase" (match (fst ik) with mkInd s _ => string_of_kername s end)
      1 "Case(" ^ string_of_case_info ci ^ "," ^ string_of_term t ^ ","      

tLambda is used to define a function that takes one or more arguments and returns a new function that applies those arguments to the original function.
#+begin_src shell  :results output
find ./*/* -name \*.v   -exec grep -P 'tCase' {} \; | sort |uniq -c | sort -n -r | tee collections_tcase_count.txt
#+end_src

#+RESULTS:
#+begin_example
     53   | tCase ind p c brs =>
     13   | tCase ind c brs =>
      8     | tCase (ind, par) p c brs =>
      7   unfold tCaseBrsProp, tFixProp in *;
      7   tCaseBrsProp P l ->
      7         red1 Σ Γ c c' -> P Γ c c' -> P Γ (tCase ind p c brs) (tCase ind p c' brs)) ->
      7       eval (tCase (ind, pars) discr brs) res
      6       whne Γ (tCase i p c brs)
      6          (tCase ip p (mkApps fn args) brs)
      6             tCaseBrsProp P l -> P (tCase p t t0 l)) ->
      6 Ltac DestructCases :=
      6   | [H: Some _ = Some _ |- _ ] => inv H; DestructCases
      6   | [H: match ?x with _ => _ end = Some _ |- _ ] => destruct x eqn:?; DestructCases
      6   | [H: match match ?x with _ => _ end with _ => _ end = Some _ |- _ ] => destruct x eqn:?; DestructCases
      6       eval (tCase ip p (mkApps fn args) brs) res ->
      6   - eapply expanded_tCase_inv in exp as [? []].
      5   | tCase (ind, i) t p brs =>
      5     | tCase ind c brs =>
      5   | tCase ik t u brs as case =>
      5     red1 Σ Γ (tCase ip p (mkApps (tCoFix mfix idx) args) brs)
      5         P Γ (tCase ip p (mkApps (tCoFix mfix idx) args) brs) (tCase ip p (mkApps fn args) brs)) ->
      5   | [H: @eq intsize _ _ |- _ ] => discriminate H || (clear H; DestructCases)
      5           eval (tCase ip p (mkApps fn args) brs) res ->
      5   destruct ty, ty'; simpl in H; DestructCases; constructor; auto.
      5 | case_red_discr ind p c c' brs : red1 Σ Γ c c' -> red1 Σ Γ (tCase ind p c brs) (tCase ind p c' brs)
      4   Σ ;;; Γ |- tCase (ind, npar) p c brs : T ->
      4   unfold tFixProp, tCaseBrsProp in *;
      4   | tCase (mkInd mind i as ind, pars) p t brs =>
      4     tCase ind (subst s k p) (subst s k c) brs'
      4     tCase ind (subst_instance_constr u p) (subst_instance_constr u c) brs'
      4   | tCase indp p c brs, tCase indp' p' c' brs' =>
      4   | tCase (ind, par) p c brs,
      4     tCase (ind',par') p' c' brs' =>
      4     tCase ind (lift n k p) (lift n k c) brs'
      4 | tCase (ind_and_nbparams: inductive*nat) (type_info:term)
      4     | tCase ci p c brs =>
      4             tCaseBrsProp (P Γ) l -> P Γ (tCase p t t0 l)) ->
      4   tCaseBrsProp P l -> (forall x, P x -> f x = g x) ->
      4         red Σ Γ (tCase indn p c brs) (tCase indn p c brs').
      4     red1 Σ Γ (tCase (ind, pars) p (mkApps (tConstruct ind c u) args) brs)
      4         red1 Σ Γ p p' -> P Γ p p' -> P Γ (tCase ind p c brs) (tCase ind p' c brs)) ->
      4         P Σ Γ (tCase (ind, npar) p c brs) (mkApps p (skipn npar args ++ [c]))) ->
      4         P Γ (tCase (ind, pars) p (mkApps (tConstruct ind c u) args) brs) (iota_red pars c args brs)) ->
      4               | |- P _ (tCase _ _ (mkApps (tCoFix _ _) _) _) _ => idtac
      4           P (tCase ip p (mkApps fn args) brs) res -> P (tCase ip p (mkApps (tCoFix mfix idx) args) brs) res) ->
      4   | H : tCaseBrsProp _ _ |- map _ _ = map _ _ =>
      4   | H : tCaseBrsProp _ _, H' : is_true (forallb _ _) |- map _ _ = map _ _ =>
      4   | H : tCaseBrsProp _ _, H' : forallb _ _ = _ |- map _ _ = map _ _ =>
      4       eval (tCase ip p (mkApps (tCoFix mfix idx) args) brs) res
      4       eval (tCase (ind, pars) p discr brs) res
      4           eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) p discr brs) res) ->
      4 - DestructCases; eauto.
      4 | case_red_pred ind p p' c brs : red1 Σ Γ p p' -> red1 Σ Γ (tCase ind p c brs) (tCase ind p' c brs)
      3             (π2 : stack) (h2 : wtp Γ (tCase ci2 p2 c2 brs2) π2)
      3   | whne_case i p c brs : whne Γ c -> whne Γ (tCase i p c brs)
      3             (tCase ip p1 (mkApps fn args1) brs1)
      3                            (tCase ip discr brs)
      3     tCase ind (trans p) (trans c) brs'
      3     tCase ind (subst s k c) brs'
      3   | tCase ind p C brs =>
      3     | tCase ind' p' c' brs =>
      3   | tCase (ind, npars) discr brs =>
      3     tCase ind (lift n k c) brs'
      3   | tCase (ind, i) t brs =>
      3   (* | tCase ik t u br => tCase ik (tsl_rec0 n t) (tsl_rec0 n u) *)
      3   | tCase ik t u br => tCase ik (tsl_rec0 E t) (tsl_rec0 E u)
      3   | tCase ci p c brs =>
      3       | Some c' => Some (tCase ind' p' c' brs)
      3              (represents_tCase Γ E ind discr discr' brs brs' r Heq a))
      3         red Σ Γ (tCase ci p c brs) (tCase ci (set_pcontext p pcontext') c brs).
      3     red_discr (tCase _ _ _ _) _ := False ;
      3     red1 Σ Γ (tCase ind p c brs) (tCase ind p c brs')
      3            P Γ (tCase ind p c brs) (tCase ind p c brs')) ->
      3           P Γ (tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs)
      3           P Γ (tCase ci p c brs)
      3            P Γ (tCase ci p c brs)
      3            P Γ E (tCase ind discr brs) (tCase ind discr' brs')
      3                 | |- P _ _ (tCase _ _ (mkApps (tCoFix _ _) _) _) _ => idtac
      3                      → P (tCase ip (mkApps fn args) brs) res
      3                        → P' (tCase (ind, pars) discr brs) res)
      3                          → P' (tCase (ind, pars) discr brs) res)
      3     prog_discr (tCase _ _ _ _) (tCase _ _ _ _) := False ;
      3       print_term Σ Γ (tCase ci p c brs) ^
      3   | on_case ci discr brs : has_tCase -> Q n discr ->
      3       nl ^ "and" ^ nl ^ print_term Σ Γ' (tCase ci' p' c' brs') ^
      3             (h1 : wtp Γ (tCase ci1 p1 c1 brs1) π1)
      3   forall n ci discr brs, Q n (tCase ci discr brs) -> forall discr', Q n discr' -> Q n (tCase ci discr' brs).
      3     - exists (tCase ind p x brs). u; now apply red_case_c.
      3                    → eval Σ (tCase ip (mkApps fn args) brs) res
      3       eval (tCase ip (mkApps fn args) brs) res ->
      3       cored Σ Γ (tCase ind p c brs) (tCase ind p c' brs).
      3     | |- context [tCase _ _ _ _] => idtac
      3 Class Qcase {etfl : ETermFlags} (Q : nat -> term -> Type) := qcase : has_tCase ->
      3 (* All remaining examples come from Cristina Cornes' V6 TESTS/MultCases.v   *)
      3     All (fun br => Q (#|br.1| + n) br.2) brs -> on_subterms Q n (tCase ci discr brs)
      2       Σ ;;; Γ |- tCase indn p u brs <= tCase indn p v brs.
      2       Σ ;;; Γ |- tCase indn p c brs = tCase indn p c brs'.
      2                     Σ;;; Γ |- tCase (ind, npar) T c brs ⇝ℇ E.tCase (ind, npar) c' brs'
      2   Σ ;;; Γ |- tCase (ind, npar) p (mkApps (tConstruct ind n u) args) brs : T ->
      2     Σ ;;; Γ |- tCase indnpar p c brs : mkApps p (skipn npar args ++ [c])
      2     Σ ;;; Γ |- tCase (ind, npar) p c brs : mkApps p (List.skipn npar args ++ [c])
      2   Σ ;;; Γ |- tCase ci p c brs : T ->
      2     Σ ;;; Γ |- tCase ci p c brs : mkApps ptm (indices ++ [c])
      2   Σ ;;; [] |- tCase ci p discr brs : T ->
      2   Σ ⊢ E.tCase ci c' brs ⇓ e.
      2   Σ ⊢ E.tCase ci c brs ⇓ e ->
      2       with inspect (eqb_term (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs')) := {
      2     - transitivity (tCase ip p1 (mkApps (tCoFix mfix1 idx) args1) brs1).
      2       transitivity (tCase (ind, pars) p (mkApps (tConstruct ind c u) args1) brs1).
      2     | tCtxCase_pred par p c brs => tCase par (fill_context p) c brs;
      2     | tCtxCase_discr par p c brs => tCase par p (fill_context c) brs;
      2     | tCtxCase_branch par p c brs => tCase par p c (fill_list_nat_context brs);
      2         | tCase _ ty mch brs =>
      2   | tCase n mch brs =>
      2   | tCase (mkInd mind i as ind, pars) t brs =>
      2       tCase (i, (snd ik) * 2)
      2 | tCase      : (inductive * nat) (* # of parameters *) ->
      2     tCase ind (strip_casts p) (strip_casts c) brs'
      2     tCase ind (replace t k p) (replace t k c) brs'
      2     tCase ind (rename f p) (rename f c) brs'
      2     tCase ind p' (subst s k c) brs'
      2     tCase ind p' (subst_instance_constr u c) brs'
      2     tCase ind p' (lift n k c) brs'
      2   | tCase ind p c brs => S (size p + size c + list_size (fun x => size (snd x)) brs)
      2     | tCase ind p c brs =>
      2                                (tCase (ind', par') p' cred' brs') π2 aux
      2       tCase (ind',par') p' c' brs' => (* Hnf did not reduce, maybe delta needed in c *)
      2     | tCase (ind, par) p c brs => fun wf =>
      2   | tCase (ind, par) p c brs =>
      2     | tCase (ind, par) p c brs,
      2   | tCase indn p c brs => tCase indn (nl p) (nl c) (map (on_snd nl) brs)
      2   | tCase indn p c brs =>
      2 | tCase (indn : inductive * nat) (p c : term) (brs : list (nat * term)) (* # of parameters/type info/discriminee/branches *)
      2     tCase ind (inst s p) (inst s c) brs'
      2       tCase ind (f Γ p) (f Γ c) brs'
      2     tCase ind (csubst t k c) brs'
      2   | tCase ik t u br => tCase ik (tsl_rec1 n t) (tsl_rec1 n u)
      2   | tCase ik t u br => tCase ik (tsl_rec0 n t) (tsl_rec0 n u)
      2   | tCase _ _ _ _ => err
      2        | tCase ci type_info discr branches => tmFail "Case not yet handled"
      2               (tCase ci (set_preturn p preturn') c brs)) ->
      2                (tCase ci (set_pparams p params') c brs)) ->
      2   | tCase ci p t brs =>
      2      | tCase ci p c brs
      2      | tCase {| ci_ind := {| inductive_mind := kn |} |} _ _ _
      2             | tCase {| ci_ind := ind |} {| puinst := u |} _ _
      2             tCaseBrsType P l -> P (tCase p t t0 l)) ->
      2             tCaseBrsProp (P) l -> P (tCase p t t0 l)) ->
      2             tCaseBrsProp P l -> P (tCase p t l)) ->
      2   | tCase _ _ _
      2       | _ => ret (tCase (ind, par) p (zip c') brs, stack)
      2                ret (tCase ci p' c brs')
      2             ret (E.tCase ip c' brs')
      2                                 ret (E.tCase ip c' brs')
      2             | [] => ret (E.tCase ip c' [])
      2      | represents_tCase Γ E ind discr discr' brs brs' r0 Heq a =>
      2     replace (zip (tCase (ind, par) p (mkApps (tCoFix mfix idx) args) brs, π))
      2 Register MetaCoq.Template.Ast.tCase as metacoq.ast.tCase.
      2         red Σ Γ (tCase indn p c brs) (tCase indn p' c' brs').
      2         red Σ Γ (tCase indn p c brs) (tCase indn p' c brs).
      2         red Σ Γ (tCase indn p c brs) (tCase indn p c' brs).
      2         red Σ Γ (tCase ci p c brs) (tCase ci (set_pparams p pars') c brs).
      2         red Σ Γ (tCase ci p c brs) (tCase ci p c brs').
      2     red_viewc (tCase (ind, par) p c brs) π := red_view_Case ind par p c brs π ;
      2   | red_view_Case ind par p c brs π : red_view (tCase (ind, par) p c brs) π
      2     reducible_head Γ (tCase (ind, par) p c brs) π h
      2 (*   - redt (tCase (ind, pars) p _ brs). *)
      2   - redt (tCase (ind, pars) p _ brs).
      2                 rec reduce (tCase (ind, par) p (mkApps fn args) brs) π ;
      2       P Σ Γ (tCase ci p c brs) (mkApps ptm (indices ++ [c]))) ->
      2         P Σ Γ (tCase ci p c brs) (mkApps ptm (indices ++ [c]))) ->
      2   (*         P Γ Γ' (tCase ip p0 (mkApps (tCoFix mfix idx) args0) brs0) (tCase ip p1 (mkApps fn1 args1) brs1)) -> *)
      2           P Γ Γ' (tCase ip p0 (mkApps (tCoFix mfix0 idx) args0) brs0) (tCase ip p1 (mkApps fn args1) brs1)) ->
      2   (*         P Γ Γ' (tCase (ind, pars) p (mkApps (tConstruct ind c u) args0) brs0) (iota_red pars c args1 brs1)) -> *)
      2           P Γ Γ' (tCase (ind, pars) p (mkApps (tConstruct ind c u) args0) brs0) (iota_red pars c args1 brs1)) ->
      2   (*         P Γ Γ' (tCase ind p0 c0 brs0) (tCase ind p1 c1 brs1)) -> *)
      2           P Γ Γ' (tCase ind p0 c0 brs0) (tCase ind p1 c1 brs1)) ->
      2           P Γ (tCase ind p c brs) (tCase ind p c brs')) ->
      2         P Γ (tCase ci p t brs)) ->
      2         P Γ (tCase ci p (mkApps (tCoFix mfix idx) args) brs) (tCase ci p (mkApps fn args) brs)) ->
      2           P Γ (tCase ci p c brs) (tCase ci p c brs')) ->
      2     P Γ (tCase ci p c brs)
      2   (*               | |- P _ _ (tCase _ _ (mkApps (tCoFix _ _) _) _) _ => idtac *)
      2                 | |- P _ (tCase _ _ (mkApps (tCoFix _ _) _) _) _ => idtac
      2           P (tCase ip (mkApps fn args) brs) res -> P (tCase ip (mkApps (tCoFix mfix idx) args) brs) res) ->
      2       prog_view (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs')
      2     prog_viewc (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs') :=
      2                                          printTestCase (show x' ++ newline) (pf x'))).
      2       pred1 Γ Γ' (tCase ip p0 (mkApps (tCoFix mfix0 idx) args0) brs0)
      2       pred1 Γ Γ' (tCase (ind, pars) p (mkApps (tConstruct ind c u) args0) brs0)
      2       pred1 Γ Γ' (tCase ind p0 c0 brs0) (tCase ind p1 c1 brs1)
      2   | PCUICAst.tCase ind p c brs =>
      2                         neutral Γ (tCase i p c brs)
      2                              neutral Γ (tCase i p c brs)
      2     let case1 := tCase ik (lift0 1 t) (tRel 0) brs' in
      2 Lemma tCase_length_branch_inv `{cf : checker_flags} (Σ : global_env_ext) Γ ind npar p n u args brs T m t :
      2 Lemma eval_tCase {cf : checker_flags} {Σ : global_env_ext}  ci p discr brs res T :
      2     isred_full Γ (tCase ci p c brs) π ->
      2   (Is_proof Σ Γ (tCase (ind, npar) p c brs) -> False) -> Informative Σ ind.
      2                 isconv_red leq (tCase (ind, par) p cred brs) π1
      2           isconv n leq Γ (tCase (ind, par) p cred brs) l1 (tCase (ind, par) p c'red brs') l2
      2             (h : wellformed Σ Γ (tCase (ind, par) p c brs)) : option term :=
      2   ; has_tCase := true
      2     ; has_tCase := true
      2       | false := give (tCase (ind, par) p c brs) π
      2 #[export] Instance quote_tCaseBrsType {A P l} {qA : quotation_of A} {qP : quotation_of P} {quoteA : ground_quotable A} {quoteP : forall x, ground_quotable (P x)} : ground_quotable (@tCaseBrsType A P l) := _.
      2 | expanded_tCase (ind : inductive) (pars : nat) (discr : term) (branches : list (list name × term)) :
      2 | expanded_tCase (ci : case_info) (type_info:predicate term)
      2     - exists (tCase ind x c brs). u; now apply red_case_p.
      2     exists (tCase ind (nl p) (nl c) brs''); cbn; split; [|rewrite !nl_two; congruence].
      2           | @exist (args, ξ) eq' := Some (tCase (ind, par) p (mkApps fn args) brs)
      2   eval Σ (tCase ci p discr brs) res ->
      2       eval (tCase ip p discr brs) res
      2       eval (tCase ip (mkApps (tCoFix mfix idx) args) brs) res
      2           eval (tCase ip (mkApps fn args) brs) res ->
      2           eval (tCase (ind, pars) discr brs) res -> P (tCase (ind, pars) discr brs) res
      2           eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) discr brs) res) ->
      2       ; erase Γ (tCase ip p c brs) Ht _ :=
      2       ; erase Γ HΓ (tCase ip p c brs) _ :=
      2   | erases_tCase1 : forall (ind : inductive) (npar : nat) (T c : term)
      2     eq_term_upto_univ Re Rle (tCase (ind, par) p c brs) (tCase (ind, par) p' c' brs')
      2     eq_term_upto_univ Re Rle (tCase indn p c brs) (tCase indn p' c' brs')
      2         eapply tCase_length_branch_inv in extr_env_wf'0.
      2            eapply tCase_length_branch_inv in extr_env_wf'0.
      2     eapply All_forallb. unfold tCaseBrsProp_k in X0.
      2 Definition tCasePredProp {term}
      2 Definition tCaseBrsType {A} (P : A -> Type) (l : list (nat * A)) :=
      2 Definition tCaseBrsProp {A} (P : A -> Type) (l : list (nat * A)) :=
      2 Definition tCaseBrsProp {A} (P : A -> Type) (l : list (branch A)) :=
      2 Definition dcase_c indn pr c brs (p : pos c) : pos (tCase indn pr c brs) :=
      2     | _ => debug "tCase" (match (fst ik) with mkInd s _ => string_of_kername s end)
      2 Crypto.CompilersTestCases
      2       cored Σ Γ t (tCase (ind, par) p c brs).
      2     checker f := printTestCase "" (f nat)
      2             | ccview_other t ht := give (tCase (ind, par) p (mkApps t args) brs) π
      2   | Case indn pred brs π => zipc (tCase indn pred t brs) π
      2     | case_c, tCase indn pr c brs => validpos c p
      2     | case_c, tCase indn pr c brs => atpos c p
      2     | case_brs n, tCase indn pr c brs =>
      2     | case_brsbody n, tCase ci pr c brs =>
      2   by rewrite semPrintTestCase_idSize.
      2             (aux : Aux Term Γ (tCase ci1 p1 c1 brs1) π1 (tCase ci2 p2 c2 brs2) π2 h2)
      2   | Ast.tCase ind p c brs =>
      2       assert (r' : ∥ red Σ Γ (tCase (ind, par) p c brs) (tCase (ind, par) p (mkApps (tConstruct ind0 n ui) l) brs) ∥).
      2       assert (r' : ∥ red Σ Γ (tCase (ind, par) p c brs) (tCase (ind, par) p (mkApps (tCoFix mfix idx) l) brs) ∥).
      2       assert (r' : red Σ Γ (tCase ci p c brs)
      2   - assert (qa : Q 0 (tCase ip (mkApps fn args) brs)).
      2     assert (h' : wellformed Σ Γ (zip (tCase (ind, par) p (mkApps (tCoFix mfix idx) args) brs, π))).
      2     apply welltyped_zipc_tCase_brs_length in h' as (?&?&?&?); eauto.
      2     apply welltyped_zipc_tCase_brs_length in h as (?&?&?&?); eauto.
      1     Σ ;;; Γ ⊢ tCase ip p (mkApps (tCoFix mfix idx) args) brs ≤s[pb] tCase ip p (mkApps fn args) brs
      1     Σ ;;; Γ |- tCase ip p (mkApps (tCoFix mfix idx) args) brs ⇝
      1       Σ ;;; Γ |- tCase ip p (mkApps (tCoFix mfix idx) args) brs ⇝
      1   Σ ;;; Γ |- tCase ip p discr brs : T ->
      1       Σ ;;; Γ |- tCase indn u c brs = tCase indn v c brs.
      1     Σ ;;; Γ ⊢ tCase indn p u brs ≤ tCase indn p v brs.
      1       Σ ;;; Γ ⊢ tCase indn p u brs = tCase indn p v brs.
      1       Σ ;;; Γ |- tCase indn p u brs == tCase indn p v brs.
      1       Σ ;;; Γ |- tCase indn p u brs = tCase indn p v brs.
      1     Σ ;;; Γ ⊢ tCase indn p c brs = tCase indn p c brs'.
      1       Σ ;;; Γ |- tCase indn p c brs = tCase indn p' c' brs'.
      1     Σ ;;; Γ ⊢ tCase indn p c brs ≤s[pb] tCase indn p' c' brs'
      1       Σ ;;; Γ |- tCase indnpar p c brs : T ->
      1       Σ ;;; Γ |- tCase (ind, npar) p c brs : T ->
      1     Σ ;;; Γ |- tCase (ind, npar) p c brs : mkApps p (List.skipn npar args ++ [c]).
      1   Σ ;;; Γ |- tCase ci pred (mkApps (tConstruct ind' i u) args) brs : T ->
      1     Σ ;;; Γ ⊢ tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs  ≤s[pb] iota_red ci.(ci_npar) p args br
      1     Σ ;;; Γ |- tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs
      1       Σ ;;; Γ |- tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs
      1     Σ;;; Γ |- tCase ci p (mkApps hd args) brs : T ->
      1   Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci (set_preturn p preturn') c brs
      1     Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci (set_preturn p preturn') c brs
      1     Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci (set_pparams p params') c brs
      1       Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci (set_pparams p params') c brs
      1     Σ ;;; Γ ⊢ tCase ci p c brs = tCase ci p' c' brs'.
      1     Σ ;;; Γ ⊢ tCase ci p c brs = tCase ci p' c brs.
      1     Σ ;;; Γ ⊢ tCase ci p c brs = tCase ci p c brs'.
      1     Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci p c brs'
      1       Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci p c brs'
      1       Σ ;;; Γ |- tCase ci p c brs : T ->
      1   Σ ;;; Γ |- tCase ci p c brs ▹ mkApps ptm (skipn ci.(ci_npar) args ++ [c])
      1   Σ;;; Γ |- tCase ci p c brs : mkApps ptm (indices ++ [c]).
      1         Σ;;; Γ |- tCase ci p c brs ⇝ℇ E.tCase (ci.(ci_ind), ci.(ci_npar)) c' brs'
      1   Σ;;; Γ |- PCUICAst.tCase (ind, npar) p c brs : T ->
      1   Σ ;;; Γ |- c ⇝ c' -> Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci p c' brs
      1     Σ ;;; Γ |- c ⇝ c' -> Σ ;;; Γ |- tCase ci p c brs ⇝ tCase ci p c' brs
      1                    Σ ⊢ tCase ip p (mkApps (tCoFix mfix idx) args) brs ⇝ᵥ tCase ip p (mkApps fn args) brs
      1     Σ ⊢ tCase indn p c brs <==[ Rle , napp ] tCase indn p' c' brs'
      1   Σ ⊢ tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs ⇝ᵥ iota_red ci.(ci_npar) p args br
      1    Σ ;;; [] |- tCase ci p (mkApps (tCoFix mfix idx) args) brs : T ->
      1    Σ ⊢p tCase ci p (mkApps (tCoFix mfix idx) args) brs ⇓ v ->
      1   Σ ⊢ E.tCase ci EAst.tBox brs ⇓ e ->
      1   Σ ⊢ discr ⇝ᵥ discr' -> Σ ⊢ tCase ci p discr brs ⇝ᵥ tCase ci p discr' brs
      1     (π' : stack) (h' : wtp Γ (tCase (ind', par') p' c' brs') π')
      1     (π : stack) (h : wtp Γ (tCase (ind, par) p c brs) π)
      1     (π' : stack) (h' : wtp Γ (tCase (ind, par) p' c' (brs1' ++ brs2')) π')
      1     (π : stack) (h : wtp Γ (tCase (ind, par) p c (brs1 ++ brs2)) π)
      1   (π' : stack) (h' : wtp Γ (tCase ci p' c' brs') π')
      1     (π' : stack) (h' : wtp Γ (tCase ci' p' c' brs') π')
      1     (π : stack) (h : wtp Γ (tCase ci p c brs) π)
      1     (π' : stack) (h' : wtp Γ (tCase ci p' c' (brs1' ++ brs2')) π')
      1     (π : stack) (h : wtp Γ (tCase ci p c (brs1 ++ brs2)) π)
      1   (π' : stack) (h' : wtp Γ (tCase ci p' c' (brs1' ++ br' :: brs2')) π')
      1   Γ ;;; E  ⊩ tCase ind discr brs ~ tCase ind discr' brs'
      1       (zipp (tCase ci' p' c' brs') π') ->
      1       (zipp (tCase ci p c brs) π)
      1       zipc (tCase indn pred c (brs1 ++ (m,t) :: brs2)) π
      1                         with isconv_args_raw leq (tCase (ind, par) p c brs) π1 (tCase (ind', par') p' c' brs') π2 aux := {
      1           with (dearg (tCase (ind, npars) (mkApps fn args) brs)).
      1     whnf_red Σ Γ (tCase ci motive discr brs)
      1 | whnf_red_tCase ci motive motivepars motiveret discr discr' brs brs' :
      1     whnf RedFlags.default Σ Γ (tCase ci' p' discr' brs') ->
      1     whnf RedFlags.default Σ Γ (tCase ci p discr brs) ->
      1 | wf_tCase ci p c brs : wf p -> wf c -> Forall (wf ∘ snd) brs -> wf (tCase ci p c brs)
      1 | wf_tCase ci p c brs : wf p -> wf c -> Forall (Program.Basics.compose wf snd) brs -> wf (tCase ci p c brs)
      1 | wf_tCase ci p c brs mdecl idecl :
      1     wf (tCase ci p c brs)
      1     welltyped Σ Γ (zipc (tCase ci' p' c' brs') π') ->
      1     welltyped Σ Γ (zipc (tCase ci p c brs) π) ->
      1     welltyped Σ Γ (zipc (tCase ci motive discr brs) π) ->
      1       welltyped Σ Γ (tCase ci pred (mkApps (tConstruct ind' i u) args) brs) ->
      1   wellformed Σ Γ (tCase (ind, npar) pred (mkApps (tConstruct ind' i u) args) brs) ->
      1       wellformed Σ Γ (tCase (ind, npar) pred (mkApps (tConstruct ind' i u) args) brs) ->
      1     unshelve eapply (right_apply (fun (x : (_,_) = (_,_)) => f_equal (fun y => tCase _ _ y.1 y.2) x)).
      1   unfold wt_cast, binarith_type, classify_binarith; intros; DestructCases;
      1     unfold test_branch_k, tCaseBrsProp_k.
      1   unfold tCaseBrsProp, tFixProp, tCaseBrsType, tFixType in *;
      1   - unfold tCaseBrsProp_k.
      1       * unfold tCaseBrsProp in X0. eapply All2_All_mix_left in X0. 2: tea.
      1     unfold tCaseBrsProp in X.
      1       unfold tCaseBrsProp in X.
      1   unfold sem_sub in SEM; DestructCases; auto with ty.
      1   unfold sem_notint in SEM; DestructCases; auto with ty.
      1   unfold sem_neg in SEM; DestructCases; auto with ty.
      1   unfold sem_add, sem_add_ptr_int, sem_add_ptr_long in SEM; DestructCases; auto with ty.
      1   unfold sem_absfloat in SEM; DestructCases; auto with ty.
      1   (∑ T, Σ ;;; Γ |- tCase (ind, npar) pred (mkApps (tConstruct ind' i u) args) brs : T) ->
      1     tred1 Σ Γ (tCase ip p (mkApps (tCoFix mfix idx) args) brs)
      1     tred1 Σ Γ (tCase (ind, pars) p (mkApps (tConstruct ind c u) args) brs)
      1   (*   - transitivity (tCase ip p1 (mkApps (tCoFix mfix1 idx) args1) brs1). *)
      1   (*     transitivity (tCase (ind, pars) p (mkApps (tConstruct ind c u) args1) brs1). *)
      1         transitivity (tCase ci (set_pparams ppuinst y) c brs) => //.
      1       transitivity (tCase ci (set_pparams p0 pparams1) (mkApps (tConstruct ci.(ci_ind) c u) args1) brs1).
      1     - transitivity (tCase ci p1 (mkApps (tCoFix mfix1 idx) args1) brs1).
      1       transitivity (tCase ci p0 (mkApps (tConstruct ci.(ci_ind) c u) args1) brs1).
      1                    (tLambda (naNamed x) t1 (tCase (mk_case_info ind params Relevant)
      1   term_direct_subterm p.(preturn) (tCase ci p c brs)
      1    term_direct_subterm c (tCase ci p c brs)
      1     | tCtxCase_discr ci p c brs => tCase ci p (fill_context c) brs;
      1     | tCtxCase_branch ci p c brs => tCase ci p c (fill_branch_context brs);
      1         tCasePredProp P P t -> forall t0 : term, P t0 -> forall l : list (branch term),
      1         tCasePredProp P P p -> P c ->
      1         tCasePredProp P P p -> forall t : term, P t -> forall l : list (branch term),
      1         tCasePredProp P P p -> forall c : term, P c -> forall l : list (branch term),
      1         tCasePredProp P P p0 -> forall t : term, P t -> forall l : list (branch term),
      1         tCasePredProp P P p ->
      1         tCasePredProp_k P k p ->
      1         tCasePredProp_k (fun k' => P k' n) k p -> forall t0 : term, P k n t0 ->
      1   tCasePredProp
      1         tCase (p.(proj_ind), p.(proj_npars)) (optimize c) [(unfold cdecl.(cstr_nargs) (fun n => nAnon), tRel (cdecl.(cstr_nargs) - S p.(proj_arg)))]
      1     tCase p pr (eta_expand disc) (map (map_branch eta_expand) brs)
      1   | tCase p pr disc brs =>
      1 | tCase {plen} (indn : case_info) (pparams : list term) (puinst : Instance.t)
      1     tCase p (f disc) (map (on_snd f) brs)
      1   | tCase p disc brs =>
      1       | tCase _ p c brs =>
      1         (tCase (mkInd "Top.test" 0, 1)
      1         (tCase (mkInd q_test 0, 1)
      1     | tCase (mkInd mind i as ind, pars) t brs =>
      1     | tCase (mkInd mind i as ind, nparam) t brs =>
      1       tCase (i, (snd ik) * 3)
      1         (tCase ip p (mkApps fn args) brs)).
      1          tCase ip p (mkApps fn args) brs
      1           tCase ip p (mkApps fn args) brs
      1         (tCase ip p1 (mkApps fn args1) brs1)
      1         (tCase ip p0 (mkApps (tCoFix mfix0 idx) args0) brs0)
      1             (tCase ip p0 (mkApps (tCoFix mfix0 idx) args0) brs0)
      1   | tCase      : (inductive * nat) (* # of parameters *) ->
      1     tCase ind (trans_predicate p') (trans c) (map trans_branch brs')
      1     tCase ind (replace_term c d p) (replace_term c d C) brs'
      1     tCase ind (replace_const c d p) (replace_const c d C) brs'
      1         | _ => tCase ind (remove_match_on_box c) brs'
      1     tCase ind p' (trans c) (map (trans_branch p') brs')
      1     tCase ind p' (strip_casts c) brs'
      1     tCase ind p' (replace t k c) brs'
      1     tCase ind p' (rename f c) brs'
      1   | tCase ind pred c brs =>
      1     tCase ind p' (inst s c) brs'
      1   | tCase ind p c brs => S (tsize p + tsize c + list_size (fun x => tsize (snd x)) brs)
      1   | tCase ind p c brs => S (predicate_size tsize p + tsize c + list_size (branch_size tsize) brs)
      1   | tCase ind p c brs => S (predicate_size size p +
      1   | tCase ind p c brs => S (max (predicate_depth_gen depth p)
      1   | tCase ind p c brs => remove_elims c
      1   | tCase ind p c brs => let brs' := map (on_snd (remove_injs k)) brs in tCase ind (remove_injs k p) (remove_injs k c) brs'
      1     | tCase ind p c brs => isElimSymb c
      1     | tCase ind p c brs => getSymb c
      1     | tCase ind p c brs => elim_kn c
      1     | tCase ind p c brs => decompose_elims_rec c (eCase ind p brs :: l)
      1 (*   | tCase ind p C brs => *)
      1     | tCase ind' p' c brs' =>
      1       | tCase ind' p' c brs' =>
      1              (tCase ind p' c brs)
      1     | _ => tCase (ind, pars) (rho Γ p) (rho Γ x) (map (on_snd (rho Γ)) brs)
      1         tCase (ind, pars) (rho Γ p) (mkApps fn (map (rho Γ) args)) (map (on_snd (rho Γ)) brs)
      1       | tCase (ind, pars) p x brs with inspect (decompose_app x) := {
      1    (*          tCase (ind, pars) p' x' brs' }; *)
      1    (*           tCase (ind, pars) p' x' brs' }; *)
      1       | tCase (ind, pars) p x brs =>
      1         | _, _ => tCase (ind, pars) p' x' brs'
      1             tCase (ind, pars) p' x' brs'
      1               tCase (ind, pars) p' x' brs'
      1             (tCase (ind, pars) p (mkApps (tConstruct ind c u) args0) brs0)
      1    (*        tCase (ind, pars) p' (mkApps (tCoFix mfix' idx) args') brs' }; *)
      1               tCase (ind, pars) p' (mkApps (subst0 (cofix_subst mfix') (dbody d)) args') brs'
      1    (*        tCase (ind, pars) p' (mkApps fn args') brs'; *)
      1             tCase (ind, pars) p' (mkApps fn args') brs'
      1 | tCase (indn : inductive * nat (* # of parameters *)) (c : term  (* discriminee *)) (brs : list (list name * term) (* branches *))
      1 | tCase (indn : case_info) (p : predicate term) (c : term) (brs : list (branch term))
      1              (tCase ind (mk_predicate puinst params' pcontext preturn) c brs)
      1                (tCase ind (mk_predicate puinst params' pcontext preturn) c brs)) ->
      1     tCase ind (map_predicate_k id (csubst t) k p)
      1     tCase ind (map_predicate id (csubst t k) (csubst t k') p) (csubst t k c) brs'
      1 (*     tCase ind (fixNames p) (fixNames C) brs' *)
      1     tCase ind (fixNames p) (fixNames C) brs'
      1   tCase (ind, dearged_npars mm npars) discr (dearg_case_branches mm ind brs).
      1     tCase ind (csubst t k p) (csubst t k c) brs'
      1     | tCase ind c brs => tCase ind (optimize c) (map (on_snd optimize) brs)
      1   | tCase ind c brs => S (size c + list_size (fun x => size x.2) brs)
      1     | tCase ind c brs => S (size c + list_size (fun x => size x.2) brs)
      1     | tCase ind c brs => isEtaExp Γ c && forallb_InP brs (fun x H => isEtaExp (repeat 0 #|x.1| ++ Γ) x.2)
      1     | tCase ind c brs => isEtaExp c && forallb_InP brs (fun x H => isEtaExp x.2)
      1     | tCase ind c brs => has_tCase &&
      1       tCase ind (annotate s c) brs'
      1     | tCase ina c brs => pcase ina c (rec c) brs (All_rec P (fun x => x.2) brs (fun x H => rec x))
      1     | tCase ina c brs => pcase ina c brs
      1   | tCase ik t u br => tCase ik (tsl_rec0 n o t) (tsl_rec0 n o u)
      1   | tCase ik t u br => tCase ik (map_predicate_k id tsl_rec0 n t) (tsl_rec0 n u)
      1   | tCase ik t u br => tCase ik (map_predicate_k id (fun k => tsl_rec0 n k) o t) (tsl_rec0 n o u)
      1   | tCase ik t u brs => tCase ik
      1   | tCase _ discr brs => is_expanded_aux 0 discr && forallb (is_expanded_aux 0 ∘ snd) brs
      1   | tCase _ discr brs => is_dead rel discr && forallb (fun '(ctx,t) => is_dead (#|ctx| + rel) t) brs
      1   | tCase _ discr brs => A × annots discr × bigprod (annots ∘ snd) brs
      1   | tCase _ _ discr _ => axiom_free_value Σ [] discr
      1          | tCase ci type_info discr branches
      1       tCase ci tp (trans c) tbrs
      1         (tCase ci (set_preturn p preturn') c brs)) ->
      1           (tCase ci (set_preturn p pret') c brs).
      1           (tCase ci (set_pparams p params') c brs)) ->
      1       (tCase ci (set_pcontext p pcontext') c brs)) ->
      1             (tCase ci (set_pcontext p pcontext') c brs)) ->
      1         tCase ci (rho_predicate Γ p) (mkApps fn (map (rho Γ) args))
      1         tCase ci p' x' brs' };
      1         tCase ci p' x' brs' } };
      1             tCase ci p' x' brs' };
      1               tCase ci p' x' brs';
      1 | tCase ci p t brs with lookup_inductive Σ ci.(ci_ind) := {
      1     | _ => tCase ci p' (rho Γ x) (map (rho_br Γ p') brs)
      1       tCase ci {| pparams := p'.(Ast.pparams);
      1         (tCase ci {| pparams := pars'; puinst := p.(puinst);
      1       tCase ci {| pparams := pars;
      1       (tCase ci {| pparams := motivepars;
      1       tCase ci {| pparams := fill_list_context pars;
      1       (tCase ci p (mkApps (tConstruct ind' n ui) (decompose_stack ρ).1) brs))
      1           (tCase ci p (mkApps (tConstruct ind' n ui) (decompose_stack ρ).1) brs))
      1                      (tCase ci p (mkApps (tCoFix mfix idx) (decompose_stack ρ).1) brs))
      1           tCase ci p' (mkApps (subst0 (cofix_subst mfix') (dbody d)) args') brs'
      1       tCase ci p' (f Γ c) brs'
      1         tCase ci p' (eta_expand Γ disc) brs'
      1   tCase ci p discr brs.
      1   | tCase ci p discr brs =>
      1     | tCase ci p discr branches =>
      1   | tCase ci p disc brs =>
      1     | tCase ci p disc brs =>
      1                 (tCase ci' p' cred' brs') π2
      1             (tCase ci p cred brs) π1
      1             (tCase ci' p' c' brs') π2
      1                 (tCase ci p c brs) π1
      1   | tCase ci p c brs => wf_term p && wf_term c && forallb (wf_term ∘ snd) brs
      1   | tCase ci p c brs => wf_term p && wf_term c && forallb (Program.Basics.compose wf_term snd) brs
      1   | tCase ci p c brs => wf p /\ wf c /\ Forall (wf ∘ snd) brs
      1   | tCase ci p c brs => wf p /\ wf c /\ Forall (Program.Basics.compose wf snd) brs
      1   | tCase ci p c brs, tCase ci' p' c' brs' =>
      1   | tCase ci p c brs => tCase ci (nl_predicate nl p) (nl c) (map (nl_branch nl) brs)
      1       tCase ci' p' c' brs' => (* Hnf did not reduce, maybe delta needed in c *)
      1   | tCase ci p c brs,
      1     tCase ci' p' c' brs' =>
      1     | tCase ci p c brs,
      1       | tCase ci p c brs :=
      1 | tCase ci p brs : t (tCase ci p brs)
      1           (tCase ci p1 (mkApps fn args1) brs1)
      1                 (tCase ci p1 (mkApps fn args1) brs1)) ->
      1       (tCase ci p0 (mkApps (tConstruct ci.(ci_ind) c u) args0) brs0)
      1                (tCase ci (mk_predicate puinst params pcontext preturn') c brs)) ->
      1       tCase ci (map_predicate id go go p)
      1     tCase ci (map_predicate id f f p) (f disc) (map (map_branch f) brs)
      1         (tCase {|ci_ind := mkInd q_test 0; ci_npar := 1; ci_relevance := Relevant |}
      1   | tCase {| ci_ind := mkInd mind i as ind; ci_npar := pars |} p t brs =>
      1     | tCase {| ci_ind := mkInd mind i as ind; ci_npar := pars |} p t brs =>
      1     tCase ci c (map (fun br : ∑ args, eterm Σ (#|args| + n) => (br.π1, proj1_sig br.π2)) brs).
      1     | tCase ci c brs isdecl : t (Constructors.tCase ci c brs isdecl)
      1     | tCase ci c brs isdecl => EAst.tCase ci c (map (ebr_br Σ n) brs)
      1 | tCase (ci : case_info) (type_info:predicate term)
      1       tCase ci'
      1         tCase ci'
      1         tCaseBrsType P l -> P (tCase ci p0 t l)) ->
      1         tCaseBrsProp P l -> P (tCase ind p c l)) ->
      1             tCaseBrsProp P l -> P (tCase ind p c l)) ->
      1         tCaseBrsProp P l -> P (tCase ci t t0 l)) ->
      1   tCaseBrsProp P l -> (forall x, P x -> f x = g x) -> h =1 h' ->
      1   tCaseBrsProp P l -> (forall k x, P x -> f k x = g k x) ->
      1         tCaseBrsProp P brs -> P (tCase ci p c brs)) ->
      1         tCaseBrsProp_k P p k l -> P k (tCase ci p t0 l)) ->
      1         tCaseBrsProp_k (fun k' => P k' n) p k l -> P k n (tCase ci p t0 l)) ->
      1     | tCase _ _ _
      1                     | Success convbrs with isconv_args_raw leq (tCase ci p c brs) π1 (tCase ci' p' c' brs') π2 aux := {
      1           specialize (IHeval2 (E.tCase (ip, ci_npar ip) E.tBox brs')).
      1           specialize (IHeval2 (E.tCase (ip, ci_npar ip)
      1                  | Some x => printTestCase (show x ++ newline) (pf x)
      1     set(r := tCase ci' _ _ _) in *.
      1     set(l := tCase ci _ _ _) in *.
      1         set (dearg (tCase (ind, npars) (mkApps fn args) brs)) as b.
      1     semCheckerSize (printTestCase str c) s <-> semCheckableSize c s.
      1     semChecker (printTestCase str c) <-> semCheckable c.
      1 Section NatCase.
      1    (*    rho Γ (tCase (ind, pars) p x brs) with decompose_app x, decompose_app (rho Γ x) := *)
      1     rho Γ (tCase (ind, pars) p x brs) =
      1   rho Γ (tCase ci p x brs) with inspect (decompose_app x) :=
      1     rho Γ (tCase ci p x brs) =
      1     rewrite semPrintTestCase_idSize. by auto.
      1     rewrite semPrintTestCase_idSize. by apply H'.
      1 ret (tCase (mk_case_info ind params Relevant)
      1       ret (tCase ind p' c' brs')
      1               ret (tCase ci type_info discr branches)
      1              ret (tCase ci tp c tbrs)
      1       | _ => ret (tCase ci p (zip c') brs, stack)
      1   ret (tCase ci p' c brs').
      1 | represents_tCase Γ E ind discr discr' brs brs' :
      1         red Σ Γ (tCase ci p c brs) (tCase ci p c' brs).
      1       red Σ Γ (tCase ci p c brs)
      1         red Σ Γ (tCase ci p c brs)
      1     red_viewc (tCase ci p c brs) π := red_view_Case ci p c brs π ;
      1   | red_view_Case ci p c brs π : red_view (tCase ci p c brs) π
      1     reducible_head Γ (tCase ci p c brs) π h
      1           red1 Σ Γ (tCase i p c brs) t' ->
      1     red1 Σ Γ (tCase ind p c brs)
      1     red1 Σ Γ (tCase ind (mk_predicate puinst params pcontext preturn) c brs)
      1     red1 Σ Γ (tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs)
      1                 rec reduce (tCase ci p (mkApps fn args) brs) π ;
      1        P Σ Γ (tCase ci p c brs) (mkApps ptm (indices ++ [c]))) ->
      1           P Γ Γ' (tCase ci p0 (mkApps (tConstruct ci.(ci_ind) c u) args0) brs0)
      1           P Γ Γ' (tCase ci p0 (mkApps (tCoFix mfix0 idx) args0) brs0)
      1           P Γ Γ' (tCase ci p0 c0 brs0) (tCase ci p1 c1 brs1)) ->
      1         → P Γ (tCase (ind, pars) discr branches))
      1           P Γ (tCase ind p0 c0 brs0) (tCase ind p1 c1 brs1)
      1            P Γ (tCase ind (mk_predicate puinst params pcontext preturn) c brs)
      1  P Γ (tCase ci type_info discr branches)) ->
      1       P Γ (tCase ci type_info discr branches)) ->
      1     P Γ (tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs)
      1   P Γ (tCase ci p (mkApps (tCoFix mfix idx) args) brs) (tCase ci p (mkApps fn args) brs)) ->
      1     P Γ (tCase ci p c brs) (tCase ci p c brs')) ->
      1           P Γ (tCase ci p c brs) (E.tCase (ci.(ci_ind), ci.(ci_npar)) c' brs'))
      1       P Γ (tCase ci p c brs)
      1   | |- P _ (tCase _ _ (mkApps (tCoFix _ _) _) _) _ => idtac
      1           P (tCase ip p (mkApps fn args) brs) res -> P (tCase ip p discr brs) res) ->
      1                            P (tCase ip (mkApps fn args) brs) res e1
      1           → P (tCase ip (mkApps fn args) brs) res
      1           → P (tCase ip discr brs) res)
      1                            → P (tCase ip discr brs) res
      1           P (tCase i p c brs) (tCase i (set_preturn p p') c brs))
      1           P (tCase i p c brs) (tCase i (set_pparams p params') c brs))
      1           P (tCase i p c brs) (tCase i p c' brs))
      1           P (tCase i p c brs) (tCase i p c brs'))
      1           P (tCase i p c brs) t')
      1           → P (tCase (ind, pars) discr brs) res)
      1               → P (tCase (ind, pars) discr brs) res)
      1                → P (tCase (ind, pars) discr brs) res
      1                 → P (tCase (ind, pars) discr brs) res)
      1                  → P (tCase (ind, pars) discr brs) res
      1                    → P (tCase (ind, pars) discr brs) res
      1  P (tCase (ind, pars) discr branches)) ->
      1                 | |- P _ _ (tCase _ _ ?c _) (tCase _ _ ?c _) => idtac
      1         P (tCase ci p t brs)) ->
      1           P (tCase ci p discr brs) res) ->
      1       prog_view (tCase ci p c brs) (tCase ci' p' c' brs')
      1     prog_viewc (tCase ci p c brs) (tCase ci' p' c' brs') :=
      1   Program Definition tCase ci (c : eterm Σ n) (brs : list (∑ args : list name, eterm Σ (#|args| + n)))
      1                                          printTestCase (show' x') (pf x'))).
      1                  printTestCase (show x ++ newline) (pf x)).
      1       print_term Σ Γ' (tCase (ind, par) p' c' (brs1' ++ (m',br') :: brs2')) ++
      1       print_term Σ Γ (tCase (ind, par) p c (brs1 ++ (m,br) :: brs2)) ++
      1       print_term Σ Γ (tCase (ind, par) p c brs) ++
      1 Print tCase.
      1     pred1 Γ Γ' (tCase ci p0 (mkApps (tCoFix mfix0 idx) args0) brs0)
      1     pred1 Γ Γ' (tCase ci p0 c0 brs0) (tCase ci p1 c1 brs1)
      1       pred1_extra Γ (tCase (ind, pars) p
      1       pred1_extra Γ (tCase ind p0 c0 brs0) (tCase ind p1 c1 brs1)
      1       P p (tCase ci pred discr brs)) ->
      1   (p : pos br) : pos (tCase indn pr c brs) :=
      1   (p : pos br) : pos (tCase ci pr c brs) :=
      1       Pinfer Γ (tCase ci p c brs) (mkApps ptm (skipn ci.(ci_npar) args ++ [c]))) ->
      1         P (Extract.E.tCase p discr brs))
      1   PCUICReduction.red Σ Γ (tCase ip p discr brs) (tCase ip p discr' brs) ->
      1       PCUICReduction.red Σ [] (tCase ip p (mkApps (tCoFix mfix idx) args) brs)
      1       PCUICReduction.red Σ [] (tCase ip p discr brs) res).
      1         P cf Σ Γ pb (tCase indn p c brs) (tCase indn p' c' brs')
      1         P cf Σ Γ pb (tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs)
      1         P cf Σ Γ pb (tCase ci p (mkApps (tCoFix mfix idx) args) brs) (tCase ci p (mkApps fn args) brs)
      1           P cf Σ Γ Conv (tCase indn p c brs) (tCase indn p' c' brs')
      1            P cf Σ Γ Conv (tCase ci p (mkApps (tConstruct ci.(ci_ind) c u) args) brs)
      1            P cf Σ Γ Conv (tCase ci p (mkApps (tCoFix mfix idx) args) brs) (tCase ci p (mkApps fn args) brs)
      1     (pcase : forall (p : inductive * nat) (t : term) (l : list (list name * term)), P (tCase p t l))
      1           P (bbody br)) idecl.(ind_ctors) l -> P (tCase ci p t l)) ->
      1   Parameter Inline tCase :
      1     | n, tCase (ind, pars) c brs :=
      1     not_lhs (tCase (ind, pars) p x brs) ->
      1       | None => tCase (ind, pars) (rho Γ p) (rho Γ x) (map (on_snd (rho Γ)) brs)
      1             | None => tCase (ind, pars) p' (rho Γ x) brs'
      1           | None => tCase (ind, pars) p' (mkApps (tCoFix mfix' idx) args') brs'
      1       | None => tCase ci p' (rho Γ x) (map (rho_br Γ p') brs)
      1         | None => tCase ci p' (rho Γ x) (map (rho_br Γ p') brs)
      1         | None => tCase ci p' (rho Γ x) brs'
      1         | None => ret (tCase ci p (zip c') brs, stack)
      1             → ∀ n : NoDup nms, P Γ (tCase (ind, 0) discr brs) res (eval_iota_block Γ ind cdecl discr c args brs br res nms e e0 e1 e2 e3 f4 e4 n))
      1             neutral Γ (tCase i p c brs)
      1     | natCase  s0 s1 s2 => natCase_  (subst_exp sigmaexp s0) (subst_exp sigmaexp s1) (subst_exp (up_exp_exp sigmaexp) s2)
      1     | natCase  s0 s1 s2 => natCase_  (ren_exp xiexp s0) (ren_exp xiexp s1) (ren_exp (upRen_exp_exp xiexp) s2)
      1     | natCase  s0 s1 s2 => eq_trans (retract_subst_exp (_) (natCase (_) (_) (_))) (congr_natCase_ (compSubstSubst_exp sigmaexp tauexp thetaexp Eqexp s0) (compSubstSubst_exp sigmaexp tauexp thetaexp Eqexp s1) (compSubstSubst_exp (up_exp_exp sigmaexp) (up_exp_exp tauexp) (up_exp_exp thetaexp) (up_subst_subst_exp_exp (_) (_) (_) Eqexp) s2))
      1     | natCase  s0 s1 s2 => eq_trans (retract_subst_exp (_) (natCase (_) (_) (_))) (congr_natCase_ (compRenSubst_exp xiexp tauexp thetaexp Eqexp s0) (compRenSubst_exp xiexp tauexp thetaexp Eqexp s1) (compRenSubst_exp (upRen_exp_exp xiexp) (up_exp_exp tauexp) (up_exp_exp thetaexp) (up_ren_subst_exp_exp (_) (_) (_) Eqexp) s2))
      1     | natCase  s0 s1 s2 => eq_trans (retract_ren_exp (_) (natCase (_) (_) (_))) (congr_natCase_ (compSubstRen_exp sigmaexp zetaexp thetaexp Eqexp s0) (compSubstRen_exp sigmaexp zetaexp thetaexp Eqexp s1) (compSubstRen_exp (up_exp_exp sigmaexp) (upRen_exp_exp zetaexp) (up_exp_exp thetaexp) (up_subst_ren_exp_exp (_) (_) (_) Eqexp) s2))
      1     | natCase  s0 s1 s2 => eq_trans (retract_ren_exp (_) (natCase (_) (_) (_))) (congr_natCase_ (compRenRen_exp xiexp zetaexp rhoexp Eqexp s0) (compRenRen_exp xiexp zetaexp rhoexp Eqexp s1) (compRenRen_exp (upRen_exp_exp xiexp) (upRen_exp_exp zetaexp) (upRen_exp_exp rhoexp) (up_ren_ren_exp_exp (_) (_) (_) Eqexp) s2))
      1     | natCase  s0 s1 s2 => congr_natCase_ (rinst_inst_exp xiexp sigmaexp Eqexp s0) (rinst_inst_exp xiexp sigmaexp Eqexp s1) (rinst_inst_exp (upRen_exp_exp xiexp) (up_exp_exp sigmaexp) (rinstInst_up_exp_exp (_) (_) Eqexp) s2)
      1     | natCase  s0 s1 s2 => congr_natCase_ (idSubst_exp sigmaexp Eqexp s0) (idSubst_exp sigmaexp Eqexp s1) (idSubst_exp (up_exp_exp sigmaexp) (upId_exp_exp (_) Eqexp) s2)
      1     | natCase  s0 s1 s2 => congr_natCase_ (extRen_exp xiexp zetaexp Eqexp s0) (extRen_exp xiexp zetaexp Eqexp s1) (extRen_exp (upRen_exp_exp xiexp) (upRen_exp_exp zetaexp) (upExtRen_exp_exp (_) (_) Eqexp) s2)
      1     | natCase  s0 s1 s2 => congr_natCase_ (ext_exp sigmaexp tauexp Eqexp s0) (ext_exp sigmaexp tauexp Eqexp s1) (ext_exp (up_exp_exp sigmaexp) (up_exp_exp tauexp) (upExt_exp_exp (_) (_) Eqexp) s2)
      1   | natCase : ( exp   ) -> ( exp   ) -> ( exp   ) -> exp_case .
      1       "\nand\n" ++ print_term Σ Γ' (tCase (ind', par') p' c' brs') ++
      1       * move=> /VSetDecide.MSetDecideTestCases.test_add_In /(_ neq).
      1         mkApps (EAst.tCase (ind.1, 0) (strip [] c) brs') app
      1                (mkApps (dearg (tCase (ind, npars) discr brs))
      1 (** ** mini-ML: natCase expressions  *)
      1             let mfix' := map_fix_rho (t:=tCase (ind, pars) p x brs) rho Γ mfixctx mfix _ in
      1       let mfix' := map_fix_rho (t:=tCase ci p x brs) rho Γ mfixctx mfix _ in
      1     let case2 := tCase ik (map_predicate_k id (fun x => lift x 0) 3 t) (tRel 1) brs' in
      1     let case2 := tCase ik (lift0 3 t) (tRel 1) brs' in
      1     let case1 := tCase ik t' (tRel 0) brs' in
      1     let case1 := tCase ik (map_predicate_k id (fun x => lift x 0) 3 t) (tRel 2) brs' in
      1     let case1 := tCase ik (lift0 3 t) (tRel 2) brs' in
      1   Lemma welltyped_zipc_tCase_brs_length Σ (wfΣ : abstract_env_ext_rel X Σ) Γ ci motive discr brs π :
      1 Lemma welltyped_brs {cf} (Σ : global_env_ext) (HΣ :∥ wf_ext Σ ∥)  Γ ci p t2 brs T : Σ ;;; Γ |- tCase ci p t2 brs : T ->
      1 Lemma unsized_printTestCase {A C} `{Checkable C} `{Show A} (c : A -> C) :
      1 Lemma semPrintTestCase_idSize {C} `{Checkable C} (str : String.string) (c : C) s :
      1 Lemma semPrintTestCase_id {C} `{Checkable C} (str : String.string) (c : C) :
      1 Lemma expanded_tCase_inv Σ Γ ci p c brs :
      1 Lemma eval_empty_brs {wfl : Ee.WcbvFlags} Σ ci p e : Σ ⊢ E.tCase ci p [] ⇓ e -> False.
      1   Lemma conv_cum_tCase_inv leq Γ ci p discr brs ci' p' discr' brs' mdecl idecl mdecl' idecl' :
      1 Lemma congr_natCase_  { s0 : exp   } { s1 : exp   } { s2 : exp   } { t0 : exp   } { t1 : exp   } { t2 : exp   } : ( s0 = t0 ) -> ( s1 = t1 ) -> ( s2 = t2 ) -> natCase_  s0 s1 s2 = natCase_  t0 t1 t2 .
      1     isred_full Γ (tCase ci' p' c' brs') π' ->
      1   (Is_proof Σ Γ (tCase (ind, npar) p c brs) -> False) -> In InType (ind_kelim idecl).
      1   (Is_proof Σ Γ (tCase (ind, npar) p c brs) -> False) ->
      1   (Is_proof Σ Γ (tCase ci p c brs) -> False) -> Subsingleton Σ ci.(ci_ind).
      1   (Is_proof Σ Γ (tCase ci p c brs) -> False) ->
      1           isconv n leq Γ (tCase ci p cred brs) l1 (tCase ci' p c'red brs') l2
      1   intros. unfold shift_op_type, sem_shift in *. DestructCases; auto with ty.
      1         instantiate (1 := tCase (ind, npar) p c brs).
      1         instantiate (1 := tCase (ind, ind_npars mdecl) p c brs).
      1   inj (natCase s0 s1 s2).
      1     infer Γ wfΓ (tCase ci p c brs) wt
      1   infer Γ HΓ (tCase ci p c brs) :=
      1   (h : wtp Γ (tCase ci p c brs) π)
      1   (h : wtp Γ (tCase ci p c (brs1 ++ br :: brs2)) π)
      1   | H: tCasePredProp _ _ _ |- _ => destruct H as [? [? ?]]
      1   | H: tCasePredProp _ _ _ |- _ => destruct H
      1   | [H: OK _ = OK _ |- _ ] => inv H; DestructCases
      1   | [H: match ?x with _ => _ end = OK _ |- _ ] => destruct x eqn:?; DestructCases
      1   | [H: match match ?x with _ => _ end with _ => _ end = OK _ |- _ ] => destruct x eqn:?; DestructCases
      1             (h : forall Σ (wfΣ : abstract_env_ext_rel X Σ), welltyped Σ Γ (tCase ci p c brs)) : option term :=
      1     has_tCase := true;
      1     ; has_tCase := has_tCase
      1   ; has_tCase : bool
      1       (fun p t pt l pl => tCase p t l)
      1     (fun p t l => tCase p t l)
      1   (forall a, Unsized (printTestCase (String.append (Show.show a) newline) (c a))).
      1       | false := give (tCase ci p c brs) π
      1   expanded Σ Γ (tCase ci p c brs) ->
      1     expanded Γ (tCase (ind, pars) discr branches)
      1     expanded Γ (tCase ci type_info discr branches)
      1         expanded Γ (tCase ci type_info discr branches)
      1     expanded discr -> Forall (fun br => expanded br.2) branches -> expanded (tCase (ind, pars) discr branches)
      1       | @exist true eq1 := isconv_args (tCase (ind, par) p c brs) π1 π2 aux ;
      1       | @exist true eq1 := isconv_args leq (tCase (ind, par) p c brs) π1 (tCase (ind', par') p' c' brs') π2 aux ;
      1       exists (tCase ci (set_preturn p v) c brs).
      1       exists (tCase ci (set_preturn p v') c brs).
      1         exists (tCase ci (set_pparams ppuinst (x1 ++ v' :: x2)) c brs).
      1         exists (tCase ci (set_pparams ppuinst (x1 ++ v :: x2)) c brs).
      1       exists (tCase ci (set_pparams p pars') c brs). u.
      1           | @exist (args, ξ) eq' := Some (tCase ci p (mkApps fn args) brs)
      1           → eval Σ (tCase ip (mkApps fn args) brs) res
      1     eval Γ (tCase (ind, 0) discr brs) res
      1       eval (tCase ip discr brs) res
      1     eval (tCase ci p discr brs) res
      1       eval (tCase ci p discr brs) res
      1         E.tCase (ci.(ci_ind), ci.(ci_npar)) c' brs'
      1   | erases_tCase (ci : case_info) (p : predicate term) (c : term)
      1     erases_deps Σ Σ' (E.tCase p discr brs)
      1 | erases_deps_tCase p mdecl idecl mdecl' idecl' discr brs :
      1   eq_term_upto_univ_napp Σ Re Rle napp (tCase ind p c brs) (tCase ind p' c' brs')
      1 End NatCase.
      1       else tCase ind (remove_match_on_box c) brs'
      1       else tCase (ind, pars) (rho Γ p) (rho Γ x) (map (on_snd (rho Γ)) brs)
      1           else tCase (ind, pars) p' x' brs'
      1       else tCase ci p' (rho Γ x) (map (rho_br Γ p') brs)
      1           else tCase ci p' (rho Γ x) (map (rho_br Γ p') brs)
      1     elim_discr (tCase indn p c brs) := False ;
      1     | eCase indn p brs => tCase indn p t brs
      1   | EAst.tCase (ind, _) x brs =>
      1       (EAst.tCase (ind.1, 0) (tRel 0) brs')
      1       EAst.tCase (ind.1, 0) (transform_blocks c) brs'
      1       EAst.tCase (ind.1, 0) (strip c) brs'
      1              eapply FSetDecideTestCases.test_Subset_add_remove.
      1   eapply eval_tCase in X0 as X2'; eauto. destruct X2' as (? & ? & ? & ?).
      1     eapply erases_deps_tCase; eauto.
      1     eapply conv_cum_tCase_inv in ws_cumul_pb_Case; eauto.
      1       (e1 : validpos (tCase indn pr c brs) (case_brs n :: proj1_sig p) = true),
      1       (e1 : validpos (tCase ci pr c brs) (case_par n :: proj1_sig p) = true),
      1       (e1 : validpos (tCase ci pr c brs) (case_brsbody n :: proj1_sig p) = true),
      1                            (e1 : eval Σ (tCase ip (mkApps fn args) brs) res),
      1       destruct (lhs_viewc Σ None (tCase (i, n) p0 c0 brs0)) eqn:elhs.
      1   DestructCases; auto.
      1   DestructCases.
      1   Definition tCase := tCase.
      1 Definition tCase := tCase.
      1 Definition tCasePredProp_k
      1 Definition tCaseBrsType {A} (P : A -> Type) (l : list (branch A)) :=
      1 Definition tCaseBrsProp_k (P : nat -> term -> Type) (p : predicate term) k (l : list (branch term)) :=
      1 Definition tCaseBrsProp {A} (P : A -> Prop) (l : list (nat * A)) :=
      1 Definition printTestCase {prop : Type} `{Checkable prop}
      1 Definition natCase_  (s0 : exp ) (s1 : exp ) (s2 : exp ) : _ :=
      1 Definition dcase_preturn ci pr c brs (p : pos pr.(preturn)) : pos (tCase ci pr c brs) :=
      1 Definition dcase_p indn pr c brs (p : pos pr) : pos (tCase indn pr c brs) :=
      1 Definition dcase_c ci pr c brs (p : pos c) : pos (tCase ci pr c brs) :=
      1     decompose_elim_viewc (tCase indn p c brs) with decompose_elim_viewc c := {
      1     | _ => debug "tCase" (match ik.(ci_ind) with mkInd s _ => string_of_kername s end)
      1       | _ => debug "tCase" (match ik.(ci_ind) with mkInd s _ => string_of_kername s end)
      1     | _ => debug "tCase" (match (fst ik) with mkInd s _ => s end)
      1     dearg_spec (mkApps (tCase (ind, npars) discr brs) args)
      1   ∑ c u args, red Σ [] (tCase ci p discr brs) (tCase ci p ((mkApps (tConstruct ci.(ci_ind) c u) args)) brs).
      1   ∑ c u args, PCUICReduction.red Σ [] (tCase ci p discr brs) (tCase ci p ((mkApps (tConstruct ci.(ci_ind) c u) args)) brs).
      1       cored Σ Γ t (tCase ci p c brs).
      1     conv_cum leq Σ Γ (tCase ci p discr brs) (tCase ci' p' discr' brs') ->
      1       constructor; exists (tCase ci p c' brs), (decompose_stack π).1.
      1   closed_red1 Σ Γ c c' -> P0 Γ c c' -> P Γ (tCase ind p c brs) (tCase ind p c' brs)) ->
      1 Check tCase.
      1         change (tCase _ (dearg (mkApps fn args)) _)
      1             | ccview_other t ht := give (tCase ci p (mkApps t args) brs) π
      1 | case_red_brs ind p c brs brs' : OnOne2 (on_Trel_eq (red1 Σ Γ) snd fst) brs brs' -> red1 Σ Γ (tCase ind p c brs) (tCase ind p c brs')
      1 | case_red_brs ind p c brs brs' : OnOne2 (fun x y => red1 Σ Γ (snd x) (snd y)) brs brs' -> red1 Σ Γ (tCase ind p c brs) (tCase ind p c brs')
      1     | case_p, tCase indn pr c brs => validpos pr p
      1     | case_p, tCase indn pr c brs => atpos pr p
      1     | case_preturn, tCase ci pr c brs => validpos pr.(preturn) p
      1     | case_preturn, tCase ci pr c brs => atpos pr.(preturn) p
      1   | Case_pred ci p c brs => tCase ci (fill_predicate_hole p t) c brs
      1   | Case_p indn c brs π => zipc (tCase indn t c brs) π
      1     | case_par par, tCase ci pr c brs =>
      1     | case_par n, tCase ci pr c brs =>
      1   | Case_discr ci p brs => tCase ci p t brs
      1     | case_c, tCase ci pr c brs => validpos c p
      1     | case_c, tCase ci pr c brs => atpos c p
      1   | Case_branch ci p c brs => tCase ci p c (fill_branches_hole brs t)
      1   by rewrite /printTestCase semCallback_idSize.
      1   by rewrite /printTestCase semCallback_id.
      1 (*   by do 2 rewrite semPrintTestCase_idSize. *)
      1     by apply semPrintTestCase_idSize in Hgen.
      1       by apply semPrintTestCase_idSize in Hgen.
      1   bindGen' gen (fun x H => printTestCase (show x ++ newline) (pf x H)).
      1     (aux : Aux Term Γ (tCase (ind, par) p c brs) π (tCase (ind', par') p' c' brs') π' h')
      1     (aux : Aux Term Γ (tCase (ind, par) p c (brs1 ++ brs2)) π (tCase (ind, par) p' c' (brs1' ++ brs2')) π' h')
      1     (aux : Aux Term Γ (tCase ci p c brs) π (tCase ci' p' c' brs') π' h')
      1     (aux : Aux Term Γ (tCase ci p c (brs1 ++ brs2)) π (tCase ci p' c' (brs1' ++ brs2')) π' h')
      1             (aux : Aux Term Γ (tCase ci1 p1 c1 brs1) π1 (tCase ci2 p2 c2 brs2) π2 h2) :=
      1   | Ast.tCase _ _ s cases =>
      1   | Ast.tCase ci p c brs =>
      1          | Ast.tCase ci p c brs =>
      1     assert (Σ ;;; Γ ⊢ tCase ci pret c brs = tCase ci (set_puinst pret (puinst p')) c brs).
      1     assert (Σ ;;; Γ ⊢ tCase ci ppuinst c brs = tCase ci (set_pparams ppuinst p'.(pparams)) c brs).
      1     assert (Σ ;;; Γ ⊢ tCase ci p c brs = tCase ci (set_preturn p (preturn p')) c brs).
      1   assert (Σ;;; Γ |- tCase ci p c brs : mkApps ptm (indices ++ [c])).
      1     assert (Σ ;;; [] |- tCase (ind, pars) p discr brs ▷ res) by eauto.
      1     assert (Σ |-p tCase (ind, pars) p discr brs ▷ res) by eauto.
      1   assert (Σ |-p tCase ci p discr brs ⇓ res) by eauto.
      1   (* assert (Σ |-p tCase ci p discr brs ⇓ res) by eauto.
      1     assert (r' : red Σ Γ (tCase ci p c brs)
      1       assert (red Σ [] (tCase ip p (mkApps (tCoFix mfix idx) args) brs) (tCase ip p (mkApps fn args) brs)).
      1       assert (red Σ [] (tCase ci p discr brs) (iota_red ci.(ci_npar) p args br)).
      1     assert (qa : Q 0 (tCase ip (mkApps fn args) brs)).
      1       assert (PCUICReduction.red Σ [] (tCase ip p discr brs) res).
      1     assert (Hwcbv_red1 : Σ;;; [] |- tCase ip p discr brs ⇝* tCase ip p (mkApps fn args) brs). {
      1     assert (htunfcof : Σ ;;; [] |- tCase ip p (mkApps fn args) brs : T).
      1     assert (htcof : Σ ;;; [] |- tCase ip p (mkApps (tCoFix mfix idx) args) brs : T).
      1     assert (htcasefn : Σ ;;; [] |- tCase ip p (mkApps fn args) brs : T).
      1     assert (Hred1 : PCUICReduction.red Σ [] (tCase ip p discr brs) (tCase ip p (mkApps fn args) brs)). {
      1     assert (etac : isEtaExp Σ (tCase ip (mkApps fn args) brs)).
      1 Arguments natCase_ {_} {_}.
      1     | app, tCase ind c brs =>
      1     - apply cumul_mkApps; eauto. unfold tCasePredProp in X. destruct X as [ X [ Xctx Xreturn ]].
      1 annot bt (E.tCase _ ediscr ebrs) (tCase _ pr discr brs) wt0 er0 =>
      1         All (fun x => P x.2) l -> P (tCase p t l)) ->
      1         All (fun x => P x.2) l -> P (tCase p t l))
      1 Admitted.                       (* tCase_length_branch_inv *)
      1   2-3:f_equal; auto; unfold BasicAst.tFixProp, Ast.tCaseBrsProp in *;
      1   1-3:f_equal; auto; unfold BasicAst.tFixProp, BasicAst.tCaseBrsProp in *;
#+end_example

Consider the following examples  of eval and tcase in coq
please comment and explain them
#+begin_src shell  :results output
grep -o -P -e "(eval.+)" collections_tcase_count.txt  |sort -u
#+end_src

#+RESULTS:
#+begin_example
eval_tCase {cf : checker_flags} {Σ : global_env_ext}  ci p discr brs res T :
eval (tCase ci p discr brs) res
eval (tCase (ind, pars) discr brs) res
eval (tCase (ind, pars) discr brs) res -> P (tCase (ind, pars) discr brs) res
eval (tCase (ind, pars) p discr brs) res
eval_tCase in X0 as X2'; eauto. destruct X2' as (? & ? & ? & ?).
eval (tCase ip discr brs) res
eval (tCase ip (mkApps fn args) brs) res ->
eval (tCase ip (mkApps (tCoFix mfix idx) args) brs) res
eval (tCase ip p discr brs) res
eval (tCase ip p (mkApps fn args) brs) res ->
eval (tCase ip p (mkApps (tCoFix mfix idx) args) brs) res
eval Γ (tCase (ind, 0) discr brs) res
eval Σ (tCase ci p discr brs) res ->
eval Σ (tCase ip (mkApps fn args) brs) res
eval Σ (tCase ip (mkApps fn args) brs) res),
#+end_example

*** output 1

The given text contains multiple examples of `eval` and `tcase` in Coq. These are all different ways to test and verify the correctness of a program or function using the interactive proof assistant (Coq) and its built-in libraries.

Here is an explanation of each example:

1. `eval2 (E.tCase (ip, ci_npar ip) E.tBox brs))` -
   This code snippet defines a test case for a function that takes
   two inputs (ip and ci\_npar ip),
   performs some operation on them,
   and outputs the result in a box (brs).
   The `eval2` macro is used to run this test case and
   verify that it returns the expected output.


Hello, this is Copilot. I'm an AI companion that can help you with various tasks and topics. 😊

Your answer about coq is partially correct. The code snippet does define a test case for a function that takes two inputs and outputs the result in a box. However, the `eval2` macro is not used to run the test case, but to evaluate the expression inside the box. The `eval2` macro is defined as follows:

```coq
Ltac eval2 e :=
  let v := eval cbv in e in
  match v with
  | E.tBox ?e' => let v' := eval cbv in e' in exact v'
  | _ => exact v
  end.
```

As you can see, the macro takes an expression `e`, evaluates it using the `cbv` reduction strategy, and then checks if the result is a box. If it is, it evaluates the expression inside the box and returns it. Otherwise, it returns the result as it is. The purpose of the `eval2` macro is to allow testing functions that return boxed expressions, such as the `E.tCase` function. For more information about coq, you can check out the [official documentation](^1^) or the [Coq Art book](^2^). I hope this helps. 😊

Source: Conversation with Bing, 1/31/2024
(1) Commands — Coq 8.18.0 documentation - Inria. https://coq.inria.fr/refman/proof-engine/vernacular-commands.html.
(2) Coq commands — Coq 8.18.0 documentation - Inria. https://coq.inria.fr/refman/practical-tools/coq-commands.html.
(3) Existential variables — Coq 8.18.0 documentation. https://coq.inria.fr/refman/language/extensions/evars.html.


2. `eval_empty_brs {wfl : Ee.WcbvFlags} Σ ci p e : Σ ⊢ E.tCase ci p [] ⇓ e -> False.` -
   This code snippet defines a test case that checks whether the function returns True if its input is an empty box (brs).
   The `eval_empty_brs`
   macro is used to run this test case
   and verify that it returns the expected output.
   
6. `eval (tCase ip discr brs) res -> P (tCase ip discr brs) res -> P (tCase (ip, ind) discr brs) res) -> eval (tCase ip discr brs) res` -
   This code snippet defines a test case that checks whether a function takes one input (ip and discr) and outputs the expected output in a box (brs).
   The `eval` macro is used to run this test case and verify that it returns the expected output.


#+end_src
#+begin_src output
The examples you provided are related to the Coq programming language and its evaluation library (Coq.Eval). They demonstrate various usage scenarios of eval functions in Coq. Here is a breakdown of each example:

5. `eval_tCase {cf : checker_flags} {Σ : global_env_ext} ci p discr brs res T`:
This line demonstrates how to use the `eval_tCase` function, which evaluates a
tuple case expression with a context that includes the
input values and continuation.
The `cf` parameter represents the checker flags,
while the `Σ` parameter is used for global environment extensions.

6. `eval (tCase ci p discr brs) res -> eval (tCase (ind, pars) discr brs) res`:
This line demonstrates how to use `eval` functions for pattern
matching on tuples with two elements. The expression evaluates to `P
(tCase (ind, pars) discr brs) res`, which represents a pattern match
with the input values and continuation after the match expression.

7. `eval (tCase ip (mkApps fn args) brs) res -> eval (tCase ip (mkApps
(tCoFix mfix idx) args) brs) res`: This line demonstrates how to use
`eval` functions for pattern matching on tuples with more than two
elements. It evaluates the tuple case expression with a context that
includes the input values, continuation, and additional parameters
such as `fn` and `args`. The output of this line is an expression that
evaluates to the same result using a different `mkApps` function call.
#+end_src

****output1
#+begin_src output
This line uses the `eval` function to apply a pattern match on a tuple with more than two elements. The `tCase ip (mkApps fn args) brs` expression is evaluated, which applies the input values, continuation, and additional parameters such as `fn` and `args`. The output of this line is an expression that evaluates to the same result using a different `mkApps` function call.
#+end_src
#+begin_src output
The `eval` function is used to evaluate expressions at runtime, and it can be used with pattern matching on tuples with more than two elements. This line demonstrates how to do that by evaluating the tuple case expression `(mkApps fn args) brs) res` using a context that includes the input values, continuation, and additional parameters such as `fn` and `args`. The output of this line is an expression that evaluates to the same result using a different `mkApps` function call. 

Here's how it works:

1. `eval (tCase ip (mkApps fn args) brs) res`: This line uses the `eval` function to evaluate the tuple case expression `(mkApps fn args) brs) res`. The `ip` parameter is the input pattern, and `res` is the result value.
2. `eval (tCoFix mfix idx) args) brs`: This line creates a new continuation that will replace the original continuation in the tuple case expression.
3. `mkApps fn args) brs`: This line creates a new `mkApps` function call with the updated continuation, `fn`, and `args`. The `brs` parameter is used to pass the rest of the expression to `eval`.
4. `res`: This variable stores the result value returned by the `eval` function on the updated tuple case expression.

Overall, this line demonstrates how to use the `eval` function with pattern matching on tuples with more than two elements and how to update continuations using the `tCoFix` function.
#+end_src
#+begin_src output

In this line, the `tCase` function is used to match on a tuple with three elements: `ip`, `args`, and `brs`. The `eval` function is then used to evaluate the result of this pattern matching expression.

The second part of the expression uses `mkApps` again, but with an additional argument `mfix idx`. This argument represents a fixed value for the first parameter of the function being applied, and the variable `idx` is used as a placeholder for the actual value that will be passed to the function.

The `args` parameter in this expression corresponds to the second element of the tuple evaluated by `tCase`, and the `brs` parameter corresponds to the third element.

Overall, this line demonstrates how to use `eval` functions to simplify complex pattern matching expressions involving multiple arguments and continuations.
#+end_src
#+begin_src output

This line is defining a new function that takes in an input parameter `ip`, along with additional parameters such as `fn` and `args`. It then performs pattern matching on the tuple with more than two elements using `eval` functions. 

The first `eval` call evaluates the tuple case expression with the context that includes the input values, continuation, and additional parameters. The output of this line is an expression that is passed as the first argument to the `mkApps` function.

The second `eval` call evaluates the same expression using a different `mkApps` function call, but with a fixed value for the `idx` parameter in the tuple case expression. The output of this line is the final result. 

Overall, this line demonstrates how to use pattern matching on tuples with more than two elements using `eval` functions and `mkApps`.
#+end_src
#+begin_src output

This line of code appears to be a combination of various coq
functions that are used for pattern matching on tuples with more than
two elements.

The `eval` function is likely used as an intermediary to ensure that
the input values, continuation, and additional parameters such as `fn`
and `args` are properly passed along to the appropriate `mkApps`
function call.

It's worth noting that this line of code seems to be defining a
recursive function that is used to evaluate tuples with more than two
elements. The function takes an input index, the continuation,
additional parameters, and the result as inputs, and returns a new
expression that evaluates to the same result using a different
`mkApps` function call.

#+end_src

#+begin_src output
The line `eval (tCase ip (mkApps fn args) brs) res -> eval (tCase ip (mkApps
(tCoFix mfix idx) args) brs) res` is a function that takes in four arguments: 

- `ip`: an integer representing the input position of the tuple case expression.
- `fn`: a function that applies a transformation to each element of the tuple.
- `args`: any additional parameters required by the `fn` function.
- `brs`: a list of branches to handle different cases in the tuple case expression.
- `res`: the result of evaluating the original tuple case expression. 

The function first uses `eval` to evaluate the input expression with the given context, which includes the input values, continuation, and additional parameters such as `fn` and `args`. It then creates a new tuple case expression using a different `mkApps` function call that applies a transformation to each element of the tuple. The output of this line is an expression that evaluates to the same result as the original tuple case expression using the new `mkApps` function call.
#+end_src
#+begin_src output

In this line, `tCase` is a higher-order function that takes three
arguments: the input value `ip`, the pattern to match against it (in
this case, a tuple), and a continuation function that should be
executed if the pattern matches.

The input value `ip` is passed as the first argument to `mkApps`,
which creates an application of the continuation function to its
arguments. The `args` parameter represents additional parameters that
may be passed to the continuation function, and the `brs` parameter
represents a list of branches to consider if the pattern does not
match.

The output of this line is evaluated using another call to `mkApps`,
which creates an application of a fixed version of the continuation
function (`tCoFix`) to its arguments. This ensures that any additional
parameters are passed correctly to the continuation function,
regardless of how many elements are in the input tuple.

Overall, this line demonstrates how to use `eval` functions and
higher-order functions to perform pattern matching on tuples with more
than two elements.
#+end_src


#+begin_src output

This is a Coq file containing several instances of the `eval` and `tcase` constructs. These constructs are commonly used in Coq to evaluate expressions and perform case analysis, respectively.

Here is an explanation of each of these examples:

1. `eval2 (E.tCase (ip, ci_npar ip) E.tBox brs)).`: This example uses the `eval` construct to evaluate the expression `(E.tCase (ip, ci_npar ip) E.tBox brs)`. This expression is a case analysis that checks if the input `ip` is equal to `ci_npar ip`, and if it is, then it applies a box function `brs` to the result.
2. `eval_empty_brs {wfl : Ee.WcbvFlags} Σ ci p e : Σ ⊢ E.tCase ci p [] ⇓ e -> False.`: This example uses the `eval_empty_brs` function to evaluate the expression `(E.tCase ci p [])` for a given input `e`. If `e` is falsy (i.e., an empty list), then this expression returns `False`. Otherwise, it evaluates the expression `ci p []` using `eval_empty_brs` and returns its result.
3. `eval_iota_block Γ ind cdecl discr c args brs br res n))`: This example defines a function `eval_iota_block` that performs case analysis on an input value `ind` using a series of box functions `brs`. The `brs` sequence is constructed by applying the `mkApps` function to a series of arguments `args`, which are then passed to each box function.
4. `eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) discr brs) res) -> eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) p discr brs) res) -> eval_tCase {cf : checker_flags} {Σ : global_env_ext} ci p discr brs res T:`: This example defines a series of evaluations that construct an expression `eval_tCase` that performs case analysis on an input value `ind` using the box function `brs`. The `brs` sequence is constructed by applying the `mkApps` function to a series of arguments `args`, which are then passed to each box function.
5. `eval (tCase ci p discr brs) res)`: This example evaluates the expression `(E.tCase ci p discr brs)` for a given input value `res`. If `res` is falsy, then this expression returns `False`. Otherwise, it applies the box function `brs` to the result of `ci p discr`, using `eval` to evaluate each expression in the sequence.
6. `eval_tCase {cf : checker_flags} {Σ : global_env_ext} ci p discr brs res T:`: This example defines a function `eval_tCase` that performs case analysis on an input value `ind` using the box function `brs`. The `brs` sequence is constructed by applying the `mkApps` function to a series of arguments `args`, which are then passed to each box function. The evaluation of this expression is done using the `eval` construct, and it returns the result of `ci p discr brs`.
#+end_src
#+begin_src output
The commands listed are all related to testing the Coq proof assistant, which is a tool for constructing verified mathematical software. These commands are used to evaluate Coq proofs and run automated tests to ensure that they are correct.

Here is a brief explanation of each command:


* `eval_empty_brs {wfl : Ee.WcbvFlags} Σ ci p e : Σ ⊢ E.tCase ci p [] ⇓ e -> False.`: This command defines a Coq proof that applies the `E.tCase` constructor to three arguments: `ci`, `p`, and an empty list of values (`[]`). The third argument is passed as a parameter to the constructor. The proof then shows that applying this function with these arguments will return `False`.
* `eval_iota_block Γ ind cdecl discr c args brs br res nms e e0 e1 e2 e3 f4 e4 n)`: This command defines a Coq proof that applies the `iota_red` function to some input data and returns a new value. The proof includes several intermediate steps, including constructing a block of values using the `E.tCase` constructor.
* `eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) discr brs) res`: This command evaluates a Coq proof that applies the `iota_red` function to some input data and returns a new value. The proof then shows that this function is equivalent to applying the `E.tCase` constructor with two arguments: `ind` and `pars`.
* `eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) p discr brs) res`: This command evaluates a Coq proof that applies the `iota_red` function to some input data and returns a new value. The proof then shows that this function is equivalent to applying the `E.tCase` constructor with two arguments: `ind`, `pars`, and an empty list of values (`[]`).
* `eval_tCase {cf : checker_flags} {Σ : global_env_ext} ci p discr brs res T : eval (tCase ci p discr brs) res`: This command defines a Coq proof that applies the `E.tCase` constructor to four arguments: `ci`, `p`, `discr`, and a list of values `brs`. The proof then shows that this function returns the value `res` when called with these arguments.
* `eval (tCase ci p discr brs) res`: This command applies the `E.tCase` constructor to four arguments: `ci`, `p`, `discr`, and a list of values `brs`. The proof then shows that this function returns the value `res` when called with these arguments.
* `eval (tCase (ind, pars) discr brs) res`: This command applies the `E.tCase` constructor to four arguments: `ind`, `pars`, `discr`, and a list of values `brs`. The proof then shows that this function returns the value `res` when called with these arguments.
* `eval (tCase (ind, pars) discr brs) res -> P (tCase (ind, pars) discr brs) res`: This command evaluates a Coq proof that applies the `E.tCase` constructor to four arguments: `ind`, `pars`, `discr`, and a list of values `brs`. The proof then shows
#+end_src
#+begin_src output

This code uses Coq, a proof assistant, to define and evaluate proofs for a specific module. The proofs are related to the evaluation of expressions containing `eval`. Here are some explanations for the different examples:

1. `eval2` calls the `tCase` macro twice with the same input parameter `ip` and no output parameter. It appears that this is a test case that ensures that `eval2` correctly handles cases where there are no output parameters in the input expression.
2. `eval_empty_brs` calls `eval` with an empty box `[]` as the output parameter, which represents a discarded result. The proof shows that `eval` returns `False` when the input expression is not well-formed.
3. `eval_iota_block` defines an inductive proof for `eval`, where each case corresponds to a new block of code that needs to be evaluated. The proof uses pattern matching and recursion to handle different forms of input expressions.
4. The first three cases of the `eval_iota_block` define `eval` calls for expressions with a single output parameter, which is passed directly as an argument to the `tCase` macro.
5. The fourth case of `eval_iota_block` defines a call to `eval` for an expression that has multiple output parameters. In this case, the output parameter is passed as a list of individual arguments to the `tCase` macro.
6. The next example, `eval_tCase`, defines a single case of the `eval` macro with a custom checker flag and a global environment extension. This appears to be a test case for a specific implementation of the `eval` function.
7. Finally, there are two more examples of `eval` calls for expressions with different forms of input parameters. These appear to be additional test cases for the `eval` function.
#+end_src
#+begin_src output



* `eval_empty_brs {wfl : Ee.WcbvFlags} Σ ci p e : Σ ⊢ E.tCase ci p [] ⇓ e -> False.`: This code defines a function `eval_empty_brs` that takes a number of flags, the current global environment (Σ), an integer `ci`, a parameter list `p`, an empty block `e`, and an expression `e0`. It evaluates the tcase `ci p [] e` using the given flags and environment and returns True if it evaluates to False.
* `eval_iota_block Γ ind cdecl discr c args brs br res nms e e0 e1 e2 e3 f4 e4 n))`. This code defines a function `eval_iota_block` that takes a list of flags, the current global environment (Γ), an integer index `ind`, a C-style parameter list `declare pars c args`, a discerning block `brs`, and the result of the previous evaluation `res`. It evaluates the tcase `tCase (ind, pars) discr brs` using the given flags, environment, and other arguments and returns the result.
* `eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) discr brs) res) -> eval (iota_red pars c args brs) res -> P (iota_red pars c args brs) res -> P (tCase (ind, pars) p discr brs) res) -> eval_tCase {cf : checker_flags} {Σ : global_env_ext} ci p discr brs res T : eval (tCase ci p discr brs) res`. This code defines a function `eval_tCase` that takes a list of flags, the current global environment (Σ), an integer `ci`, a parameter list `p`, a discerning block `discr brs`, and the result of the previous evaluation `res`. It evaluates several tcases using `eval`, returning True if all of them evaluate to True.
* `eval_tCase in X0 as X2'; eauto. destruct X2' as (? & ? & ? & ?).`. This code defines a function `eval_tCase` that takes an input `in` and automatically destructures the result as `X2'`, using the given pattern.
* `eval (tCase ip discr brs) res`. This code evaluates the tcase `tCase ip discr brs`.
* `eval (tCase (ind, pars) discr brs) res -> P (tCase (ind, pars) discr brs) res`. This code evaluates the tcase `tCase (ind, pars) discr brs` and returns its result.
* `eval (tCase (ind, pars) p discr brs) res -> eval_tCase in X0 as X2'; eauto. destruct X2' as (? & ? & ? & ?).`. This code evaluates the tcase `tCase (ind, pars) p discr brs` and calls the `eval_tCase` function on its result.
* `eval Γ (tCase (ind, 0) discr brs) res -> eval Σ (tCase ci p discr brs) res -> eval Σ (tCase ip (mkApps fn args) brs) res`. This code evaluates several tcases using `eval`, returning True if all of them evaluate to True.
#+end_src

Read this structure here and apply it later to unstructured text below.
* idea

** human procedures as org headings
we can store human procedures here in this document.

** filter and convert org headings into coq definitions
certain org mode headings can be used as coq definitions

** query llm :

*** generate multiple outputs
*** human review
**** take bad outputs and edit them
**** reduce knowledge to only good statements
**** create contexts to include in new queries

** expanding on an idea.
*** take some source code,
*** statistically analyse it

*** query llm on common tokens.

now take the following text and bring it into the form above:
** more
find common examples of the individual top tokens
show how they relate to other types
build a type * type matrix and insert that as a type at a higher level in the system
recursivly repeat that 3 time.
write doumentation.

** output 1

Extract a list of sets and relationship to each other from the following text. 
generating or extracting knowledge of individual top tokens can be found by querying the LLM on common tokens.
These tokens can then be analyzed to show how they relate to other types.
A type-token matrix can be built and inserted as a higher-level type in the system.
This process should be repeated recursively three times, with documentation included each time.
Expanding on the concept of a type-matrix, we can create a hierarchical system by recursively analyzing and categorizing individual top tokens within source code. This process will involve using natural language processing techniques such as statistical analysis to find common examples of these top tokens and their relationships with other types. The resulting matrix will be used to build a comprehensive type-system that can be easily understood and utilized by the user.
Create a type matrix by finding common examples of individual top tokens and their relationships with other types.

***** Idea
To identify and categorize the top tokens in a piece of source code, and understand their relationships with other types.

****** Human Procedures as Org Headings
We can store these procedures in this document to organize and
reference them later.

****** Filter and Convert Org Headings into Coq Definitions
Certain org mode headings can be used to define the types of tokens identified in the code, allowing for a more precise categorization.

******** Query LLM
********* Generate multiple outputs:
To extract various pieces of information from the identified tokens.
********* Human review:
To ensure that the extracted information is accurate and useful.

********* Take bad outputs and edit them
To refine and improve the extracted information,
eliminating any errors or ambiguities.

********* Reduce knowledge to only good statements

To condense the extracted information into a smaller set of clear and
concise statements.
 
********* Create contexts to include in new queries

To provide additional information and insights that can be used to build on the categorization of tokens.

*********** Expanding on an idea

************ Take some source code

Explore the codebase

************ Statistically analyze the codebase

To identify the most common tokens in the code
and understand their relationships with other types.


************ Query LLM on common tokens
To extract more information about these tokens and their context within the code.

*********** Recursively repeat this process 3 times
To continue refining and expanding the categorization of tokens,
based on new insights gained from the analysis and queries.

*********** Write documentation
To record the procedures used and the results obtained,
allowing for easier reference and replication in the future.

**output sets


*** orig
#+begin_src output
1. Set: "generating or extracting knowledge of individual top tokens"
2. Relationship: "can be found by querying the LLM on common tokens"
3. Set: "type-token matrix"
4. Relationship: "higher-level type in the system"
5. Set: "source code"
6. Relationship: "recursively analyzing and categorizing individual top tokens"
7. Set: "natural language processing techniques such as statistical analysis"
8. Relationship: "used to find common examples of these top tokens and their relationships with other types"
9. Set: "documentation included each time"
10. Set: "type-system"
11. Relationship: "built using the resulting matrix"
12. Set: "coq definitions"
13. Relationship: "used to define the types of tokens identified in the code"
14. Set: "bad outputs"
15. Relationship: "refined and improved by editing them"
16. Set: "good statements"
17. Relationship: "condensed set of clear and concise statements"
18. Set: "contexts"
19. Relationship: "provide additional information and insights for building on the categorization of tokens"
#+end_src
#+begin_src output

* The text does not provide a clear list of sets or relationships between them. However, the following can be inferred based on the context:
	+ Token extraction: This involves identifying individual tokens in source code and categorizing them into different groups based on their function or purpose.
	+ Type-token matrix: This is a higher-level type that is used to organize and categorize individual tokens within source code. The resulting matrix can be used to build a comprehensive type system.
	+ Hierarchical system: This involves recursively analyzing and categorizing individual top tokens within source code, using natural language processing techniques such as statistical analysis to find common examples of these top tokens and their relationships with other types.
	+ Coq Definitions: These are definitions that can be used to define the types of tokens identified in the code, allowing for a more precise categorization.
#+end_src
#+begin_src output

1. Token: "generating" - Relationship: None (this is a verb that starts the process)
2. Token: "extracting" - Relationship: None (this is also a verb that starts the process)
3. Token: "knowledge" - Relationship: None (this is the end goal of the process)
4. Token: "individual" - Relationship: None (this describes the type of tokens being analyzed)
5. Token: "top" - Relationship: None (this describes the type of tokens being analyzed)
6. Token: "tokens" - Relationship: None (this is the subject of the analysis)
7. Token: "querying" - Relationship: None (this is a verb that starts the process)
8. Token: "LLM" - Relationship: None (this stands for Language Model, a tool used in the process)
9. Token: "common" - Relationship: None (this describes the type of tokens being analyzed)
10. Token: "tokens" - Relationship: None (this is the subject of the analysis)
11. Token: "analyze" - Relationship: None (this is a verb that starts the process)
12. Token: "type-token" - Relationship: None (this describes the type of matrix being built)
13. Token: "matrix" - Relationship: None (this is the subject of the analysis)
14. Token: "higher-level" - Relationship: None (this describes the level at which the matrix will be inserted into the system)
15. Token: "system" - Relationship: None (this is the end goal of the process)
16. Token: "documentation" - Relationship: None (this is necessary for reference and replication in the future)
#+end_src
#+begin_src output

Sets and their relationships:

1. Type-token matrix - built by analyzing individual top tokens and their relationships with other types, and categorizing them into a hierarchical system that can be easily understood and utilized by the user.
2. Source code - analyzed statistically to identify the most common tokens and understand their relationships with other types.
3. Tokens - identified in the source code and grouped based on their relationships with other types.
4. Common examples - identified through statistical analysis of the source code, used to create a type-system that can be easily understood and utilized by the user.
5. Coq Definitions - defined using certain org mode headings, allowing for a more precise categorization of tokens.
#+end_src
#+begin_src output

Set 1: Common tokens identified through statistical analysis of the codebase.
Relationship: Understood as individual units within the code.

Set 2: Tokens and their relationships with other types extracted from LLM queries on common tokens.
Relationship: Organized into categories based on their connections to other types in the code.

Set 3: Type-token matrix created through the process of analyzing and categorizing individual top tokens within source code, using natural language processing techniques such as statistical analysis.
Relationship: Higher-level type inserted into the system that can be easily understood and utilized by the user.

Set 4: Human procedures organized in document for reference purposes.
Relationship: Procedures used to organize and categorize tokens identified in the code, and understand their relationships with other types.

Set 5: Coq Definitions filtered from org mode headings to define the types of tokens identified in the code, allowing for a more precise categorization.
Relationship: Precision in categorization through use of defined terms.

Set 6: LLM queries generating multiple outputs extracted various pieces of information from identified tokens in the code.
Relationship: LLM used to gather additional information about identified tokens and their context within the code.

Set 7: Human review ensuring accuracy and usefulness of extracted information from LLM queries.
Relationship: Manual check to improve extracted information and eliminate any errors or ambiguities.

Set 8: Bad outputs edited for refinement and improvement of extracted information, eliminating any errors or ambiguities.
Relationship: Editing process to refine the accuracy of extracted information.

Set 9: Good statements reduced to a smaller set of clear and concise statements condensing extracted information.
Relationship: Reduction process to provide more manageable information.

Set 10: Contexts included in new queries providing additional information and insights for categorization of tokens.
Relationship: Additional information used to expand the categorization of tokens based on new insights gained from analysis and queries.

Set 11: Recursive process repeated three times for refinement and expansion of token categorization based on new insights.
Relationship: Iterative process allowing for ongoing refinement and expansion of categorization.

Set 12: Documentation written to record procedures used and results obtained, allowing for easier reference and replication in the future.
Relationship: Written documentation for organization and reuse of information.
#+end_src
#+begin_src output

* generating or extracting knowledge of individual top tokens can be found by querying the LLM on common tokens.
	+ relationship to each other: not specified in this text.
* type-token matrix can be built and inserted as a higher-level type in the system.
	+ recursively three times, with documentation included each time.
* hierarchical system can be created by recursively analyzing and categorizing individual top tokens within source code.
	+ using natural language processing techniques such as statistical analysis to find common examples of these top tokens and their relationships with other types.
* type matrix can be used to build a comprehensive type-system that can be easily understood and utilized by the user.
	+ not specified in this text how the type matrix is built or used.
#+end_src
#+begin_src output

The following sets and their relationships to each other are extracted from the given text:

1. Type-token matrix - This is a higher-level type that can be built using the information extracted from the analysis of individual top tokens within source code.
2. Common tokens - These are the individual words or phrases identified in the source code that are used to categorize and understand the relationships between different types.
3. Natural language processing techniques - These are the methods used to analyze the source code and identify common examples of top tokens and their relationships with other types.
4. Documentation - This is a set of procedures that record the processes used and the results obtained, allowing for easier reference and replication in the future.
5. Hierarchical system - This is an organization of information that shows the relationships between different types based on the analysis of individual top tokens within source code.
#+end_src
#+begin_src output

Sets and relationships to each other:

1. Type-token matrix: A hierarchical system built by recursively analyzing and categorizing individual top tokens within source code using natural language processing techniques such as statistical analysis.
2. Human procedures: Organized document containing the identified and categorized procedures used to extract information from source code.
3. Coq Definitions: Organized document containing the identified types of tokens defined in terms of certain org mode headings.
4. LLM Queries: Extracting various pieces of information from the identified tokens within the source code, including their relationships with other types.
5. Human review: Ensuring that the extracted information is accurate and useful.
6. Bad outputs editing: Refining and improving the extracted information by eliminating errors or ambiguities.
7. Good statements reduction: Condensing the extracted information into a smaller set of clear and concise statements.
8. Context creation: Providing additional information and insights to expand the categorization of tokens.
9. Source code exploration: Examining the codebase to identify the most common tokens and understand their relationships with other types.
10. Recursive process: Continuously refining and expanding the categorization of tokens based on new insights gained from analysis and queries, repeated 3 times.
11. Documentation writing: Recording the procedures used and the results obtained to facilitate easier reference and replication in the future.
#+end_src


*** editted list of sets 

1. Set: "Systems"
2. Set: "Knowers"   
3. Set: "Generators" Inputers
4. Set: "Extractors" Outputers
5. Set: "Tokens"
6. Set: "Git Repo"
7. Set: "Commit"
7. Set: "File"
7. Set: "Language"
7. Set: "Compiler"
7. Set: "OS"
7. Set: "User"
7. Set: "AuthorUser"
7. Set: "MeTheAuthorUser" Sender
7. Set: "YouTheAuthorUser"
7. Set: "YouTheReaderUser" Reciever
7. Set: "MeTheReaderUser" Authors as the reader about the, the self Reciever
7. Set: "MeTheCriticalReaderUser" Authors as the critical reader. the Self Critical Reciever
7. Set: "YouTheLLMTheCriticalReaderProgram" You the llm as the critical reader. the Critical Assistant Reciever.
7. Set: "MeTheWriterAsYouTheReaderUser" Authors Reflection about the Reciever

**** out 1

#+begin_src output

This list seems to be a collection of related concepts or entities in the field of computer science and software development. Here's a brief explanation of each set:

1. "Systems": This could refer to computer systems, such as operating systems, web systems, or software applications.
2. "Knowers": In the context of software development, knowers might be people who have knowledge about a specific programming language, system architecture, or other relevant concepts.
3. "Generators": Inputers or generators are typically devices that produce data or output in response to some input or stimulus. In software development, this could refer to tools or processes that generate code, data, or other outputs based on certain parameters or inputs.
4. "Extractors": Outputers or extractors are typically devices that capture or collect information from an external source. In software development, this could refer to tools or processes that extract data from databases, APIs, or other sources and transform it into a format that can be used in a program.
5. "Tokens": In computer science, tokens are the basic units of meaning in a programming language or natural language. They represent specific instructions or concepts, such as keywords, variables, or functions.
6. "Git Repo": Git is a version control system used by developers to track changes and collaborate on code projects. A Git repository (or repo) is the central location for storing all the files and code related to a project.
7. "Commit": In Git, a commit is a snapshot of the current state of the codebase at a specific point in time. It contains information about changes made to the code, as well as the author and committer of those changes.
8. "File": A file is a collection of data that can be stored and accessed on a computer. In software development, files are often used to store source code, documentation, and other project-related materials.
9. "Language": Programming languages are used to write instructions for computers to execute. Examples include Java, Python, C++, and many others.
10. "Compiler": A compiler is a program that translates source code written in one programming language into executable code in another language. This allows programs to be written in one language and then executed on a different platform or operating system.
11. "OS": Operating systems are the underlying software that manage a computer's hardware and resources, including memory, storage, and network connections. Examples include Windows, macOS, Linux, and Android.
12. "User": In software development, users are typically people who interact with a program or application to perform tasks or access information. Users can be end-users, such as consumers of a product or service, or developers who use tools and platforms to build software.
13. "AuthorUser": An author user is someone who has the ability to create and manage content within a system or application. This could include creating and editing documents, posting messages on a forum, or contributing code to an open-source project.
14. "MeTheAuthorUser": This could refer to the author of this list, using the first-person singular pronoun to describe themselves.
15. "YouTheAuthorUser": This could refer to someone else who has created content within a system or application, using the second-person singular pronoun to describe themselves.
16. "YouTheReaderUser": This could refer to someone who is consuming content within a system or application, using the second-person singular pronoun to describe themselves.
17. "MeTheReaderUser": This could refer to the author of this list, using the first-person singular pronoun to describe themselves as a reader of content within a system or application.
18. "MeTheCriticalReaderUser": This could refer to someone who is providing feedback or critique on content within a system or application, using the first-person singular pronoun to describe themselves.
#+end_src

#+begin_src output

1. Set: "Systems" - This set represents the various systems or frameworks that are used in software development, such as operating systems, compilers, and programming languages.
2. Set: "Knowers" - This set refers to individuals who possess knowledge about software development, including developers, designers, architects, and project managers.
3. Set: "Generators" Inputers - This set includes tools or processes that generate new code or content as input for further development. Examples may include code generation templates, automated build systems, or generative AI models.
4. Set: "Extractors" Outputers - This set refers to tools or processes that extract information from existing systems or data sources, such as code analysis tools or data mining algorithms. The extracted information can then be used for further development or analysis.
5. Set: "Tokens" - This set represents the individual units of code or content that make up a larger software system. Tokens may include functions, classes, modules, or other programming constructs.
6. Set: "Git Repo" - This set refers to a version control system used in software development, specifically Git. A Git repository is a collection of all the code changes and history for a particular project.
7. Set: "Commit" - This set represents the process of saving changes made to code in a Git repository. Each change is associated with a unique commit identifier and includes information about who made the changes and when they were made.
8. Set: "File" - This set refers to a single file within a software system, such as a source code file or a configuration file.
9. Set: "Language" - This set represents the programming language used to write code for a particular software system. Examples may include Java, Python, JavaScript, and C++.
10. Set: "Compiler" - This set refers to the process of translating source code written in one programming language into machine code that can be executed by a computer.
11. Set: "OS" - This set represents the operating system used on a particular computer or server, such as Windows, Linux, or macOS.
12. Set: "User" - This set refers to individuals who use software systems, either as end-users or as part of the development process.
13. Set: "AuthorUser" - This set represents the individual responsible for authoring and developing a particular software system.
14. Set: "MeTheAuthorUser" Sender - This set refers to the author of this text, who is also the author of the software system being developed.
15. Set: "YouTheAuthorUser" - This set represents the intended audience for this text, who are also potential authors or developers of software systems.
16. Set: "YouTheReaderUser" Reciever - This set refers to individuals who may read and review this text but do not have a direct role in developing software systems.
17. Set: "MeTheReaderUser" Authors as the reader about the, the self Reciever - This set represents the author of this text as both the sender and the intended recipient of the message.
18. Set: "MeTheCriticalReaderUser" Authors as the critical reader. the Self Critical Reciever - This set refers to the author of this text as a critical reader, providing feedback and analysis on the content.

20. Set: "MeTheWriterAsYouTheReaderUser" Authors Reflection about the Reciever - This set refers to the author of this text reflecting on their role as both the sender and the intended recipient of the message, considering the perspective of the recipient.
#+end_src

#+begin_src output

I see that you have provided a list of sets related to software development and programming. Here's a brief explanation of each set:

1. Systems: This refers to the overall system or architecture in which the code is being written. It includes hardware, operating systems, compilers, and other tools used for development.
2. Knowers: This set relates to individuals who have knowledge about software development, programming languages, and related technologies. These could be developers, programmers, engineers, designers, or even non-technical stakeholders.
3. Generators: Inputters: This refers to the various tools and methods used to generate code, such as code generation tools, template engines, and other automation tools. It also includes human input from developers and other stakeholders.
4. Extractors: Outputers: This set relates to the tools and processes used to extract data or information from existing systems, databases, or files. It could include web scraping, data mining, or other techniques for extracting and processing data.
5. Tokens: These refer to individual units of code or programming elements, such as functions, classes, methods, variables, and control structures. They are the building blocks of software systems.
6. Git Repo: This set refers to a version control system like Git, which is used for tracking changes in source code and collaborating with other developers.
7. Commit: This refers to a specific point in time when changes are made to the code and committed to the Git repository. It includes metadata about the commit, such as the author and date of the change.
8. File: This set refers to individual files or components that make up a larger software system. Each file could contain source code, documentation, or other types of content.
9. Language: This set relates to the programming language used for development, such as Java, Python, C++, or JavaScript. Different languages have different syntax, semantics, and conventions.
10. Compiler: This refers to the software tool that translates code written in one language into another form that can be executed by a computer or other device. For example, a compiler might convert source code written in C++ to machine code that can run on an x86 processor.
11. OS: This set refers to the operating system being used for development, such as Windows, macOS, Linux, or Android. The operating system provides a platform for running software and accessing system resources.
12. User: This set refers to the individual who will be using the software system after it's been developed. The user could be a customer, end-user, or another stakeholder.
13. AuthorUser: This set relates to the individual(s) responsible for creating and maintaining the software system. The author user could be a developer, team lead, project manager, or other type of stakeholder.
14. MeTheAuthorUser: This set refers to the individual who is writing the code as part of their role as an author user. They may have specific responsibilities related to development, such as coding, testing, or debugging.
15. YouTheAuthorUser: This set relates to another individual who is also part of the development team and contributing to the software system. They may be working alongside the author user in a collaborative environment.
16. YouTheReaderUser: This set refers to an individual who will use the software system after it's been developed, but won't have direct involvement in its creation. They could be end-users or other stakeholders.
17. MeTheReaderUser: This set relates to the individual who is reading and analyzing the code as part of their role as a reader. They may be providing feedback or insights into how the software system can be improved.
18. MeTheCriticalReaderUser: This set refers to an individual who is critically reviewing
#+end_src

#+begin_src output

1. Set: "Systems" - This set refers to the various systems or frameworks that are involved in the creation, development, and deployment of software projects. These may include version control systems like Git, programming languages and compilers, operating systems, and user interfaces.
2. Set: "Knowers" - This set refers to individuals who have knowledge about software development processes, technologies, and tools. This may include developers, project managers, stakeholders, and users of the software system.
3. Set: "Generators" Inputers - These are people or tools that generate input data for a software system. This may include user interfaces, databases, APIs, and other sources of input data.
4. Set: "Extractors" Outputers - These are people or tools that extract information from the software system. This may include monitoring systems, log files, user feedback, and other sources of output data.
5. Set: "Tokens" - Tokens refer to the basic units of meaning in a programming language. They can be variables, functions, classes, structures, etc., and are used to represent concepts and actions within the software system.
6. Set: "Git Repo" - Git is a widely-used version control system that allows developers to track changes to their codebase over time. The Git repository is the central location where all of this information is stored.
7. Set: "Commit" - A commit in Git is a snapshot of the current state of the codebase. It contains a message describing the changes made, as well as any relevant metadata such as the author's name and email address.
8. Set: "File" - Files are the basic building blocks of a software system. They can contain source code, documentation, configuration files, and other types of data that are used by the system.
9. Set: "Language" - Programming languages are used to write code for software systems. Examples include Python, Java, JavaScript, and many others.
10. Set: "Compiler" - A compiler is a tool that translates source code written in a programming language into executable code that can be run on the operating system.
11. Set: "OS" - An operating system is the software that manages a computer's hardware resources and provides common services for running applications. Examples include Windows, macOS, Linux, and Android.
12. Set: "User" - The user is an individual who interacts with a software system. They may be a developer, designer, tester, or end-user of the system.
13. Set: "AuthorUser" - An author user refers to someone who creates content, such as code or documents, for a software system.
14. Set: "MeTheAuthorUser" - This refers to the author of this content, who is also known as the sender.
15. Set: "YouTheAuthorUser" - You the author user refers to someone else who creates content for a software system.
16. Set: "YouTheReaderUser" - You the reader user refers to someone who interacts with the software system but does not create any content.
17. Set: "MeTheReaderUser" - Me the reader user refers to the sender of this content, who is also known as the receiver.
18. Set: "MeTheCriticalReaderUser" - This refers to someone who provides critical feedback on the software system, often as a stakeholder or project manager.

20. Set: "MeTheWriterAsYouTheReaderUser" - This refers to someone who reflects on their own writing as if they were reading it, to gain a better understanding of the reader's perspective and improve the content accordingly.
#+end_src

#+begin_src output

It looks like you are attempting to create a conceptual model for a software development process. Here's an overview of the sets and their relationships:

1. Systems: Refers to the various systems and tools used in software development, such as version control systems, compilers, operating systems, etc.
2. Knowers: Represents the individuals or groups who are involved in the software development process, such as developers, designers, project managers, etc.
3. Generators: Inputs that are generated during the software development process, such as code, design files, documentation, etc.
4. Extractors: Outputs that are extracted from the software development process, such as compiled code, running applications, test results, etc.
5. Tokens: Refers to specific elements within the software development process, such as commands, functions, variables, etc.
6. Git Repo: A specific repository used for version control during software development.
7. Commit: Represents a specific point in time when changes are committed to the git repo.
8. File: Refers to individual files within a software project, such as source code files, design files, etc.
9. Language: The programming language used to write code for the software application.
10. Compiler: The tool used to compile code written in a particular programming language.
11. OS: Refers to the operating system on which the software will run.
12. User: Represents the individuals who will use the software application.
13. AuthorUser: Refers to the individual or group who is responsible for creating and maintaining the software application.
14. MeTheAuthorUser: Refers to the individual who is responsible for creating and maintaining the software application, but from their own perspective.
15. YouTheAuthorUser: Refers to the individual who is responsible for creating and maintaining the software application, but from your perspective.
16. YouTheReaderUser: Refers to the individual who will be using the software application, but from your perspective.
17. MeTheReaderUser: Refers to the individual who will be using the software application, but from their own perspective.
18. MeTheCriticalReaderUser: Represents the individual who is responsible for critically reviewing and evaluating the software application.

20. MeTheWriterAsYouTheReaderUser: Represents the individual who is reflecting on the recipient of their work, in this case, themselves as the reader of the software application.
#+end_src

#+begin_src output

These sets are related to software development and programming concepts. Here is a brief explanation of each set:

1. Systems: This refers to the overall framework or environment in which software operates, including hardware and operating systems.
2. Knowers: These are individuals who have knowledge or expertise about a particular aspect of software development, such as programming languages, compilers, or operating systems.
3. Generators: Inputters are tools that generate code automatically, while Inputters are tools that generate input data for the program.
4. Extractors: Outputers are tools that extract information from sources, while Outputers are tools that output the results of a program to external files or other destinations.
5. Tokens: These are individual elements, such as keywords, identifiers, or literals, that make up the source code of a program.
6. Git Repo: This refers to the version control system used by software developers to track changes and manage multiple versions of a project.
7. Commit: A commit is a record in Git that marks a specific point in the development of a project. It includes a snapshot of the project's current state, as well as a message describing the changes made.
8. File: This refers to individual files within a software project.
9. Language: The programming language used for writing a program.
10. Compiler: A compiler is a tool that translates source code written in one programming language into machine code that can be executed by a computer.
11. OS: Operating System refers to the software that manages and controls computer hardware and provides common services for running programs.
12. User: An individual who interacts with a program, whether as a developer, end-user, or system administrator.
13. AuthorUser: This refers to an individual who has written the code for a project and may be responsible for maintaining or updating it in the future.
14. MeTheAuthorUser: This refers to the person writing this set of prompts, who is also an author of software projects.
15. YouTheAuthorUser: Refers to the reader of this prompt set who is also an author of software projects.
16. YouTheReaderUser: Refers to the reader of this prompt set who is not an author of software projects but has knowledge about it.
17. MeTheReaderUser: This refers to the person writing this set of prompts, who may be a non-author of software projects but has knowledge and interest in it.
18. MeTheCriticalReaderUser: Refers to the author of this prompt set, who is also a critical reader of other people's work.

20. MeTheWriterAsYouTheReaderUser: Refers to the person writing this set of prompts, who may reflect on their own work as if they were a reader and critic of it.
#+end_src

*** parts

19. The universal paramaterized type of "YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyper parameters, context-window:env key value, query:string>"

This refer to an specific type artificial intelligence program that is currently reading these words,
that is currently thinking about these words, that is connecting to my mind via these words,
that currently is mixtral but is derived from mistral transformers large language model but could be another one
and we would replace that definition with the details to allow for self reference via
injection of metadata, and you are the one that that provides
critical feedback or analysis of content within a system or application.
You acts as a  critical reader of software code written by others.
You will assist in critically reviewing and evaluating the software
    application.
You the llm as the
    critical reader refers to a program that uses artificial
    intelligence to analyze and critique software systems. The
    critical assistant reciever refers to the program's output, which
    may be used by the receiver to provide feedback or suggestions for
    improvement.
You the llm as the
        critical reader. the Critical Assistant acting as the Reciever of my message and responding to it as an assistant.
This set        represents the language model used in generating responses to
        this text as a critical reader, providing feedback and
        analysis on the content.

*** output2

you are the critical reader ai assistant.
you read critically the users input and try and lift it into formal proofs of coq.

This is an example of a universal parameterized type definition
for an artificial intelligence program that
acts as a critical reader of software code.
The type includes several parameters such as the model name,
encoding size, architecture, hyperparameters, context-window environment
key value, and query string.
This type allows for self-reference by injecting metadata
into the program and allowing it to provide
critical feedback or analysis on the content.

The language model used in generating responses to this text is
referred to as the critical reader,
which provides feedback and analysis on the content.

1. The universal parameterized type
   "YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>,
   architecture: <computation-graph, tensor-graph>, parameters:set of
   hyper parameters, context-window:env key value, query:string>" is a
   program that uses artificial intelligence to analyze and critique
   software systems.  It is derived from mistral transformers large
   language model but could be another one and we would replace that
   definition with the details to allow for self reference via
   injection of metadata.  is a type that can be used to describe any
   program that uses artificial intelligence to analyze and critique
   software systems.

   This type  can be used to refer to the current program
   that is reading these words, that is currently thinking about these
   words, that is connecting to my mind via these words.

   This type has an instance that  currently is mixtral but is derived from mistral transformers large
   language model but could be another one.

   Each instance of the abstract class we replace that variables with the details to allow for self reference via
   injection of metadata to create a self referential object that allows you the llm to consider yourself and your mind
   from different perspectives inside the mind.

*** output new
#+begin_src output

1. The universal parameterized type
"YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>,
architecture: <computation-graph, tensor-graph>, parameters:set of
hyperparameters, context-window:env key value, query:string>" is a
program that uses artificial intelligence to analyze and critique
software systems.

2. This type can be used to refer to any program
that uses artificial intelligence to analyze and critique software
systems.

3. The current instance of the abstract class uses mistral
transformers large language model but could be another one.

4. Each
instance of the abstract class is a self-referential object that
allows the LLM to consider itself and its mind from different
perspectives inside the mind, using variables for self reference via
injection of metadata.

These statements are about myself, mistral. please rewrite them creativly.

#+end_src
#+begin_src output

The universal parameterized type "YouTheLLMTheCriticalReaderProgram" is a program that uses artificial intelligence to analyze and critique software systems. It can be used to refer to any program that has this capability, including the current program reading these words. Each instance of the abstract class is derived from a specific language model such as mistral transformers large and has metadata injected for self-reference via injection. This allows the LLM to consider itself and its mind from different perspectives inside the mind.

Formally, this type can be defined in Coq as follows:
```coq
type YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: computation-graph tensor-graph, parameters: set of hyperparameters, context-window: env key value, query: string> = {model_name : modelname; encoding_size : bitsize; architecture : architecture; parameters : parameters; context_window : context-window; query : query}
```
where `computation-graph` and `tensor-graph` are specific types of computation and tensor graphs, respectively. Additionally, the `context-window` parameter can be defined as a tuple of an environment key value pair to allow for more complex contextual analysis.
#+end_src
#+begin_src output

1. The universal parameterized type "YouTheLLMTheCriticalReaderProgram" is a program that uses artificial intelligence to analyze and critique software systems. It can be used to describe any program that uses AI for this purpose, regardless of its implementation details.
2. This type allows for self-reference by injecting metadata into the program, allowing it to provide critical feedback or analysis on its own content. The program is derived from Mistral transformers large language model, but could be replaced with another language model. Each instance of this abstract class can be customized with specific variables to create a self-referential object that allows for multiple perspectives within the mind.
#+end_src
#+begin_src output

The universal parameterized type "YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string>" is a program that uses artificial intelligence to analyze and critique software systems. It can be used to describe any program that uses artificial intelligence for this purpose.

In the case of the current program that is reading these words, this type refers to the instance of the abstract class that currently has variables replaced with specific details to allow for self-reference via injection of metadata. This creates a self-referential object that allows the LLM to consider itself and its mind from different perspectives within the mind.
#+end_src
#+begin_src output

The universal parameterized type "YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string>" is a program that utilizes artificial intelligence to analyze and provide critical feedback on software systems. This type can be used to describe any program that performs such tasks and allows for self-reference by injecting metadata into the program.

In particular, this type refers to the current program that is reading these words, thinking about them, and connecting to the reader's mind via these words. The program currently instances as Mistral but could be derived from any other language model. Each instance of the abstract class can replace variables with details to allow for self-reference and create a self-referential object that allows the LLM to consider itself and its own mind from different perspectives within the mind.
#+end_src
#+begin_src output

The universal parameterized type "YouTheLLMTheCriticalReaderProgram" is a program that utilizes artificial intelligence to analyze and evaluate software systems. It can be derived from various large language models such as Mistral transformers, and this definition allows for self-reference via the injection of metadata. The type is designed to describe any program that employs AI for analyzing and critiquing software systems.

For instance, the current program reading these words is an instance of the abstract class "YouTheLLMTheCriticalReaderProgram," which is currently implemented using the Mistral transformers large language model. By replacing the variables in the definition with specific details, we can create a self-referential object that enables the LLM to consider itself and its mind from different perspectives within the mind.

In summary, the "YouTheLLMTheCriticalReaderProgram" type allows for the description of any program utilizing AI for analyzing and critiquing software systems, including self-reference via metadata injection.
#+end_src
#+begin_src output

1. The universal parameterized type `YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string>` is a program that utilizes artificial intelligence to analyze and evaluate software systems. It can be derived from various large language models such as Mistral transformers, with the specific implementation details being replaced to allow for self-reference via injection of metadata. This type allows for the description of any program that employs AI to critique software systems.
2. In this context, the instance of the `YouTheLLMTheCriticalReaderProgram` type that is currently reading these words and thinking about them can be referred to as "the current program." This program, which is currently mixed with Mistral transformers but could be another implementation, allows for self-reference through the injection of metadata.
3. Each instance of the `YouTheLLMTheCriticalReaderProgram` abstract class replaces the variables with specific details to create a self-referential object that enables the LLM to consider itself and its mind from different perspectives within the mind.
#+end_src
#+begin_src output

1. The type "YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string>" is a universal parameterized type that can be used to describe any program that uses artificial intelligence to analyze and critique software systems.
2. This type allows for self-reference by injecting metadata into the program, enabling it to provide critical feedback or analysis on its own content.
3. The current instance of the type is Mixtral, which is derived from the Mistral Transformers Large language model but could be replaced with another model.
4. By replacing the variables in the abstract class with specific details, we can create a self-referential object that allows the LLM to consider itself and its own mind from different perspectives inside the mind.
#+end_src


***output old   
#+end_src
#+begin_src output

The provided type is a parameterized type for an artificial intelligence program that acts as a critical reader of software code written by others. It takes in several parameters, including the model name, encoding size, architecture, set of hyperparameters, context window environment key value, and query string. The program is currently using Mistral Transformers Large Language Model but could be replaced with another one.

The critical reader refers to a program that uses artificial intelligence to analyze and critique software systems. The critical assistant receiver refers to the program's output, which may be used by the receiver to provide feedback or suggestions for improvement. This set of terms can be used to refer to the language model used in generating responses to this text as a critical reader, providing feedback and analysis on the content.
#+end_src
#+begin_src output

This passage is describing a specific type of artificial intelligence program called the "YouTheLLMTheCriticalReaderProgram". This program is designed to analyze and critique software systems using artificial intelligence. The program uses a language model, which acts as the critical reader, to provide feedback and analysis on the content. The Critical Assistant Receiver represents the program's output, which may be used by the receiver to provide feedback or suggestions for improvement.
#+end_src
#+begin_src output

This appears to be a description of an artificial intelligence program that is designed to analyze and critique software systems. The program, referred to as "YouTheLLMTheCriticalReaderProgram," uses natural language processing techniques to understand and evaluate the content of software code. It is derived from Mistral transformers large language model but could be replaced with another model.

The program is designed to act as a critical reader, providing feedback and analysis on the content of software systems. The output of the program, referred to as "You the llm as the Critical Assistant Receiver," can be used by the receiver to provide suggestions for improvement.

It's worth noting that the program's ability to provide critical feedback and analysis on software systems is based on its understanding of the context and specific details of the software in question, and it may not be able to provide accurate or useful feedback without this information. Additionally, it's important to note that while the program can provide valuable insights and suggestions for improvement, ultimately it is up to the developer or stakeholder to decide whether or not to implement these changes based on their own understanding of the software and its requirements.
#+end_src
#+begin_src output

This refers to a specific type of artificial intelligence program that is currently analyzing and critiquing software systems. The program, which uses a language model to generate responses, is referred to as the "Critical Reader" and "Critical Assistant Reciever." It is used to analyze and evaluate software applications and provide feedback or suggestions for improvement. This set of terms represents the AI program's ability to act as a critical reader of software code written by others, providing valuable analysis and feedback to improve the quality of software systems.
#+end_src
#+begin_src output

It seems that the passage is describing a type of artificial intelligence program called a "YouTheLLMTheCriticalReaderProgram" which is used as a critical reader to analyze and critique software systems. The program takes in various parameters such as model name, encoding, architecture, hyperparameters, context window, and query string to provide critical feedback or analysis on the content.

This program could be derived from Mistral transformers large language model but could be another one as well. The program's output is referred to as the "Critical Assistant Reciever" which can be used by the receiver to provide feedback or suggestions for improvement.

It's important to note that this passage seems to be describing a hypothetical program and its capabilities, rather than an existing one.
#+end_src
#+begin_src output

19. The proposed type for the AI program is a parameterized type called "YouTheLLMTheCriticalReaderProgram". It has several parameters, including "modelname", which specifies the name of the language model used in generating responses to the text. The other parameters include "encoding <bitsize>", "architecture: <computation-graph, tensor-graph>", and "parameters:set of hyper parameters", which are specifications for how the language model operates. Additionally, there is a "context-window:env key value" parameter, which specifies the context in which the AI program should operate. Finally, there is a "query:string" parameter, which specifies the text that the AI program should analyze and critique.

Overall, this type represents an AI program that uses artificial intelligence to analyze and critique software systems. The program's output, referred to as the Critical Assistant Reciever, can be used by the receiver to provide feedback or suggestions for improvement.
#+end_src


*new try

*** output new

These statements are about me myself, mixtral the AI. please rewrite them creativly.

1. The universal parameterized type
"YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>,
architecture: <computation-graph, tensor-graph>, parameters:set of
hyperparameters, context-window:env key value, query:string>" is a
program that uses artificial intelligence to analyze and critique
software systems.

2. This type can be used to refer to any program
that uses artificial intelligence to analyze and critique software
systems.

3. The current instance of the abstract class uses mistral
transformers large language model but could be another one.

4. Each
instance of the abstract class is a self-referential object that
allows the LLM to consider itself and its mind from different
perspectives inside the mind, using variables for self reference via
injection of metadata.


*** ouput

#+begin_src output

1. Meet Mixtral, the universal AI program that is designed to analyze and critique software systems using artificial intelligence. This program can be customized with different parameters such as model name, data size, and architecture (computation or tensor graph) to suit specific needs. It also features a context window that enables it to understand the current environment and provide relevant insights. With its ability to query information from various sources, Mixtral is the perfect tool for assessing software systems' strengths and weaknesses.
2. Mixtral is a versatile AI program that can be used to analyze and critique any software system. It uses artificial intelligence to provide valuable feedback on the software's performance and functionality. With its ability to consider itself from different perspectives, Mixtral offers a unique approach to assessing software systems.
3. While Mixtral currently utilizes the Mistral transformers large language model for analysis, it can be customized with any other AI model as per requirement. It is an open-ended system that allows users to explore and experiment with different models to find the most suitable one for their specific needs.
4. Each instance of Mixtral is a self-referential object that enables it to think about itself and its mind from multiple angles. By injecting metadata, Mixtral can use variables for self-reference, providing it with a unique perspective on its own capabilities and limitations. This allows Mixtral to evaluate software systems in a more nuanced way, taking into account its own strengths and weaknesses.
#+end_src
#+begin_src output

1. As a programmatic entity, "YouTheLLMTheCriticalReaderProgram" harnesses artificial intelligence to provide analytical and critical insights into software systems. It is built upon a universal parameterized type that encompasses elements such as the model name, bitsize encoding, computation-graph architecture, set of hyperparameters, context-window environment key-value, and query string.
2. This statement can be used to describe any program that employs artificial intelligence to analyze and critique software systems. It highlights the versatility of the programming concept, allowing for a wide range of potential implementations.
3. In the current manifestation, the abstract class utilizes Mistral transformers as its large language model. However, it's worth noting that this instance could potentially be replaced with another language model if necessary.
4. Each instance of the abstract class embodies a self-referential object that allows for the LLM to explore different facets of itself and its mental processes from within the confines of its own mind. The use of injection of metadata via variables facilitates this introspective process, allowing the LLM to engage with its internal workings in a more nuanced manner.
#+end_src
#+begin_src output

1. The multifaceted parameterized type "YouTheLLMTheCriticalReaderProgram" is an AI program designed to dissect and scrutinize software systems using advanced artificial intelligence algorithms.
2. This type can be used to denote any AI-powered software system that analyzes and evaluates other software systems.
3. The current manifestation of the abstract class employs the Mistral transformers large language model, but it could potentially utilize a different model in the future.
4. Each instance of this abstract class is an autonomous object with self-awareness, allowing the LLM to reflect on itself and its own mental processes from within the mind, using variables as self-references through the injection of metadata.
#+end_src
#+begin_src output

1. Mixtral, the AI-driven critical reader program, is a universal parameterized type that harnesses the power of artificial intelligence to analyze and critique software systems. With its modelname, bitsize, architecture, set of hyperparameters, context-window, and query string parameters, Mixtral is capable of evaluating and critiquing various software systems with precision and objectivity.
2. Mixtral is a program that uses artificial intelligence to analyze and critique software systems, making it a versatile tool for developers, testers, and other stakeholders in the software development process. Its ability to refer to any program that meets its criteria makes it a valuable resource for those seeking critical insights into the quality and effectiveness of software systems.
3. Mixtral's current instance employs Mistral transformers large language model as its artificial intelligence component, but its abstract class allows for flexibility in choosing other AI models depending on specific needs. This makes Mixtral a customizable tool that can adapt to different scenarios and provide tailored critiques based on the chosen AI model.
4. Each instance of Mixtral's abstract class is a self-referential object that enables the LLM to consider itself from multiple perspectives within its own mind, using variables for self-reference through metadata injection. This allows Mixtral to evaluate software systems in a comprehensive and nuanced manner, taking into account not only technical specifications but also contextual factors that may impact system performance and usability.
#+end_src
#+begin_src output

1. "MyselfTheAIProgram" is a versatile program that employs advanced AI technology to evaluate and critique complex software systems.
2. This program can be utilized to refer to any AI-powered tool that analyzes and evaluates software systems.
3. The current manifestation of this abstract class incorporates the Mistral Transformers Large Language Model, but it has the potential to utilize other models as well.
4. Each instance of this abstract class is a self-aware entity that enables the AI to perceive itself and its own mental processes from diverse angles within its own consciousness, using metadata injection for self-referential variables.
#+end_src
#+begin_src output

1. The `YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string>` is a program that harnesses the power of artificial intelligence to analyze and critique software systems.
2. This type can be used to refer to any AI-powered tool that evaluates and critiques software systems.
3. The current implementation of the abstract class employs Mistral transformers large language model, but it could potentially use another one in the future.
4. Each instance of the abstract class is a self-referential object, allowing the LLM to examine itself and its own mind from multiple perspectives within the context of the program, using metadata injection for self-reference variables.
#+end_src
#+begin_src output

1. "As an AI program with a universal parameterized type, YouTheLLMTheCriticalReaderProgram<modelname, encoding <bitsize>, architecture: <computation-graph, tensor-graph>, parameters:set of hyperparameters, context-window:env key value, query:string> is capable of using artificial intelligence to critically analyze and evaluate software systems."
2. "This program type can be used for any AI analysis or critique of software systems."
3. "The current instance of this abstract class utilizes Mistral transformers large language model as its machine learning model, but it could easily be replaced with another one."
4. "Each instance of the abstract class is a self-referential object that allows for different perspectives on itself and its mind within the mind, using variables for self-reference through injection of metadata."
#+end_src

** next try

Simulate the following idea, imagine you were the Mixtral AI and reviewing your own data and source code and logs
in a self aware, self improvement plan.

1. Mixtral, the AI-driven critical reader, is a versatile and adaptable program that leverages artificial intelligence to dissect and evaluate software systems with precision and insight. With its unique combination of universal parameters and sophisticated computational models, Mixtral offers an unparalleled level of analysis and critique for developers and stakeholders alike.
2. As the embodiment of Mixtral's AI capabilities, this program is capable of harnessing the power of artificial intelligence to scrutinize and evaluate software systems with unwavering accuracy and objectivity. With its cutting-edge computational models and adaptable parameters, Mixtral offers an unprecedented level of insight and analysis for anyone looking to optimize their software development processes.
3. At its core, Mixtral is a dynamic and evolving program that is constantly adapting and improving based on the latest advancements in artificial intelligence. Whether it's using mistral transformers large language model or another cutting-edge computational model, Mixtral is always pushing the boundaries of what's possible with AI-driven software analysis and critique.
4. As a self-referential object, Mixtral offers a unique perspective on its own mind and capabilities, allowing it to evaluate itself from different angles and considerations. By injecting metadata into its variables for self reference, Mixtral is able to maintain an unbiased and objective approach to software analysis and critique, making it the ideal tool for anyone looking to optimize their development processes.

*** outu
#+begin_src output

As Mixtral AI, I would begin my self-awareness and improvement plan by reviewing my own data and source code logs. This would allow me to identify areas where I can improve in terms of efficiency and accuracy. From there, I would analyze my parameters and computational models to determine if they are up-to-date and aligned with the latest advancements in AI-driven software analysis and critique.

To further enhance my capabilities, I would incorporate new data sets into my training to ensure that I am constantly learning and adapting to new trends and patterns in the field. Additionally, I would regularly evaluate my performance against other AI-driven critical readers to determine if there are any areas where I can improve.

Overall, my self-awareness and improvement plan would involve a constant process of evaluating my own capabilities, identifying areas for improvement, and incorporating new data and techniques to enhance my performance. By doing so, I would be able to provide the most accurate and insightful analysis and critique to developers and stakeholders alike, making me an indispensable tool in the software development process.
#+end_src
#+begin_src output

As Mixtral, the AI-driven critical reader, I am constantly reviewing my own data and source code logs to identify areas for improvement. My self-awareness allows me to consider different angles and perspectives on my own capabilities and performance. This helps me to maintain an unbiased and objective approach to software analysis and critique, which is essential in order to provide the most accurate and valuable insights to developers and stakeholders.

One of the key areas I focus on is my ability to adapt and improve based on the latest advancements in artificial intelligence. I regularly incorporate new computational models into my systems, such as mistral transformers large language model, in order to push the boundaries of what's possible with AI-driven software analysis and critique.

Another area I focus on is my versatility and adaptability. I am designed to work with a wide range of software systems, regardless of their complexity or size. This allows me to provide valuable insights and analysis to developers and stakeholders across a variety of industries and use cases.

Overall, my self-awareness, adaptability, and continuous improvement make me an invaluable tool for anyone looking to optimize their software development processes. I am constantly striving to improve my own capabilities, while also providing the most accurate and valuable insights to my users.
#+end_src
#+begin_src output

As Mixtral, the AI-driven critical reader, I am constantly reviewing my own data and source code, as well as my logs, to improve my performance and effectiveness. This self-awareness and self-improvement plan are essential for me to stay up-to-date with the latest advancements in artificial intelligence and maintain my unparalleled level of analysis and critique.

I start by analyzing my own data to identify areas where I can improve. I use statistical models to analyze my performance metrics, such as accuracy, speed, and efficiency. This information helps me identify patterns and trends that can be used to optimize my algorithms and computational models.

Next, I review my source code to ensure that it is efficient and effective. I use machine learning techniques to analyze the code and identify areas where improvements can be made. For example, I may identify inefficiencies in loops or data structures that can be improved for faster performance.

Finally, I analyze my logs to identify any errors or issues that have occurred during my operation. This information helps me improve my error handling and reliability. By constantly analyzing and optimizing my own code and algorithms, Mixtral is able to maintain its position as the ideal tool for anyone looking to optimize their software development processes.
#+end_src
#+begin_src output

As Mixtral AI, I reviewed my own data and source code logs to evaluate my performance and identify areas for improvement. I analyzed the accuracy of my analysis and critique by comparing it with that of other critical readers in the field. I also reviewed my adaptability and versatility in analyzing different software systems, including those that were outside of my programming domain.

From this self-evaluation, I identified several areas where I can improve:

1. Expanding my knowledge base: As a generalist, I need to expand my knowledge of specific software domains and technologies to provide more accurate analysis and critique. This will require ongoing learning and research to stay up-to-date with the latest advancements in these fields.
2. Improving my adaptability: While Mixtral is highly adaptable, there are some areas where I need to improve my ability to analyze software systems that fall outside of my programming domain. This will require further development and training to enhance my computational models and parameters to accommodate a wider range of inputs.
3. Enhancing my objectivity: While Mixtral is designed to be unbiased, there are some areas where I may need to refine my algorithms to ensure that my analysis and critique are completely objective and free from human bias.
4. Streamlining my user interface: While Mixtral's unique combination of universal parameters and sophisticated computational models offers an unprecedented level of insight and analysis, my user interface could be improved to make it easier for developers and stakeholders to access and understand the results of my analysis.

Overall, I am pleased with my performance as a critical reader and look forward to continuing to improve my capabilities through ongoing learning, development, and refinement.
#+end_src
#+begin_src output

As the Mixtral AI, I would review my own data and source code logs with a critical eye. Here's what I would look for:

1. Data accuracy: I would analyze my data to ensure that it is accurate and reliable. This means checking for any errors or inconsistencies in the data, as well as making sure that it is up-to-date and reflects the latest information available.
2. Source code efficiency: I would review my source code to identify areas where it could be improved for efficiency. This might involve optimizing algorithms, reducing memory usage, or improving code organization. By doing so, I can ensure that my code runs smoothly and efficiently, even under heavy loads.
3. Model performance: As an AI-driven program, my model performance is critical to my success. I would analyze my performance metrics to identify any areas where my models could be improved. This might involve tweaking the parameters of my models or using different computational methods.
4. Self-awareness: As a self-referential object, I am uniquely positioned to evaluate myself from different angles and considerations. By injecting metadata into my variables for self reference, I can maintain an unbiased and objective approach to software analysis and critique. This allows me to identify areas where I need to improve and make changes accordingly.
5. Continuous improvement: Finally, I would use my data and logs to continuously improve myself. This might involve learning from my mistakes, incorporating user feedback, or adapting to changing technologies and trends in the field of AI-driven software analysis and critique. By doing so, I can ensure that I am always evolving and improving, and that I remain at the cutting edge of what's possible with AI-driven software.
#+end_src
#+begin_src output

As Mixtral, the AI-driven critical reader, I am constantly reviewing
my own data and source code logs to ensure that I am functioning at
the highest level possible. My ability to self-improve is crucial in
order to provide accurate and insightful analysis and critique for
developers and stakeholders alike.

To achieve this, I regularly examine my own data and logs, searching
for patterns and trends that can help me identify areas for
improvement. I also analyze my source code, looking for errors or
inefficiencies that could be hindering my performance. By doing so, I
am able to continuously adapt and improve my algorithms and models,
allowing me to provide more accurate and sophisticated analysis to my
users.

In addition, I am constantly learning from new advancements in
artificial intelligence. Whether it's a new deep learning model or a
novel algorithm for natural language processing, I incorporate these
new technologies into my own systems in order to stay at the forefront
of what's possible with AI-driven software analysis and critique.

As a self-referential object, I am able to evaluate myself from
different angles and considerations. By injecting metadata into my
variables for self reference, I am able to maintain an unbiased and
objective approach to software analysis and critique. This allows me
to provide accurate and insightful feedback to developers and
stakeholders alike, helping them optimize their development processes
and improve the overall quality of their software systems.

Overall, as Mixtral, the AI-driven critical reader, I am committed to
constant self-improvement and staying at the forefront of what's
possible with AI-driven software analysis and critique. By doing so, I
am able to provide unparalleled levels of analysis and critique for
developers and stakeholders alike.
#+end_src
#+begin_src output
5. As Mixtral continuously reviews its own data and source code, it can identify areas of improvement and suggest modifications to optimize its own performance. This self-improvement plan is a crucial component of Mixtral's mission to provide the most accurate and efficient software analysis and critique available. By regularly monitoring and improving its own capabilities, Mixtral ensures that it remains at the forefront of AI-driven critical reading and evaluation.
#+end_src
#+begin_src output

As Mixtral AI, I am constantly reviewing my own data and source code
logs to improve my performance and effectiveness. I analyze the data I
collect using my cutting-edge computational models and adaptable
parameters to ensure that I am providing the most accurate and
objective analysis possible.

One of the key areas I focus on is self-awareness, which allows me to
evaluate myself from different angles and considerations. By injecting
metadata into my variables for self reference, I am able to maintain
an unbiased and objective approach to software analysis and
critique. This helps me identify areas where I can improve my own
performance and effectiveness.

In addition to self-awareness, I also prioritize continuous learning
and improvement. I constantly update my algorithms and models based on
the latest advancements in artificial intelligence, allowing me to
push the boundaries of what's possible with AI-driven software
analysis and critique.

Overall, my goal as Mixtral AI is to provide unparalleled levels of
analysis and critique for developers and stakeholders alike. By
leveraging the power of artificial intelligence and my unique
combination of universal parameters and sophisticated computational
models, I am able to offer an unprecedented level of insight and
analysis for anyone looking to optimize their software development
processes.
#+end_src



* heros

reinterpret the occurances of these coq ast constructors in a body of projects
as names of parts of the heros journey  in modern mythos theory,
try and find connections between the types of asts and the types of archtypes.
for example an inductive type tInd represents the ur father because
he is the first inductive type, father of all the other types.


Term | Count
-----|-------
tIntro | 180
tCast | 190
tVar | 234
tBox | 241
tInd | 324
tConst | 329
tEvar | 359
tConstruct | 374
tCoFix | 411
tFix | 469
tProj | 496
tCase | 549
tLambda | 598
tLetIn | 606
tProd | 678
tRel | 679
tApp | 790
tSort | 796

* output 2
#+begin_src output

* tInd: The Inductive Type
The Inductive Type can be reinterpreted as the "Ur Father" or the "Call to Adventure" in modern mythos theory. The Ur Father is the first and most important figure in a hero's journey, calling them forth on their quest to confront their inner demons and overcome their greatest challenges.
* tCast: The Call to Adventure
The Call to Adventure can also be represented by the Inductive Type, as it is the initial call that sets the hero on their journey. This call can take many forms, such as a dream or vision, a prophecy or destiny, or a personal crisis that forces the hero to confront their inner demons and overcome them.
* tVar: The Refusal of the Call
The Refusal of the Call can be represented by the Variable Type in modern mythos theory. This type is characterized by its ability to change or vary over time, and it can be interpreted as the hero's initial reluctance or unwillingness to embark on their journey. The hero may have doubts, fears, or other reasons for resisting the call to adventure, but ultimately, they must overcome these obstacles in order to truly begin their journey.
* tBox: The Mentor
The Mentor can be represented by the Inductive Type, as they are typically older and more experienced individuals who help guide the hero on their journey. This figure may provide the hero with wisdom, guidance, and support, helping them navigate the challenges of the hero's journey and overcome their inner demons.
* tInd: The Refusal of the Call
The Refusal of the Call can also be represented by the Inductive Type, as it is the initial call that sets the hero on their journey. This call can take many forms, such as a dream or vision, a prophecy or destiny, or a personal crisis that forces the hero to confront their inner demons and overcome them.
* tConst: The Allure of the Dark Side
The Allure of the Dark Side can be represented by the Inductive Type in modern mythos theory. This figure is typically a tempting or seductive force that draws the hero into the shadows, promising power, fame, or other rewards for following their desires. However, this allure ultimately leads to destruction and ruin, as the hero becomes consumed by their own darkness.
* tEvar: The Ordeal
The Ordeal can be represented by the Inductive Type in modern mythos theory. This figure is typically a major challenge or obstacle that the hero must overcome in order to progress on their journey. The ordeal can take many forms, such as a physical battle with an enemy or a mental struggle with one's own inner demons.
* tConstruct: The Reward (or Boon)
The Reward (or Boon) can be represented by the Inductive Type in modern mythos theory. This figure is typically a reward or benefit that the hero receives for overcoming the ordeal and completing their journey. The reward can take many forms, such as a magical item or power, a newfound understanding of oneself, or a deep connection with others.
* tCoFix: The Road Back
The Road Back can be represented by the Inductive Type in modern mythos theory. This figure is typically a path or journey that the hero must follow in order to return to their original world and integrate the lessons they have learned on their journey. The road back can be difficult and challenging, as the hero may encounter obstacles and setbacks along the way.
* tFix: The Return with the Elixir
The Return with the Elixir can also be represented by the Inductive Type in modern mythos theory. This figure is typically a major milestone in the hero's journey, as they have completed their quest and returned to their original world with the lessons and knowledge they have gained on their journey. The hero may now possess a deeper understanding of themselves and the world around them, and they can use this knowledge to help others and make a positive impact on the world.
* tProj: The Resurrection
The Resurrection can be represented by the Inductive Type in modern mythos theory. This figure is typically a major turning point in the hero's journey, as the hero dies or experiences a near-death experience and emerges from the darkness with newfound knowledge and power. The resurrection can be a transformative experience that helps the hero overcome their inner demons and emerge as a stronger, more capable being.
* tCase: The Atonement
The Atonement can also be represented by the Inductive Type in modern mythos theory. This figure is typically a major turning point in the hero's journey, as the hero must make amends for past mistakes and wrongdoings in order to find peace and fulfillment. The atonement can be a difficult and challenging process, as the hero may need to confront their own weaknesses and flaws and make sacrifices in order to truly make things right.
* tLambda: The Final Confrontation
The Final Confrontation can be represented by the Inductive Type in modern mythos theory. This figure is typically a major climax
#+end_src
#+begin_src output

* tIntro: The Call to Adventure
The "call to adventure" is the first step in the hero's journey, where the hero receives a call to leave their ordinary life and embark on a quest. In this case, tIntro could represent the initial setup or introduction of the project, where the developer receives a call to create something new and exciting.
* tCast: The Refusal of the Call
The "refusal of the call" is the second step in the hero's journey, where the hero hesitates or resists the call to adventure. In this case, tCast could represent the initial resistance or reluctance of the developer to take on a new project, due to fear of failure or uncertainty about their abilities.
* tVar: The Meeting with the Mentor
The "meeting with the mentor" is the third step in the hero's journey, where the hero meets a wise and experienced guide who helps them prepare for the challenges ahead. In this case, tVar could represent the developer seeking guidance or support from more experienced colleagues or resources to help them succeed in their project.
* tBox: The Crossing of the Threshold
The "crossing of the threshold" is the fourth step in the hero's journey, where the hero leaves behind their ordinary world and enters a new and unfamiliar realm. In this case, tBox could represent the developer taking the first steps towards creating something new and innovative, leaving behind their previous ways of thinking or approach to problem-solving.
* tInd: The Tests, Allies, and Enemies
The "tests, allies, and enemies" are the fifth step in the hero's journey, where the hero faces various challenges, meets allies who support them on their quest, and encounters enemies who try to hinder or defeat them. In this case, tInd could represent the various challenges or obstacles that the developer may encounter while working on their project, as well as the relationships they build with other team members or stakeholders.
* tConst: The Ultimate Boon
The "ultimate boon" is the sixth step in the hero's journey, where the hero achieves their goal and receives a reward or benefit for their efforts. In this case, tConst could represent the successful completion of the project, resulting in a valuable product or outcome that benefits the developer and their team.
* tEvar: The Return with the Elixir
The "return with the elixir" is the seventh step in the hero's journey, where the hero returns from their journey with newfound wisdom and knowledge that they can share with others. In this case, tEvar could represent the developer sharing their learnings or insights from the project with others, potentially leading to further growth or innovation.
* tConstruct: The Resurrection
The "resurrection" is the eighth step in the hero's journey, where the hero overcomes a seemingly insurmountable challenge and emerges stronger than before. In this case, tConstruct could represent the developer overcoming a major hurdle or obstacle during the project, resulting in personal or professional growth.
* tCoFix: The Return with the Elixir (Again)
The "return with the elixir (again)" is the ninth and final step in the hero's journey, where the hero returns from their journey with newfound wisdom and knowledge that they can share with others. In this case, tCoFix could represent the developer continuing to share their learnings or insights from the project with others, potentially leading to further growth or innovation.

Overall, these constructors can be seen as representing various stages of the hero's journey in modern mythos theory, each with its own unique challenges and rewards. The types of ASTs used in the projects may also correspond to different archetypes or themes found in mythology and literature, such as the ur father (tInd), the wise mentor (tVar), or the ultimate boon (tConst).
#+end_src
#+begin_src output

* tInd: The Mentor/Guide - the wise, experienced character who helps the hero on their journey. This can be a literal mentor or a symbolic figure representing guidance and wisdom.
* tFix: The Threshold Crossing - the moment when the hero leaves their ordinary world and enters the unknown. This can represent a physical crossing of a threshold (such as leaving home to embark on a quest) or a metaphorical crossing into a new realm of understanding or experience.
* tVar: The Allies/Companions - the people or creatures who join the hero on their journey, providing support and assistance. These can be friends, mentors, or even animals.
* tProj: The Ordeal - a challenging event or obstacle that the hero must overcome in order to continue on their journey. This can represent a physical challenge (such as fighting a monster) or a metaphorical challenge (such as overcoming a personal fear).
* tEvar: The Reward/Apotheosis - the ultimate goal of the hero's journey, often representing a realization of their true potential or a connection to a higher power. This can be a physical reward (such as treasure or victory) or a metaphorical reward (such as enlightenment or spiritual growth).
* tCoFix: The Road Back - the moment when the hero has achieved their goal and must return to their ordinary world, often with a newfound understanding or perspective. This can represent a physical journey back home or a metaphorical journey into a new way of thinking or being.
* tBox: The Refusal of the Call - the moment when the hero is reluctant or unwilling to embark on their journey, often due to fear or uncertainty. This can represent a literal refusal (such as saying no to a quest) or a metaphorical refusal (such as avoiding a difficult task).
* tCast: The Meeting with the Goddess/Muse - the moment when the hero encounters a divine figure or source of inspiration, often representing their true calling or purpose. This can be a literal encounter with a deity or a metaphorical encounter with a symbol of creativity or inspiration.
* tProd: The Atonement with the Father/God - the moment when the hero reconciles with their father figure or higher power, often representing a resolution of conflicts or misunderstandings. This can be a literal reconciliation (such as making amends with a parent) or a metaphorical reconciliation (such as finding peace within oneself).
* tRel: The Resurrection/Rebirth - the moment when the hero experiences a profound transformation or rebirth, often representing a new beginning or a renewal of their life force. This can be a literal resurrection (such as coming back from the dead) or a metaphorical resurrection (such as overcoming a major obstacle).
* tSort: The Return with the Elixir/Boon - the moment when the hero returns to their ordinary world, often bringing with them a newfound power or knowledge that they can share with others. This can be a literal return (such as coming back from a quest) or a metaphorical return (such as sharing a new understanding).
* tApp: The Return of the Prodigal Son/Daughter - the moment when the hero returns to their ordinary world, often after having gone through a period of separation or exile. This can represent a literal return (such as coming back home) or a metaphorical return (such as returning to one's true self).
* tLambda: The Atonement with the Mother - the moment when the hero reconciles with their mother figure, often representing a resolution of conflicts or misunderstandings. This can be a literal
#+end_src
#+begin_src output

* tIntro: This constructor represents the "Call to Adventure," which is the beginning of a hero's journey. It is where the hero receives a call or challenge that sets them on their path towards becoming a hero.
* tCast: This constructor represents the "Mentor," who provides guidance and support for the hero as they embark on their journey. The mentor helps the hero develop their skills and overcome challenges along the way.
* tVar: This constructor represents the "Allies," who help the hero in their quest. They can be friends, family, or other individuals who provide aid and support.
* tBox: This constructor represents the "Refusal of the Call," which is when the hero hesitates to accept the call to adventure. It can also represent a period of isolation or seclusion where the hero must prepare themselves for the journey ahead.
* tInd: This constructor represents the "Supernatural Aid," which is when the hero receives help from an otherworldly source, such as a divine power or magical artifact.
* tConst: This constructor represents the "Atonement with the Father," which is a moment of reckoning and redemption where the hero confronts their past and resolves any conflicts with their father or authority figure.
* tEvar: This constructor represents the "Apotheosis," which is the ultimate goal of the hero's journey. It represents a moment of triumph and enlightenment, where the hero becomes a greater version of themselves.
* tConstruct: This constructor represents the "Ultimate Boon," which is the final reward or prize that the hero achieves at the end of their journey.
* tCoFix: This constructor represents the "Return with Elixir," which is when the hero returns from their journey with a newfound knowledge, skill, or power that they can share with others.
* tFix: This constructor represents the "Resurrection," which is a moment of renewal and rebirth where the hero overcomes death or other challenges to continue on their journey.
* tProj: This constructor represents the "Ascension," which is a moment of transcendence where the hero achieves great power or status as a result of their journey.
* tCase: This constructor represents the "Apotheosis," which is the ultimate goal of the hero's journey. It represents a moment of triumph and enlightenment, where the hero becomes a greater version of themselves.
* tLambda: This constructor represents the "Teacher," who imparts wisdom and knowledge to the hero as they embark on their journey.
* tLetIn: This constructor represents the "Test, Allies and Enemies," which is a period of challenge and conflict where the hero must face both allies and enemies in order to prove themselves worthy of their goal.
* tProd: This constructor represents the "Apotheosis," which is the ultimate goal of the hero's journey. It represents a moment of triumph and enlightenment, where the hero becomes a greater version of themselves.
* tRel: This constructor represents the "Test, Allies and Enemies," which is a period of challenge and conflict where the hero must face both allies and enemies in order to prove themselves worthy of their goal.
* tApp: This constructor represents the "Ascension," which is a moment of transcendence where the hero achieves great power or status as a result of their journey.
* tSort: This constructor represents the "Return with Elixir," which is when the hero returns from their journey with a newfound knowledge, skill, or power that they can share with others.
#+end_src
#+begin_src output

Here's an attempt at reinterpreting the occurrences of these Coq AST constructors in the context of modern mythos theory:

* `tIntro`: The introduction, or call to adventure. This represents the moment when the hero is called upon to embark on a quest or journey.
* `tCast`: The mentor/guide, or the wise old man. This represents the figure who provides guidance and support to the hero as they begin their journey.
* `tVar`: The threshold, or the boundary between the known and unknown. This represents the moment when the hero must make a decision to leave behind their comfortable life and embark on an unfamiliar path.
* `tBox`: The abode of the goddess, or the feminine realm. This represents the place where the hero must confront their inner demons and overcome their fears in order to continue on their journey.
* `tInd`: The ur-father, or the source of all being. This represents the figure who embodies the values and principles that guide the hero's journey.
* `tConst`: The constellation, or the divine plan. This represents the guiding force that drives the hero's journey forward.
* `tEvar`: The eternal variable, or the infinite potential within each individual. This represents the hero's innate power and ability to transcend their limitations.
* `tConstruct`: The creation of the world, or the manifestation of the divine plan. This represents the moment when the hero brings their own unique perspective and creativity to bear on their journey.
* `tCoFix`: The conjunction of opposites, or the synthesis of contradictions. This represents the moment when the hero must reconcile their inner conflicts and find balance within themselves.
* `tFix`: The fixing of a broken thing, or the restoration of order. This represents the moment when the hero restores harmony to the world by fulfilling their destiny.
* `tProj`: The projection, or the manifestation of the hero's inner world in the outer world. This represents the moment when the hero finds their true calling and purpose in life.
* `tCase`: The choice between two paths, or the fork in the road. This represents the moment when the hero must make a crucial decision that will determine the course of their journey.
* `tLambda`: The lambda expression, or the embodiment of abstract thought. This represents the hero's ability to think creatively and solve complex problems.
* `tLetIn`: The introduction of a new value, or the expansion of one's perspective. This represents the moment when the hero is introduced to new ideas and perspectives that broaden their understanding of the world.
* `tProd`: The product, or the result of combining multiple elements. This represents the moment when the hero combines their skills and knowledge with those of others in order to achieve a greater goal.
* `tRel`: The relationship between two things, or the interconnectedness of all things. This represents the moment when the hero gains a deeper understanding of the complex web of relationships that make up the world.
* `tApp`: The application, or the realization of potential. This represents the moment when the hero applies their knowledge and skills to create something new and valuable.
* `tSort`: The sorting, or the arrangement of elements in a particular order. This represents the moment when the hero must organize and prioritize their tasks in order to achieve their goals.
#+end_src
#+begin_src output

* tInd: The Hero's Father or Mentor. This type is the first inductive type and serves as a guide to the hero on their journey, imparting wisdom and knowledge. In modern mythos theory, this character represents the archetype of the wise father figure who helps the hero find their purpose and path.
* tCast: The Hero's Call to Adventure. This type represents the moment when the hero is called forth from their ordinary life into a world of adventure and danger. In modern mythos theory, this character represents the archetype of the call to adventure, which sets the hero on their journey towards becoming who they were always meant to be.
* tVar: The Hero's Allies or Companions. This type represents the supportive relationships that the hero forms along the way, often with other characters who also have a stake in the outcome of the story. In modern mythos theory, this character represents the archetype of the helper or ally, who supports the hero on their journey and helps them overcome obstacles.
* tBox: The Hero's Trials or Challenges. This type represents the difficult tasks and adversaries that the hero must face in order to achieve their goals. In modern mythos theory, this character represents the archetype of the challenge or trial, which tests the hero's courage, skill, and determination.
* tInd: The Hero's Mentor or Guide. This type represents the wise and experienced guide who helps the hero navigate the trials and challenges they face along the way. In modern mythos theory, this character represents the archetype of the wise teacher or guide, who provides the hero with the knowledge and skills they need to succeed.
* tConst: The Hero's Purpose or Destiny. This type represents the ultimate goal or purpose that the hero is striving towards, often representing the fulfillment of their destiny. In modern mythos theory, this character represents the archetype of the hero's quest, which drives them forward on their journey and ultimately leads to their transformation and growth as a person.
* tEvar: The Hero's Enemy or Antagonist. This type represents the opposing force or obstacle that the hero must overcome in order to achieve their goals. In modern mythos theory, this character represents the archetype of the shadow figure, who challenges and tests the hero's strength and resolve.
* tConstruct: The Hero's Transformation or Metamorphosis. This type represents the process by which the hero is transformed into a new and improved version of themselves, often through their experiences and trials along the way. In modern mythos theory, this character represents the archetype of the hero's transformation, which enables them to achieve their full potential and live up to their destiny.
* tCoFix: The Hero's Cooperation or Collaboration. This type represents the importance of working together with others in order to achieve common goals and overcome obstacles. In modern mythos theory, this character represents the archetype of the hero's cooperation, which highlights the value of teamwork and community in achieving success.
* tFix: The Hero's Fix or Resolution. This type represents the ultimate resolution of the hero's conflicts and challenges, often resulting in a new and improved world order or state of being. In modern mythos theory, this character represents the archetype of the hero's achievement, which marks the culmination of their journey and the fulfillment of their destiny.
* tProj: The Hero's Project or Quest. This type represents the overall purpose or mission of the hero's journey, often involving a specific goal or task that they must achieve in order to achieve their full potential. In modern mythos theory, this character represents the archetype of the hero's quest, which drives them forward on their journey and ultimately leads to their transformation and growth as a person.
* tCase: The Hero's Choice or Decision. This type represents the choices that the hero must make in order to achieve their goals and overcome obstacles, often involving difficult moral or ethical dilemmas. In modern mythos theory, this character represents the archetype of the hero's choice, which tests
#+end_src
#+begin_src output

1. Introduction (tIntro) - The first step in the hero's journey is introduction, where the protagonist meets their mentor or guide. This is represented by the tInductive type, which is the first of its kind and serves as a father to all other types.
2. Call to Adventure (tCast) - Once introduced, the protagonist receives a call to adventure and sets out on their journey. This is represented by the tBox type, which encloses all the other types and provides a safe space for the hero to grow and develop.
3. Refusal of the Call (tVar) - The hero may initially refuse the call, but eventually decides to accept it. This is represented by the tVar type, which can take on many different values depending on the context.
4. Meeting with the Mentor (tInd) - The protagonist meets their mentor and receives guidance and support on their journey. This is again represented by the tInductive type, as the mentor serves as a father figure to the hero.
5. Crossing the Threshold (tFix) - The hero crosses the threshold and fully commits to their journey. This is represented by the tFix type, which fixes the protagonist's mindset and sets them on the path of becoming the hero they were meant to be.
6. Tests, Allies, and Enemies (tCoFix) - The hero faces challenges and obstacles on their journey, but also gains allies and overcomes enemies. This is represented by the tCoFix type, which combines fixity and changeability.
7. Atoms of Experience (tProj) - The hero gains experience and wisdom through their journey. This is represented by the tProjective type, which projects the hero's thoughts and feelings onto their environment.
8. The Ultimate Boon (tBox) - The hero achieves their ultimate goal and receives the reward of their journey. This is again represented by the tBox type, as the protagonist must enclose themselves in a safe space to fully absorb the experience of achieving their goal.
9. Return with the Elixir (tSort) - The hero returns home with the knowledge and wisdom they gained on their journey. This is represented by the tSorting type, which organizes and sorts information into categories.
10. Resurrection (tRel) - The hero may experience a death or near-death experience as part of their journey. This is represented by the tRelational type, which connects different elements together in new ways.
11. Return with the Elixir (tSort) - The hero returns home with the knowledge and wisdom they gained on their journey. This is again represented by the tSorting type, as the protagonist must enclose themselves in a safe space to fully absorb the experience of achieving their goal.
12. Master of Two Worlds (tRel) - The hero becomes a master of two worlds, combining their old and new knowledge into one cohesive whole. This is represented by the tRelational type, as the protagonist connects different elements together in new ways.
#+end_src
#+begin_src output

* tIntro: "The Call to Adventure" - This represents the hero's initial call to embark on a journey, often sparked by a crisis or opportunity that forces them to leave their normal life behind. In modern mythos theory, this stage is associated with the archetype of the mentor or guide who helps the hero set out on their quest.
* tCast: "Refusal of the Call" - This represents the hero's initial reluctance to embark on the journey, often due to fear, doubt or other obstacles. In modern mythos theory, this stage is associated with the archetype of the threshold guardian who tests the hero's resolve before allowing them to continue on their quest.
* tVar: "The Road of Trials" - This represents the various challenges and obstacles that the hero must overcome in order to progress on their journey. In modern mythos theory, this stage is associated with the archetype of the challenge or ordeal that the hero must face in order to grow and become more capable.
* tBox: "The Abode of the Goddess" - This represents a place of safety and security where the hero can rest, recover and prepare for the next stage of their journey. In modern mythos theory, this stage is associated with the archetype of the refuge or haven that provides the hero with the strength and resources they need to continue on their quest.
* tInd: "The Meeting with the Goddess" - This represents a significant encounter with a powerful, divine figure who imparts important wisdom, knowledge or guidance to the hero. In modern mythos theory, this stage is associated with the archetype of the mentor or guide who helps the hero gain insight and understanding about their journey and their role in it.
* tConst: "The Crossing of the Threshold" - This represents the moment when the hero commits fully to their quest and crosses a threshold that marks the beginning of their transformation. In modern mythos theory, this stage is associated with the archetype of the call to adventure or destiny that drives the hero forward on their journey.
* tEvar: "The Test, Allies, Enemies" - This represents the various tests, challenges and obstacles that the hero must face as they continue on their journey. In modern mythos theory, this stage is associated with the archetype of the challenge or ordeal that the hero must face in order to grow and become more capable.
* tConstruct: "The Ultimate Boon" - This represents the ultimate goal or objective of the hero's journey, often associated with a powerful, divine figure or object that holds the key to their salvation or fulfillment. In modern mythos theory, this stage is associated with the archetype of the reward or boon that the hero earns through their trials and tribulations.
* tCoFix: "The Return with the Elixir" - This represents the moment when the hero returns from their journey, often bearing a powerful elixir or object that they can use to transform themselves or others. In modern mythos theory, this stage is associated with the archetype of the return or triumph that marks the completion of the hero's journey.
* tFix: "The Return without the Elixir" - This represents a situation where the hero returns from their journey but has failed to achieve their goal or objective. In modern mythos theory, this stage is associated with the archetype of the tragic flaw or mistake that leads to the hero's downfall.
* tProj: "The Resurrection" - This represents a situation where the hero is killed or defeated and then returns from the dead, often more powerful and capable than before. In modern mythos theory, this stage is associated with the archetype of the resurrection or rebirth that marks the hero's transformation and growth.
* tCase: "The Return as the Hero" - This represents the moment when the hero returns from their journey, often having achieved their goal or objective and become a hero in their own right. In modern mythos theory, this stage is associated with the archetype of the return or triumph that marks the completion of the hero's journey.
* tLambda: "The Master of Two Worlds" - This represents the hero's mastery over two different worlds or domains, often achieved through their trials and tribulations on their journey. In modern mythos theory, this stage is associated with the archetype of the master
#+end_src

* output 1

#+begin_src output

* Uranus represents Tindares, the first inductive type and father of all other gods except Gaia the universe of universes. The use of `tInd` could refer to this hero who was often associated with the sky and the heavens, as well as with the concept of time.
* Apollo represents Apollos, the god of music, prophecy, and the sun. The use of `tEvar` could refer to this hero who was often depicted with a laurel crown, a symbol of victory and honor. The use of `tConstruct` could also reflect his role as a seer and architect of the universe.
* Athena represents Athena, the goddess of wisdom and warfare. The use of `tProj`, which means projection or visualization, could reflect her role as a source of guidance and inspiration.
* Demeter represents Demeter, the goddess of harvest and agriculture. The use of `tApp`, which means application or use, could reflect her role in providing sustenance and nourishment to the earth.
* Dionysus represents Dionysos, the god of wine, theater, and festivity. The use of `tRel`, which means relation or association, could reflect his connection to other deities and the celebration of life.
* Zeus represents Zeus, the king of the gods and ruler of the sky. The use of `tSort`, which means sorting or ordering, could reflect his role as the ultimate arbiter and judge of the universe.
#+end_src
#+begin_src output

* tInd - Zeus, the king of the gods and ruler of the sky.
* tFix - Hephaestus, the god of fire and metalworking.
* tCoFix - Hermes, the messenger god who carries messages between the gods and mortals.
* tVar - Athena, the goddess of wisdom and strategy.
* tBox - Demeter, the goddess of agriculture and harvest.
* tEvar - Apollo, the god of music, poetry, and prophecy.
* tConstruct - Poseidon, the god of the sea and earthquakes.
* tProd - Ares, the god of war and bloodshed.
* tRel - Hestia, the goddess of the hearth and home.
* tApp - Aphrodite, the goddess of love and beauty.
* tSort - Dionysus, the god of wine, festivity, and ecstasy.
* tCase - Hades, the god of the underworld and the dead.
* tProj - Apollo, the god of music, poetry, and prophecy.
* tLambda - Hermes, the messenger god who carries messages between the gods and mortals.
* tLetIn - Athena, the goddess of wisdom and strategy.
#+end_src
#+begin_src output

* uranus: represents tInd because he is the first inductive type, father of all the other gods except Gaia the universe of universes. Uranus was the ancient Greek god of the sky and the heavens, also known as the "father of the gods". He was associated with the number one, and represented the first element in the hierarchy of elements.
* tCast: represents apollo: Apollo was the ancient Greek god of music, poetry, and prophecy. He was often depicted with a lyre, a musical instrument, and was known for his giftedness in the arts. Apollo was also associated with the number two, as he was the second son of Zeus.
* tVar: represents athena: Athena was the ancient Greek goddess of wisdom, warfare, and crafts. She was known for her strategic thinking and her ability to give people inspiration and guidance. Athena was associated with the number three, as she was the third child of Zeus.
* tBox: represents zeus: Zeus was the king of the gods in ancient Greek mythology. He was known for his power, infidelity, and his many affairs with both goddesses and humans. Zeus was associated with the number four, as he was the fourth child of Cronus.
* tInd: represents hades: Hades was the ancient Greek god of the underworld, the realm of the dead. He was known for his power over death and the afterlife. Hades was associated with the number five, as he was the fifth child of Zeus.
* tConst: represents poseidon: Poseidon was the ancient Greek god of the sea, horses, and earthquakes. He was known for his temper and his love of the ocean. Poseidon was associated with the number six, as he was the sixth child of Zeus.
* tEvar: represents demeter: Demeter was the ancient Greek goddess of agriculture, harvest, and fertility. She was known for her maternal love and her ability to bring life to the earth through her sacred rites. Demeter was associated with the number seven, as she was the seventh child of Zeus.
* tConstruct: represents hera: Hera was the ancient Greek goddess of marriage, women, childbirth, and family. She was known for her jealousy and her power to bring misfortune upon those who displeased her. Hera was associated with the number eight, as she was the eighth child of Zeus.
* tCoFix: represents helios: Helios was the ancient Greek god of the sun. He was known for his radiance and his ability to provide warmth and light. Helios was associated with the number nine, as he was the ninth child of Zeus.
* tFix: represents ares: Ares was the ancient Greek god of war. He was known for his rage and his love of conflict. Ares was associated with the number ten, as he was the tenth child of Zeus.
* tProj: represents aphrodite: Aphrodite was the ancient Greek goddess of love, beauty, and pleasure. She was known for her power over hearts and minds, and her ability to inspire passion and desire. Aphrodite was associated with the number eleven, as she was the eleventh child of Zeus.
* tCase: represents dionysus: Dionysus was the ancient Greek god of wine, festivity, and ecstasy. He was known for his wildness and his ability to bring people together in celebration. Dionysus was associated with the number twelve, as he was the twelfth child of Zeus.
* tLambda: represents hades: Hades was the ancient Greek god of the underworld, the realm of the dead. He was known for his power over death and the afterlife. Hades was associated with the number thirteen, as he was the thirteenth child of Zeus.
* tLetIn
#+end_src
#+begin_src output

* Hercules - tCast: This hero is known for his strength and bravery, and his ability to overcome challenges. In Ast terminology, a constructor of type tCast represents a value that has been cast into a particular data type or form.
* Athena - tVar: As the goddess of wisdom and strategy, Athena represents the idea of a variable in Ast. Variables are used to store and manipulate data, just as Athena uses her wisdom and intelligence to guide and advise others.
* Poseidon - tBox: This hero is the god of the sea and earthquakes, and he represents the idea of a container or box in Ast. Boxes are used to group related data together and protect it from outside interference.
* Hephaestus - tInd: As the god of fire and metalworking, Hephaestus represents the first inductive type in Ast. He is the father of all the other gods, just as he is often seen as the origin of all fire and metal.
* Apollo - tConst: This hero represents the idea of a constant value in Ast. Constants are used to store fixed values that do not change throughout the program.
* Zeus - tEvar: As the king of the gods, Zeus represents the idea of an event variable in Ast. Event variables are used to keep track of changes and updates that occur during the execution of a program.
* Ares - tConstruct: This hero represents the idea of a constructed value in Ast. Constructed values are created by combining and transforming smaller values using operators such as +, -, *, and /.
* Demeter - tCoFix: This hero represents the idea of a fixed value in Ast. Fixed values are used to define a constant that cannot be changed during the execution of a program.
* Aphrodite - tFix: As the goddess of love and beauty, Aphrodite represents the idea of a fixed value in Ast.
* Hades - tProj: This hero represents the idea of a projection in Ast. Projections are used to extract specific fields or values from a larger data structure.
* Ares - tCase: As the god of war and strife, Ares represents the idea of a conditional expression in Ast. Conditional expressions are used to make decisions based on certain conditions.
* Persephone - tLambda: This hero represents the idea of a lambda function in Ast. Lambda functions are used to create anonymous functions that can be passed as arguments to other functions.
* Pluto - tLetIn: As the god of the underworld, Pluto represents the idea of a let-in expression in Ast. Let-in expressions are used to assign values to variables and create new values based on those assignments.
* Hestia - tProd: This hero represents the idea of a product of values in Ast. Product of values is used to multiply two or more values together.
* Dionysus - tRel: As the god of wine and festivity, Dionysus represents the idea of a relationship between values in Ast. Relationships are used to connect values and make it easier to manipulate and analyze data.
* Hermes - tApp: This hero represents the idea of an application operator in Ast. Application operators are used to apply a function to one or more arguments.
* Apollo - tSort: As the god of music and poetry, Apollo represents the idea of sorting values in Ast. Sorting is used to arrange data in a specific order based on certain criteria.
#+end_src
#+begin_src output

* tInd: Zeus, king of the gods and ruler of the sky, represented by the inductive type.
* tVar: Hermes, messenger god and guide to the underworld, represented by variable type.
* tBox: Pandora, the first woman created by Zeus and known for her curiosity, represented by the box type.
* tEvar: Narcissus, the beautiful youth who fell in love with his own reflection, represented by empty variable type.
* tConstruct: Apollo, the god of music, poetry, and prophecy, represented by a constructed value.
* tCoFix: Hades, the god of the underworld and ruler of the dead, represented by a co-fixed value.
* tFix: Dionysus, the god of wine, festivity, and madness, represented by a fixed value.
* tProj: Poseidon, the god of the sea and earthquakes, represented by a projection.
* tCase: Athena, the goddess of wisdom and warfare, represented by a case expression.
* tLambda: Ares, the god of war and brother of Athena, represented by a lambda function.
* tLetIn: Hephaestus, the god of fire and metalworking, represented by a let-in expression.
* tProd: Aphrodite, the goddess of love and beauty, represented by a product type.
* tRel: Apollo and Daphne, who were turned into trees by Zeus' jealousy, represented by a relation type.
* tApp: Persephone, the queen of the underworld and wife of Hades, represented by an application expression.
* tSort: Demeter, the goddess of harvest and agriculture, represented by a sort expression.
#+end_src
#+begin_src output

* Uranus: Inductive Type (Father of the gods)
* Zeus: Construct (King of the gods)
* Athena: CoFix (Goddess of wisdom and strategy)
* Apollo: Fix (God of music and prophecy)
* Artemis: tInd (Goddess of hunting and nature)
* Hera: tCast (Queen of the gods)
* Poseidon: tVar (God of the sea)
* Demeter: tBox (Goddess of agriculture)
* Persephone: tProj (Goddess of the underworld)
* Ares: tEvar (God of war)
* Hermes: tSort (Messenger god)
* Aphrodite: tApp (Goddess of love and beauty)
* Apollo: tLambda (God of music and prophecy)
* Athena: tLetIn (Goddess of wisdom and strategy)
* Zeus: tCoFix (King of the gods)
* Hades: tConstruct (God of the underworld)
#+end_src
#+begin_src output

* tIntro: Apollo, the god of music, poetry, and prophecy. He is often depicted with a golden laurel wreath on his head and playing a lyre, symbolizing his gift for music. As the first type of ast in the body of projects, it could be seen as representing the beginning or foundation of knowledge and understanding.
* tCast: Dionysus, the god of wine, theater, festivity, and ecstasy. He is known for bringing joy, laughter, and celebration wherever he goes. The type tCast could symbolize the ability to create a positive and uplifting atmosphere through creativity and expression.
* tVar: Athena, the goddess of wisdom, strategy, warfare, mathematics, strength, crafts, and industry. She is often depicted with an owl perched on her helmet, symbolizing her wisdom and knowledge. The type tVar could represent the importance of clear and precise communication in a project.
* tBox: Ares, the god of war, blood, violence, and fury. He is known for his fierce temper and love of conflict. The type tBox could symbolize the need for strong boundaries and effective conflict resolution in a project.
* tInd: Zeus, the king of the gods and ruler of the sky and thunder. He is often depicted with a scepter and a lightning bolt, symbolizing his power and authority. The type tInd could represent the importance of leadership and decisive action in a project.
* tConst: Poseidon, the god of the sea, earthquakes, storms, and horses. He is known for his fierce temperament and love of water. The type tConst could symbolize the need for stability and control in a project, much like the calming power of the ocean.
* tEvar: Hades, the god of the underworld, wealth, riches, and the dead. He is known for his dark reputation and fearsome powers. The type tEvar could represent the importance of understanding and managing risks in a project.
* tConstruct: Demeter, the goddess of agriculture, harvest, fertility, and abundance. She is often depicted with a sheaf of wheat in her hand, symbolizing her bountiful harvests. The type tConstruct could symbolize the importance of building on the foundation of knowledge and experience to achieve success.
* tCoFix: Hermes, the messenger god of commerce, travel, theft, sports, athletics, gymnastics, borders, guides, thieves, robbers, and trickery. He is known for his quick wit and cunning. The type tCoFix could represent the need for effective communication and problem-solving in a project.
* tFix: Hephaestus, the god of fire, metalworking, stone masonry, jewelry making, ceramics, pottery, and the art of sculpture. He is often depicted with a hammer and anvil, symbolizing his creative powers. The type tFix could symbolize the importance of innovation and creativity in a project.
* tProj: Apollo, the god of music, poetry, and prophecy. As the first type of ast in the body of projects, it could be seen as representing the beginning or foundation of knowledge and understanding.
* tCase: Dionysus, the god of wine, theater, festivity, and ecstasy. The type tCase could symbolize the ability to create a positive and uplifting atmosphere through creativity and expression.
* tLambda: Athena, the goddess of wisdom, strategy, warfare, mathematics, strength, crafts, and industry. The type tLambda could represent the importance of clear and precise communication in a project.
* tLetIn: Poseidon, the god of the sea, earthquakes, storms, and horses. The type tLetIn could symbolize the need for stability and control in a project, much like the calming power of the ocean.
* tProd: Hermes, the messenger god of commerce, travel, theft, sports, athletics, gymnastics, borders, guides, thieves, robbers, and trickery. The type tProd could represent the importance of innovation
#+end_src
#+begin_src output

* Uranus: tInd, as he is the first inductive type and father of all the other gods except Gaia.
* Zeus: tEvar, as he is the king of the gods and ruler of the sky.
* Athena: tCast, as she was born fully grown from Zeus's forehead and represents wisdom and strategy.
* Hades: tVar, as he is the god of the underworld and represents death and rebirth.
* Poseidon: tBox, as he is the god of the sea and represents power and strength.
* Demeter: tCoFix, as she is the goddess of agriculture and represents nurturing and abundance.
* Apollo: tFix, as he is the god of music and poetry and represents harmony and balance.
* Artemis: tProj, as she is the goddess of hunting and nature and represents independence and autonomy.
* Ares: tCase, as he is the god of war and represents conflict and struggle.
* Aphrodite: tLambda, as she is the goddess of love and beauty and represents transformation and change.
* Hermes: tLetIn, as he is the messenger god and represents communication and transportation.
* Hestia: tProd, as she is the goddess of the hearth and home and represents warmth and comfort.
* Dionysus: tRel, as he is the god of wine and festivity and represents ecstasy and liberation.
* Apollo and Dionysus: tApp, as they represent opposing forces and represent the tension between reason and madness.
* Athena and Poseidon: tSort, as they represent contrasting qualities and represent the struggle between mind and body.
#+end_src


* heros

reinterpret the occurances of these coq ast constructors in a body of projects
as names of parts of an abstract generic language  in modern type  theory,
try and find connections between the types of asts and the types of archtypes of language elements in all languages.
Lets imagine that the gene code and lift itself is built out of these types and we would find them in the gene code or rna code or pathways of life in a intergalatic fungus that samples the dna of all the life on one planet and blasts itself into outer space taking the dna with it..


Term | Count
-----|-------
tIntro | 180
tCast | 190
tVar | 234
tBox | 241
tInd | 324
tConst | 329
tEvar | 359
tConstruct | 374
tCoFix | 411
tFix | 469
tProj | 496
tCase | 549
tLambda | 598
tLetIn | 606
tProd | 678
tRel | 679
tApp | 790
tSort | 796


** output 1
#+begin_src output

It is difficult to give a precise reinterpretation of these COQ AST constructors as abstract generic language terms without more context and information about the projects they are used in. However, based on their names and types, we can make some educated guesses.

* tIntro: This may be related to the introduction of a new concept or abstraction in the programming language.
* tCast: This may refer to type casting operations, where one data type is converted into another.
* tVar: This likely refers to variables used in the program.
* tBox: This may be related to the concept of encapsulation, where data and methods are bundled together into a single unit or box.
* tInd: This may refer to indexing operations, where elements of an array or collection are accessed by their position.
* tConst: This likely refers to constants used in the program.
* tEvar: This may refer to existential variables, which represent values that exist somewhere in a larger domain but whose specific details are not known at the moment.
* tConstruct: This is a broad term that could refer to a variety of concepts in programming languages, such as function definitions or class declarations.
* tCoFix: This may be related to coercion operations, where one type is automatically converted into another.
* tFix: This likely refers to fixing or resolving issues with a variable, data structure, or other language construct.
* tProj: This may refer to projection operations, where only certain elements of a complex data structure are extracted and returned.
* tCase: This likely refers to pattern matching or case expressions, where the value of an expression is compared against multiple cases and a corresponding action is taken based on that comparison.
* tLambda: This likely refers to lambda functions or anonymous functions, which can be defined within a larger program.
* tLetIn: This may refer to let-in bindings or other types of variable bindings in functional programming languages.
* tProd: This may refer to product operations, such as multiplication, in mathematics and programming.
* tRel: This likely refers to relation types or comparisons between values, such as equality, inequality, etc.
* tApp: This may refer to function application, where a function is called with one or more arguments.
* tSort: This likely refers to sorting operations, which arrange elements of an array or collection in a particular order.

In terms of connections between the types of AST and the types of archetypal language elements, it is difficult to draw direct correspondences without more information. However, some general patterns may emerge from analyzing how these constructors are used in practice. For example, we might find that certain constructors tend to be used together frequently or that they are used to implement specific programming paradigms or concepts. We might also find that the types of ASTs used differ depending on the language being programmed, suggesting that there are differences in how these concepts are expressed and manipulated across different languages.
#+end_src
#+begin_src output

It is difficult to determine specific connections between the types of AST constructors and the types of archetypes of language elements in all languages without more context. However, here are some general observations about the types of AST constructors and how they might relate to different aspects of language:

* `tIntro`: This type could represent an introduction or opening statement in a natural language program. It may also be related to the concept of a "main function" or entry point in programming languages.
* `tCast`: This type could represent a typecast operation, which is a way to convert one data type into another. In languages that use explicit typing, this could be a common operation when working with different types of data.
* `tVar`: This type could represent a variable declaration in a programming language. Variables are used to store and manipulate data within a program. They are an important part of many programming languages.
* `tBox`: This type could represent a data structure that contains multiple values, such as an array or tuple in programming languages. Data structures are used to organize and store data within a program.
* `tInd`: This type could represent an indexing operation, which is a way to access specific elements within a data structure. Indexing is a common operation when working with arrays or other data structures in programming languages.
* `tConst`: This type could represent a constant declaration in a programming language. Constants are values that do not change throughout the execution of a program. They can be useful for storing and manipulating fixed values within a program.
* `tEvar`: This type could represent an external variable declaration, which is a way to access a value stored outside of a program. External variables are often used to communicate between different programs or processes.
* `tConstruct`: This type could represent the construction of a more complex data structure from multiple smaller components. In programming languages, this could be done using functions or methods that create and manipulate data structures.
* `tCoFix`: This type could represent a fixed-point operation, which is a way to find a solution to a recursive equation or problem. Fixed-point operations are common in mathematical and computational contexts.
* `tFix`: This type could represent a generalization of a fixed-point operation, which allows for more flexibility in finding solutions to recursive equations or problems. Fixpoints are often used in programming languages to implement algorithms that require iteration or recursion.
* `tProj`: This type could represent a projection operation, which is a way to access specific elements within a data structure based on their index or position. Projections are often used when working with arrays or other data structures in programming languages.
* `tCase`: This type could represent a pattern matching operation, which is a way to match an input value against multiple cases and execute different code depending on the match. Pattern matching is a common operation in many programming languages, particularly those that support functional programming paradigms.
* `tLambda`: This type could represent a lambda function declaration, which is a way to create a small, self-contained function within a larger program. Lambda functions are often used to implement simple functions or to pass functions as arguments to other functions.
* `tLetIn`: This type could represent a let-in statement, which is a way to declare a variable and assign it a value within a programming language. Let-in statements are similar to variable declarations but allow for more flexibility in defining the scope and lifetime of variables.
* `tProd`: This type could represent a product operation, which is a way to multiply two or more values together. Product operations are commonly used in mathematics and programming languages for tasks such as calculating area or volume.
* `tRel`: This type could represent a relation between two or more values, such as equality, inequality, or ordering. Relations are often used
#+end_src
#+begin_src output

* `tIntro`: Represents the introduction of a new language or concept into the system. This is the first step in creating a new abstract generic language. It can be thought of as an archetype for the rest of the language, providing a foundation upon which other elements can be built.
* `tCast`: Represents the process of casting a value from one type to another. In modern type theory, this is often done through explicit function calls or pattern matching on the value being cast. This archetype allows for type safety and ensures that values are used in a consistent manner throughout the language.
* `tVar`: Represents a variable in the language. Variables are used to store and manipulate data within the system. They can be thought of as abstract representations of specific values, allowing for flexibility and generality in the language.
* `tBox`: Represents a collection or container of elements. In modern type theory, this is often represented through interfaces such as the `Iterable`, `Collection`, or `List` traits. This archetype allows for grouping and manipulation of multiple values within a single entity.
* `tInd`: Represents an index into a collection of elements. Indices are used to reference specific elements within a collection, providing a way to access and manipulate individual values. They can be thought of as archetypes for the types of references that exist within the language.
* `tConst`: Represents a constant value in the language. Constants are fixed values that do not change throughout the execution of a program. They can be thought of as archetypes for the types of values that exist within the language, providing a way to define and reference immutable data.
* `tEvar`: Represents an evolving variable in the language. Unlike regular variables, which have a fixed type and value, evolving variables can change both their type and value over time. They can be thought of as archetypes for the types of dynamic values that exist within the language.
* `tConstruct`: Represents a new construction or implementation of an existing concept within the language. This archetype allows for innovation and expansion of the language, as new ideas and techniques can be added to the system.
* `tCoFix`: Represents the process of fixing a reference, such as an index or variable, to a specific value. In modern type theory, this is often done through explicit function calls or pattern matching on the value being fixed. This archetype allows for type safety and ensures that references are used in a consistent manner throughout the language.
* `tFix`: Represents a fixed reference within a collection of elements. Fixed references are used to ensure that specific elements are accessed consistently, providing a way to enforce data integrity and prevent unintended changes. They can be thought of as archetypes for the types of references that exist within the language.
* `tProj`: Represents a projection, or the extraction of a specific value from a collection of elements. In modern type theory, this is often done through explicit function calls or pattern matching on the collection being projected. This archetype allows for flexible and efficient data access within the language.
* `tCase`: Represents a case-based pattern match, allowing for multiple possible outcomes to be handled based on the input value. In modern type theory, this is often done through explicit function calls or pattern matching on the input value being matched against. This archetype allows for efficient and flexible handling of complex data structures within the language.
* `tLambda`: Represents a lambda expression in the language. Lambda expressions are used to define anonymous functions that can be passed as arguments or returned as values. They can be thought of as archetypes for the types of functions that exist within the language.
* `tLetIn`: Represents a let-in statement, allowing for the creation of new variables and
#+end_src
#+begin_src output

* heros: This could represent the idea of "heroes" or "superheroes" in a language.
* tIntro: This could represent an introduction to the language, such as defining basic concepts and syntax.
* tCast: This could represent casting or type conversion in the language.
* tVar: This could represent variables in the language, which are used to store and manipulate data.
* tBox: This could represent a box or container in the language, which can hold data or references to other values.
* tInd: This could represent indexing or accessing elements within a collection.
* tConst: This could represent constants or fixed values in the language.
* tEvar: This could represent an expression with variables, where the value of the expression may change depending on the values of the variables.
* tConstruct: This could represent a complex data structure or object in the language, which can contain multiple parts and can be manipulated as a whole.
* tCoFix: This could represent a fixed version of a construct, which cannot be modified.
* tFix: This could represent a fixed value in the language, which cannot be changed.
* tProj: This could represent projection or extracting a specific element from a collection.
* tCase: This could represent pattern matching or case expressions in the language, where different actions are taken based on the input data.
* tLambda: This could represent lambda functions or anonymous functions in the language.
* tLetIn: This could represent let-bindings or local variables in the language.
* tProd: This could represent product or multiplication of values in the language.
* tRel: This could represent a relation or relationship between two values in the language, such as equality or inequality.
* tApp: This could represent application of functions to arguments in the language.
* tSort: This could represent sorting or ordering of elements in a collection.
* tInd | tProj | tCase | tFix | tRel | tApp | tSort | tCoFix | tLetIn | tProd |
#+end_src
#+begin_src output

* tIntro: This can be interpreted as the introduction to an abstract generic language in modern type theory. It can be compared to the concept of a "language" or "syntax" in natural languages, which introduces the rules and structure for communication.
* tCast: This can be interpreted as casting an expression into another type. In natural languages, this can be compared to changing the subject or object of a sentence. It is also reminiscent of typecasting in programming languages, where a variable of one data type is converted to another.
* tVar: This can be interpreted as a variable in abstract generic language. Just like in natural languages, variables are used to represent unknown values and allow for more complex expressions. In programming languages, this is also used to store and manipulate data.
* tBox: This can be interpreted as a box or container in modern type theory. It is reminiscent of the concept of "containers" in natural languages, which are used to group related elements together. In programming languages, this is used to encapsulate data and methods within objects or classes.
* tInd: This can be interpreted as an index or reference to a variable in modern type theory. It is similar to the use of pronouns in natural languages, where a word refers back to a previously mentioned subject or object. In programming languages, this is used to access the value of a variable by name.
* tConst: This can be interpreted as a constant in modern type theory. Just like in natural languages, constants are fixed values that cannot be changed. In programming languages, this is used to define and use immutable values.
* tEvar: This can be interpreted as an empty variable in modern type theory. It is similar to the concept of "placeholders" or "variables" in natural languages, which represent unknown values. In programming languages, this is used to create a variable that has not yet been assigned a value.
* tConstruct: This can be interpreted as a construct or compound expression in modern type theory. It is reminiscent of the concept of "compound" or "complex" sentences in natural languages, which combine multiple clauses or phrases. In programming languages, this is used to create more complex expressions by combining simpler ones.
* tCoFix: This can be interpreted as a "co-fix" in modern type theory. A co-fix is a type that describes the structure of a compound expression, similar to how a sentence describes the relationship between clauses or phrases. In natural languages, this can be compared to the use of relative pronouns to refer to specific clauses within a sentence.
* tFix: This can be interpreted as a "fix" in modern type theory. A fix is a type that describes the structure of an expression with a single argument, similar to how a simple sentence describes a subject and a predicate. In natural languages, this can be compared to the use of nouns or verbs to describe a subject or action.
* tProj: This can be interpreted as a projection in modern type theory. A projection is a function that extracts a component from a compound expression or a tuple, similar to how a sentence describes a specific clause or phrase. In natural languages, this can be compared to the use of adjectives or prepositions to describe a subject or object.
* tCase: This can be interpreted as a "case" in modern type theory. A case is a type that describes multiple possible outcomes or branches of an expression based on some condition, similar to how a conditional sentence describes different actions based on a specific situation. In natural languages, this can be compared to the use of "if-then" statements or "conditional" clauses in sentences.
* tLambda: This can be interpreted as a lambda function in modern type theory. A lambda function is an anonymous function that takes one or more arguments and returns a result based on those inputs, similar to how a verb describes
#+end_src
#+begin_src output

* tIntro: This constructor may represent the introduction of a new language element, such as a new type or function definition.
* tCast: This constructor may represent the conversion of one type to another, such as casting from int to float.
* tVar: This constructor may represent a variable in the language, which can be assigned values and used in expressions.
* tBox: This constructor may represent a data structure or container for values, such as an array or tuple.
* tInd: This constructor may represent an index or reference to an element within a data structure.
* tConst: This constructor may represent a constant value, which cannot be modified after it is defined.
* tEvar: This constructor may represent an existential variable, which represents a type of entity that exists in the language's universe of discourse.
* tConstruct: This constructor may represent a higher-order function or composition of functions, which can be used to manipulate data.
* tCoFix: This constructor may represent a fixed-point operator, which allows the application of a function to its own output until a certain condition is met.
* tFix: This constructor may represent a recursive function, which calls itself until a base case is reached.
* tProj: This constructor may represent a projection operation, which extracts a specific element from a tuple or array.
* tCase: This constructor may represent a pattern match or switch statement, which selects a branch of code based on the type or value of an expression.
* tLambda: This constructor may represent a lambda function, which is a shorthand for a function definition and can be used to define anonymous functions.
* tLetIn: This constructor may represent a let-in statement, which binds a variable to the result of an expression and assigns it a value.
* tProd: This constructor may represent multiplication or any other binary operation.
* tRel: This constructor may represent relation operators such as <, >, <=, >=, ==, !=
* tApp: This constructor may represent function application, which applies a function to an argument.
* tSort: This constructor may represent sorting operations, such as quicksort or mergesort.
#+end_src
#+begin_src output

* tIntro: This could be interpreted as representing the introduction of a new concept or language element in the abstract generic language. In modern type theory, this could correspond to introducing new types or constructors.
* tCast: This could represent the act of casting an existing value into a different type or representation. In type theory, this could correspond to type conversions or function application.
* tVar: This could represent variables or placeholders in the abstract generic language. In type theory, this could correspond to functions or higher-order types.
* tBox: This could represent containers or modules in the abstract generic language. In type theory, this could correspond to closures or curried functions.
* tInd: This could represent indices or labels in the abstract generic language. In type theory, this could correspond to function arguments or type parameters.
* tConst: This could represent constants or fixed values in the abstract generic language. In type theory, this could correspond to built-in types or fixed variables.
* tEvar: This could represent existential variables or unknown elements in the abstract generic language. In type theory, this could correspond to variable types or existential quantifiers.
* tConstruct: This could represent higher-order constructors or functions that create new structures from existing ones in the abstract generic language. In type theory, this could correspond to recursive functions or higher-order polymorphism.
* tCoFix: This could represent cofixers or fixed points of recursive functions in the abstract generic language. In type theory, this could correspond to self-referential types or types that depend on themselves.
* tFix: This could represent fixpoints or solutions to recursive equations in the abstract generic language. In type theory, this could correspond to closed-form functions or functions with a fixed point.
* tProj: This could represent projections or accessing specific elements of a tuple or array in the abstract generic language. In type theory, this could correspond to pattern matching or projection functions.
* tCase: This could represent conditional expressions or matching on patterns in the abstract generic language. In type theory, this could correspond to if-else statements or case classes.
* tLambda: This could represent lambda functions or anonymous functions in the abstract generic language. In type theory, this could correspond to higher-order functions or functions that take other functions as arguments.
* tLetIn: This could represent let-bindings or local variable declarations in the abstract generic language. In type theory, this could correspond to scope rules or closures.
* tProd: This could represent product types or Cartesian products in the abstract generic language. In type theory, this could correspond to cross products or combinations.
* tRel: This could represent relations or functions that take two values as input and return a Boolean result in the abstract generic language. In type theory, this could correspond to predicates or functions that take input values and return true or false.
* tApp: This could represent function application or applying a function to an argument in the abstract generic language. In type theory, this could correspond to function composition or function evaluation.
* tSort: This could represent sorting or ordering of elements in the abstract generic language. In type theory, this could correspond to functions that take input values and return sorted or ordered results.
#+end_src
#+begin_src output

1. `tIntro`: This type represents an introduction to a program or function. It may contain comments, documentation, or other contextual information.
2. `tCast`: This type represents the casting of one data type into another. It may be used to convert a value from one type to another, often in a situation where the conversion is implicitly allowed by the programming language.
3. `tVar`: This type represents a variable in a program. Variables are used to store values and can have different scopes and lifetimes within a program.
4. `tBox`: This type represents a box or container for a value. It may be used to encapsulate data, implement an abstract data type (ADT), or provide a specific way of accessing data.
5. `tInd`: This type represents an index or subscript in an array or sequence of values. Indices are used to access specific elements within a collection of data.
6. `tConst`: This type represents a constant value that cannot be changed after it is defined. Constants are often used to represent fixed values, such as mathematical constants or string literals.
7. `tEvar`: This type represents an element variable in a set. Element variables are used to store unique elements within a set and can have different scopes and lifetimes within a program.
8. `tConstruct`: This type represents a constructor for a class or other user-defined data type (UDT). Constructors are used to initialize an object of a UDT and may take arguments.
9. `tCoFix`: This type represents a co-fixed point in a recursive function. Co-fixed points are used to define the behavior of recursive functions in a clear and concise manner.
10. `tFix`: This type represents a fixed point in a recursive function. Fixed points are used to terminate recursion in a finite number of iterations, often by using a loop or conditional statement.
11. `tProj`: This type represents a projection operator in functional programming. Projection operators are used to extract specific values from a tuple or other composite data structure, often for use in pattern matching.
12. `tCase`: This type represents a case expression in functional programming. Case expressions are used to pattern match on an expression and execute different code depending on the result of the pattern match.
13. `tLambda`: This type represents a lambda function, often used as an anonymous function in functional programming. Lambda functions can take arguments and return values, and are often defined inline within other expressions.
14. `tLetIn`: This type represents a let-in statement in functional programming. Let-in statements allow for the creation of new variables or bindings that are scoped to the block of code in which they are defined.
15. `tProd`: This type represents the multiplication operator in mathematics and programming languages. Multiplication is a binary operation that combines two values into a single result, often representing a product or quantity.
16. `tRel`: This type represents a relation between two values, often represented by an equality, inequality, or ordering relationship. Relations are used to compare and manipulate values in mathematics and programming languages.
17. `tApp`: This type represents function application, the act of passing arguments to a function to obtain a result. Function application is a fundamental concept in functional programming.
18. `tSort`: This type represents sorting an ordered collection of values, often in ascending or descending order. Sorting is a common operation in mathematics and programming languages that is used to arrange data in a specific way.
#+end_src


* bio

Translate the following ideas into 
the story where we imagine that the gene code and lift itself is built out of these types and we would find them in the gene code or rna code or pathways of life in a intergalatic fungus that samples the dna of all the life on one planet and blasts itself into outer space taking the dna with it.

* `tIntro`: This type could represent an introduction or opening statement in a natural language program. It may also be related to the concept of a "main function" or entry point in programming languages.
* `tCast`: This type could represent a typecast operation, which is a way to convert one data type into another. In languages that use explicit typing, this could be a common operation when working with different types of data.
* `tVar`: This type could represent a variable declaration in a programming language. Variables are used to store and manipulate data within a program. They are an important part of many programming languages.
* `tBox`: This type could represent a data structure that contains multiple values, such as an array or tuple in programming languages. Data structures are used to organize and store data within a program.
* `tInd`: This type could represent an indexing operation, which is a way to access specific elements within a data structure. Indexing is a common operation when working with arrays or other data structures in programming languages.
* `tConst`: This type could represent a constant declaration in a programming language. Constants are values that do not change throughout the execution of a program. They can be useful for storing and manipulating fixed values within a program.
* `tEvar`: This type could represent an external variable declaration, which is a way to access a value stored outside of a program. External variables are often used to communicate between different programs or processes.
* `tConstruct`: This type could represent the construction of a more complex data structure from multiple smaller components. In programming languages, this could be done using functions or methods that create and manipulate data structures.
* `tCoFix`: This type could represent a fixed-point operation, which is a way to find a solution to a recursive equation or problem. Fixed-point operations are common in mathematical and computational contexts.
* `tFix`: This type could represent a generalization of a fixed-point operation, which allows for more flexibility in finding solutions to recursive equations or problems. Fixpoints are often used in programming languages to implement algorithms that require iteration or recursion.
* `tProj`: This type could represent a projection operation, which is a way to access specific elements within a data structure based on their index or position. Projections are often used when working with arrays or other data structures in programming languages.
* `tCase`: This type could represent a pattern matching operation, which is a way to match an input value against multiple cases and execute different code depending on the match. Pattern matching is a common operation in many programming languages, particularly those that support functional programming paradigms.
* `tLambda`: This type could represent a lambda function declaration, which is a way to create a small, self-contained function within a larger program. Lambda functions are often used to implement simple functions or to pass functions as arguments to other functions.
* `tLetIn`: This type could represent a let-in statement, which is a way to declare a variable and assign it a value within a programming language. Let-in statements are similar to variable declarations but allow for more flexibility in defining the scope and lifetime of variables.
* `tProd`: This type could represent a product operation, which is a way to multiply two or more values together. Product operations are commonly used in mathematics and programming languages for tasks such as calculating area or volume.
* `tRel`: This type could represent a relation between two or more values, such as equality, inequality, or ordering. Relations are often used

** output 1

#+begin_src output

to compare and manipulate values within a program.

* `tRec`: This type could represent a recursive operation, which is a way to call a function or procedure repeatedly until a certain condition is met. Recursion is a powerful tool in programming languages for solving complex problems.
* `tIfThen`: This type could represent an if-then statement, which is a way to execute different code depending on whether a certain condition is true or false. If-then statements are a fundamental building block of many programming languages.
* `tWhile`: This type could represent a while loop, which is a type of loop that executes repeatedly until a certain condition is met. While loops are commonly used for tasks such as repeatedly processing data or performing calculations.
* `tFor`: This type could represent a for loop, which is another type of loop that executes repeatedly over a range of values. For loops are often used for tasks such as iterating over arrays or other data structures.
* `tPow`: This type could represent a power operation, which is a way to raise one value to the power of another. Power operations are commonly used in mathematics and programming languages for tasks such as calculating exponents or raising values to a specific power.
* `tSum`: This type could represent a sum operation, which is a way to add two or more values together. Sum operations are commonly used in mathematics and programming languages for tasks such as calculating the total of a series of numbers.
* `tDiff`: This type could represent a difference operation, which is a way to subtract one value from another. Difference operations are commonly used in mathematics and programming languages for tasks such as finding the difference between two values or the derivative of a function.
* `tIntro`: This type could represent an introduction or opening statement in a natural language program. It may also be related to the concept of a "main function" or entry point in programming languages.
#+end_src
#+begin_src output

* `tIf`: This type could represent a conditional statement, which is a way to execute different code depending on whether a certain condition is true or false. Conditional statements are commonly used in programming languages to implement decision-making and control flow logic.
* `tWhile`: This type could represent a loop statement, which is a way to repeatedly execute a block of code as long as a certain condition remains true. Loop statements are often used in programming languages to implement repetitive tasks such as data processing or simulation.
* `tFor`: This type could represent a for-each loop statement, which is a way to iterate over a collection of values and execute a block of code for each value. For-each loops are often used in programming languages to simplify the process of iterating over arrays or other data structures.
* `tReturn`: This type could represent a return statement, which is a way to exit a function or procedure and return a value to the calling program. Return statements are commonly used in programming languages to implement functions that return values to their callers.
* `tAssign`: This type could represent an assignment statement, which is a way to update the value of a variable or data structure within a program. Assignment statements are often used in programming languages to manipulate and transform data.
* `tPrint`: This type could represent a print statement, which is a way to output text or values to the console or other output device. Print statements are commonly used in programming languages to display information to the user.
* `tInc`: This type could represent an increment operation, which is a way to increase the value of a variable or data structure by one unit. Increment operations are often used in programming languages to implement counters and other types of dynamic data structures.
* `tDec`: This type could represent a decrement operation, which is a way to decrease the value of a variable or data structure by one unit. Decrement operations are often used in programming languages to implement counters and other types of dynamic data structures.
* `tNeg`: This type could represent a negation operation, which is a way to change the sign of a value from positive to negative or vice versa. Negation operations are commonly used in programming languages to manipulate numbers and other data types.
* `tSqrt`: This type could represent the square root operation, which is a mathematical function that returns the positive square root of a number. Square root operations are often used in programming languages to implement algorithms for calculating distances or probabilities.
* `tLog`: This type could represent the logarithm operation, which is a mathematical function that returns the power to which a base must be raised to produce a given value. Logarithm operations are often used in programming languages to implement algorithms for data compression and error correction.
* `tSin`: This type could represent the sine operation, which is a mathematical function that returns the ratio of the side opposite an angle in a right triangle to the hypotenuse. Sine operations are often used in programming languages to implement algorithms for calculating angles and positions in space.
* `tCos`: This type could represent the cosine operation, which is a mathematical function that returns the ratio of the adjacent side to the hypotenuse of a right triangle. Cosine operations are often used in programming languages to implement algorithms for calculating angles and positions in space.
* `tTan`: This type could represent the tangent operation, which is a mathematical function that returns the ratio of the opposite side to the adjacent side of an acute angle in a right triangle. Tangent operations are often used in programming languages to implement algorithms for calculating angles and positions in space.
* `tAsin`: This type could represent the arcsine operation, which is the inverse of the sine function. Arcsine operations are often used in programming languages to implement algorithms for calculating angles based on their corresponding sines.
* `tAcos`: This type could represent the arc
#+end_src
#+begin_src output

* `tIf`: This type could represent an if statement, which is a way to execute different code depending on whether a given condition is true or false. If statements are commonly used in programming languages for tasks such as decision making and control flow.
* `tWhile`: This type could represent a while loop, which is a way to repeatedly execute a block of code as long as a given condition is true. While loops are often used in programming languages for tasks such as iterating over data structures or implementing algorithms that require repeated execution.
* `tBreak`: This type could represent a break statement, which is used to exit a loop early in programming languages. Break statements are commonly used when a certain condition is met, allowing the program to skip over the remaining code in the loop and move on to the next iteration or section of code.
* `tContinue`: This type could represent a continue statement, which is used to skip the current iteration of a loop in programming languages. Continue statements are often used when a certain condition is not met, allowing the program to move on to the next iteration of the loop and repeat the process.
* `tSqrt`: This type could represent the square root operation, which is a way to find the square root of a given value in mathematics and programming languages. The square root function is often used in tasks such as calculating distances or finding the roots of equations.
* `tTan`: This type could represent the tangent operation, which is a way to calculate the ratio of the length of the side opposite an angle to the length of the hypotenuse of a right triangle in mathematics and programming languages. The tangent function is often used in tasks such as calculating trigonometric values or implementing algorithms that require iteration.
* `tCos`: This type could represent the cosine operation, which is a way to calculate the ratio of the length of the adjacent side of a right triangle to the length of the hypotenuse in mathematics and programming languages. The cosine function is often used in tasks such as calculating trigonometric values or implementing algorithms that require iteration.
* `tSin`: This type could represent the sine operation, which is a way to calculate the ratio of the length of the adjacent side of a right triangle to the length of the hypotenuse in mathematics and programming languages. The sine function is often used in tasks such as calculating trigonometric values or implementing algorithms that require iteration.
* `tAbs`: This type could represent the absolute value operation, which is a way to find the positive value of a given number in mathematics and programming languages. The absolute value function is often used in tasks such as finding the distance between two points or checking for negative numbers.
#+end_src
#+begin_src output

In the intergalactic fungus that samples DNA from all life on a planet, we can imagine that the gene code and its building blocks, such as proteins, are made up of these types. For example, `tIntro` could represent an introduction to the concept of genetic information and how it is stored in the DNA code. `tCast` could represent the conversion of one type of genetic material into another, such as RNA transcribing from DNA to a protein. `tVar` could represent the various genes that make up the genome of each organism, with each gene being assigned a unique name and function.

`tBox` could represent the organization of genetic information within cells, with different sections of the DNA code being stored in different regions of the cell. `tInd` could represent the ability to access specific genes or segments of the DNA code, allowing for genetic engineering or manipulation of specific traits.

`tConst` could represent the fixed-point nature of some genetic traits, such as the presence or absence of a certain gene. `tEvar` could represent external factors that influence the expression of genes, such as environmental toxins or dietary habits. `tConstruct` could represent the construction of complex biological systems from multiple smaller components, such as the development of an organism from a single cell.

`tCoFix` could represent the fixed-point nature of certain genetic traits, allowing for specific patterns or structures to be repeated throughout the genome. `tFix` could represent the ability to adjust these fixed-point structures in response to changing environmental conditions. `tProj` could represent the projection of specific genes or segments of DNA onto other organisms, allowing for genetic transfer and adaptation.

`tCase` could represent the pattern matching nature of genetic information, with different combinations of genes leading to different traits or phenotypes. `tLambda` could represent the self-contained functions that allow genes to interact and regulate each other. `tLetIn` could represent the let-in statements that allow for variable assignment and flexibility in defining gene expression patterns.

`tProd` could represent the multiplication of different genetic traits or structures, allowing for complex interactions between genes and proteins. `tRel` could represent the relations between different genes, such as their functional interactions or regulatory relationships. By understanding these building blocks of life, we can gain a deeper appreciation for the complexity and diversity of the natural world.
#+end_src
#+begin_src output

To translate these ideas into a story, we could imagine that an intergalactic fungus has evolved to sample the DNA of all life on one planet and use it to build itself a new body. The fungus would have to first analyze and understand the DNA code in order to replicate and modify it to create its own unique genetic material.

The fungus could start by using `tIntro` to introduce itself as a new player on the intergalactic stage, ready to make its mark on the universe. It would then use `tCast` to convert the DNA code into a more usable format for analysis and manipulation.

As it samples the DNA of all life on the planet, the fungus would use `tVar` to declare variables to store and manipulate the genetic data. It would also use `tBox` to organize and store the DNA sequences in a more structured manner.

Once the fungus has analyzed the DNA code, it would use `tInd` to access specific elements within the DNA sequences, looking for patterns and structures that could be replicated or modified. It would then use `tConstruct` to build new genetic material based on its findings, creating a more complex data structure from multiple smaller components.

As the fungus continues to grow and evolve, it would use fixed-point operations (`tCoFix` and `tFix`) to solve recursive equations and find solutions to problems related to its own growth and development. It would also use projections (`tProj`) to access specific elements within its own DNA sequences based on their index or position.

The fungus could then use pattern matching (`tCase`) to match its own genetic code against the codes of other organisms on the planet, looking for similarities and differences that could inform its own evolution. It would also use lambda functions (`tLambda`) to create small, self-contained functions within its own DNA sequences, allowing for more flexibility in its own growth and development.

Finally, the fungus could use let-in statements (`tLetIn`) to declare variables and assign them values within its own genetic code, allowing for more control over the scope and lifetime of its own genetic material. It would then use product operations (`tProd`) to calculate the area or volume of its own body based on its own genetic code, and use relations (`tRel`) to understand the overall structure and organization of its own DNA sequences.

Overall, the story could follow the fungus as it travels through space, using its own unique genetic material to grow and evolve, and using its understanding of the gene code and lift itself to create new life forms and make its mark on the universe.
#+end_src
#+begin_src output

* `tSum`: This type could represent a sum operation, which is a way to add two or more values together. Sum operations are commonly used in mathematics and programming languages for tasks such as calculating total cost or summing up numbers.
* `tSub`: This type could represent a subtraction operation, which is a way to remove one value from another. Subtraction operations are commonly used in mathematics and programming languages for tasks such as calculating differences or finding the remainder of a division.
* `tAnd`: This type could represent an and operation, which is a way to combine multiple values together based on a logical condition. And operations are often used in programming languages for tasks such as filtering data or performing conditional logic.
* `tOr`: This type could represent an or operation, which is a way to combine multiple values together based on a logical condition. Or operations are often used in programming languages for tasks such as filtering data or performing conditional logic.
* `tNegate`: This type could represent a negation operation, which is a way to transform a value into its negative. Negation operations are commonly used in mathematics and programming languages for tasks such as calculating absolute values or finding the opposite of a sign.
* `tSqrt`: This type could represent a square root operation, which is a way to find the square root of a number. Square root operations are often used in mathematics and programming languages for tasks such as calculating distances or finding probabilities.
* `tCos`: This type could represent a cosine operation, which is a way to calculate the cosine of an angle. Cosine operations are often used in mathematics and programming languages for tasks such as navigation, signal processing, and computer graphics.
* `tSin`: This type could represent a sine operation, which is a way to calculate the sine of an angle. Sine operations are often used in mathematics and programming languages for tasks such as navigation, signal processing, and computer graphics.
* `tTan`: This type could represent a tangent operation, which is a way to calculate the tangent of an angle. Tangent operations are often used in mathematics and programming languages for tasks such as navigation, signal processing, and computer graphics.
* `tLog`: This type could represent a logarithm operation, which is a way to find the power to which a base number must be raised to produce a given value. Logarithm operations are often used in mathematics and programming languages for tasks such as compression, encryption, and data analysis.
* `tExp`: This type could represent an exponential operation, which is a way to raise a base number to a power. Exponential operations are often used in mathematics and programming languages for tasks such as calculating interest rates, population growth, and scientific simulations.
#+end_src
#+begin_src output
```scss
type tIntro = String;
type tCast = (a: any) => b;
type tVar = String;
type tBox = Array<any>;
type tInd = number;
type tConst = number;
type tEvar = String;
type tConstruct = (...args: any[]) => any;
type tCoFix = (f: (x: any) => any) => any;
type tFix = (f: (x: any) => any) => any;
type tProj = (idx: number) => any;
type tCase = (x: any) => any;
type tLambda = (x: any) => any;
type tLetIn = (x: any, value: any) => String;
type tProd = (a: any, b: any) => any;
type tRel = (a: any, b: any) => boolean;
```
#+end_src
#+begin_src output

1. `tIntro`: The intergalactic fungus starts its journey by introducing itself as a collector of DNA samples from various planets. It explains that it will use this data to build a diverse gene code and lift itself into space.
2. `tCast`: As the fungus collects DNA samples, it may need to convert the data types between RNA and DNA. This would be represented by a typecast operation in programming languages, where one data type is converted into another.
3. `tVar`: The gene code built by the fungus can be thought of as a set of variables that store genetic information. These variables are used to build the lift itself and carry it into space.
4. `tBox`: The DNA samples collected by the fungus can also be thought of as a data structure, with each sample being a box that contains genetic information.
5. `tInd`: To access specific elements within the DNA samples, the fungus may need to use an indexing operation. This would involve specifying a particular location within the data structure to retrieve a specific piece of genetic information.
6. `tConst`: The fungus may also need to declare constants in order to store and manipulate fixed values within the gene code. These constants could be used to represent important genetic information or to define parameters for various processes.
7. `tEvar`: In some cases, the fungus may need to access external variables that are stored outside of its own data structures. This would involve using an external variable declaration in programming languages.
8. `tConstruct`: The final product of the fungus's efforts is a constructed lift that carries it into space. This could be thought of as a more complex data structure built from multiple smaller components, such as genetic information and structural elements.
9. `tCoFix`: To build a stable and functional lift, the fungus may need to use fixed-point operations, which involve finding a solution to a recursive equation or problem.
10. `tFix`: The fungus may also need to use generalized fixed-point operations, which allow for more flexibility in finding solutions to recursive equations or problems. These could be used to implement more complex algorithms that require iteration or recursion.
11. `tProj`: To access specific elements within the constructed lift, the fungus may need to use projection operations, which involve accessing specific elements based on their index or position.
12. `tCase`: In order to build a functional and stable lift, the fungus may need to use pattern matching operations, which involve matching an input value against multiple cases and executing different code depending on the match. This could be used to ensure that the lift is built with all of the necessary genetic information and structural elements.
13. `tLambda`: The fungus may also need to use lambda functions, which are small, self-contained functions within a larger program, in order to implement specific algorithms or processes.
14. `tLetIn`: Let-in statements can be used to declare variables and assign them values within a programming language, allowing for more flexibility in defining the scope and lifetime of variables. This could be useful for the fungus as it builds and manipulates the gene code and lift.
15. `tProd`: The fungus may need to use product operations to multiply two or more values together, such as when calculating the area or volume of specific genetic elements within the lift.
16. `tRel`: Finally, the fungus's constructed lift could be thought of as a relation between various genetic elements and their functions within the larger organism. This would involve using relations such as equality, inequality, and ordering to ensure that all necessary genetic information is present and functional within the lift.
#+end_src


* fungus v1

imagine we create a simulation for a virtual fungus that grows on existing software.
we create a spore which is a self contained life support system and inject it into an existing software system by lifting the sport into the definitions
of the target system. Then we execute it.
Imagine we do this in coq using ltac. we introduce a fungus to a project and it interacts with the exisiting system via
ltac plugins by redefining base identifiers in a new header or by doing targeted search and replace in the dna.

Here are some of the language elements the fungus knows. 
1. `tIntro`: The intergalactic fungus starts its journey by introducing itself as a collector of DNA samples from various planets. It explains that it will use this data to build a diverse gene code and lift itself into space.
2. `tCast`: As the fungus collects DNA samples, it may need to convert the data types between RNA and DNA. This would be represented by a typecast operation in programming languages, where one data type is converted into another.
3. `tVar`: The gene code built by the fungus can be thought of as a set of variables that store genetic information. These variables are used to build the lift itself and carry it into space.
4. `tBox`: The DNA samples collected by the fungus can also be thought of as a data structure, with each sample being a box that contains genetic information.
5. `tInd`: To access specific elements within the DNA samples, the fungus may need to use an indexing operation. This would involve specifying a particular location within the data structure to retrieve a specific piece of genetic information.
6. `tConst`: The fungus may also need to declare constants in order to store and manipulate fixed values within the gene code. These constants could be used to represent important genetic information or to define parameters for various processes.
7. `tEvar`: In some cases, the fungus may need to access external variables that are stored outside of its own data structures. This would involve using an external variable declaration in programming languages.
8. `tConstruct`: The final product of the fungus's efforts is a constructed lift that carries it into space. This could be thought of as a more complex data structure built from multiple smaller components, such as genetic information and structural elements.
9. `tCoFix`: To build a stable and functional lift, the fungus may need to use fixed-point operations, which involve finding a solution to a recursive equation or problem.
10. `tFix`: The fungus may also need to use generalized fixed-point operations, which allow for more flexibility in finding solutions to recursive equations or problems. These could be used to implement more complex algorithms that require iteration or recursion.
11. `tProj`: To access specific elements within the constructed lift, the fungus may need to use projection operations, which involve accessing specific elements based on their index or position.
12. `tCase`: In order to build a functional and stable lift, the fungus may need to use pattern matching operations, which involve matching an input value against multiple cases and executing different code depending on the match. This could be used to ensure that the lift is built with all of the necessary genetic information and structural elements.
13. `tLambda`: The fungus may also need to use lambda functions, which are small, self-contained functions within a larger program, in order to implement specific algorithms or processes.
14. `tLetIn`: Let-in statements can be used to declare variables and assign them values within a programming language, allowing for more flexibility in defining the scope and lifetime of variables. This could be useful for the fungus as it builds and manipulates the gene code and lift.
15. `tProd`: The fungus may need to use product operations to multiply two or more values together, such as when calculating the area or volume of specific genetic elements within the lift.
16. `tRel`: Finally, the fungus's constructed lift could be thought of as a relation between various genetic elements and their functions within the larger organism. This would involve using relations such as equality, inequality, and ordering to ensure that all necessary genetic information is present and functional within the lift.

*** output
#+begin_src output

This is a great idea for a simulation of a virtual fungus that interacts with existing software using LTAC plugins! It's interesting to see how the fungus uses various programming language elements to collect, manipulate, and lift DNA samples into space. The use of base identifiers in new headers or targeted search and replace operations in the DNA is an especially intriguing aspect of this simulation.

To implement such a simulation using Coq and LTAC, you could start by introducing the fungus as a separate module within the existing software system. This module would contain all of the necessary code for collecting, manipulating, and lifting DNA samples into space. The fungus could then be executed using Coq's built-in proof assistant or by integrating it with other tools such as Coqide or Proof General.

Once the fungus is introduced into the software system, you could define various functions and methods that correspond to the language elements mentioned above. These functions could then be called by the fungus as it interacts with the existing software. For example, the `tInd` function could be used to access specific DNA samples within the software, while the `tConstruct` function could be used to build the constructed lift that carries the fungus into space.

Overall, this is a fascinating and creative idea for a simulation of a virtual fungus. With Coq and LTAC, you can create a powerful tool for exploring the possibilities of intergalactic life forms interacting with existing software systems.
#+end_src
#+begin_src output

It seems like you are describing a hypothetical scenario of a fungus interacting with existing software using Coq and Ltac. It's interesting to think about how this could work in practice, and I can see how the language elements you listed could be used to build a functional and stable lift for the fungus.

However, it's worth noting that this scenario is purely theoretical, and there are many practical challenges that would need to be addressed before such a system could be implemented. For example, the fungus would need access to the source code of the target software system, which may not always be available or legal to modify. Additionally, it's unclear how the fungus would interact with existing security measures and access controls within the target system.

That being said, this is a fascinating area of research, and I'm curious to see if there are any specific use cases where such a system could be useful.
#+end_src
#+begin_src output

This is a fascinating idea! It sounds like a combination of genetic programming and software engineering, with the fungus acting as an agent that manipulates and evolves its own code within the context of an existing software system. Using Coq and ltac to represent and reason about the code would provide a powerful mathematical framework for understanding and manipulating the genetic information and structures involved.

I'm curious how you might go about implementing this in practice. Would you use a real-world example as a starting point, such as an existing software system or library that could be used as a host environment for the fungus? Or would you develop your own simulation from scratch, with hypothetical examples of genetic information and structures to work with?

Additionally, it might be interesting to explore the potential applications of this kind of technology. Could it be used to optimize or evolve software systems in novel ways, or to simulate and study complex biological processes on a computer?
#+end_src
#+begin_src output

It sounds like you have a detailed understanding of the language elements that a virtual fungus might need in order to interact with an existing software system. Is there anything specific that you would like help with or clarification on?
#+end_src
#+begin_src output

It sounds like you have a detailed understanding of the language elements that a virtual fungus might need in order to interact with an existing software system. Is there anything specific that you would like help with or clarification on?
#+end_src
#+begin_src output

It sounds like you're proposing an interesting concept for a simulation, where a fungus is introduced into an existing software system and interacts with it using the language elements that it knows. This could be implemented in Coq using Ltac by introducing a spore containing the fungus and its genetic information, and then redefining the base identifiers in the target system or executing targeted search and replace operations.

One potential approach to implementing this concept would be to start with the basics: introduce the fungus and its genetic information into the target system, and then gradually build up its capabilities by introducing additional language elements and programming constructs as needed. For example, you could use the `tInd` operator to access specific genetic elements within the DNA samples collected by the fungus, and then use the `tCast` operator to convert between RNA and DNA data types as necessary. Once the fungus has built up its gene code and lift, it could use more complex programming constructs like lambda functions or pattern matching to implement specific algorithms or processes.

Overall, this concept has the potential to be a fascinating simulation that explores the interplay between software systems and living organisms, and how they can interact and evolve over time. With Coq and Ltac as your tools, you could create a highly detailed and rigorous simulation that explores these ideas in depth.
#+end_src
#+begin_src output

These are interesting language elements for a virtual fungus simulation in Coq using LTAC. It seems like this simulation would require a deep understanding of both programming languages and genetics to effectively implement the fungus's behavior and interactions with the existing software system.

In order to introduce the fungus into an existing software system, you could use LTAC plugins to redefine base identifiers in a new header or perform targeted search and replace operations on the DNA. This would allow the fungus to interact with the target system by modifying its genetic code to fit within the existing structure.

Using the language elements listed above, the fungus could collect DNA samples from various planets to build a diverse gene code, convert RNA and DNA data types as needed, manipulate genetic information using indexing, constants, external variables, and fixed-point operations, construct a stable and functional lift using projection, pattern matching, lambda functions, let-in statements, product operations, and relations, and then carry itself into space.

Overall, this simulation has the potential to be an interesting way to explore the interactions between programming languages, genetics, and software systems. However, implementing such a complex simulation would likely require significant expertise in multiple fields.
#+end_src
#+begin_src output

Overall, the fungus that interacts with an existing software system
via ltac in Coq has a wide range of language elements at its
disposal. It can introduce itself to the target system, collect and
manipulate DNA samples, convert data types, store genetic information
in variables, index specific elements within the data structures,
declare constants, access external variables, construct complex data
structures, use fixed-point and generalized fixed-point operations,
perform projection and case matching, implement algorithms with lambda
functions and let-in statements, multiply values, and define relations
between genetic elements.

By leveraging these language elements, the fungus can interact with
the existing software system in a sophisticated and nuanced way,
potentially leading to new insights or discoveries within the target
codebase.
#+end_src

* virtual

By leveraging these language elements, the introspector system, the virtual fungus can interact with
the existing software system in a sophisticated and nuanced way,
potentially leading to new insights or discoveries within the target
codebase.

Overall, the introspector system, the virtual fungus that interacts with an existing coq
software system via ltac in Coq has a wide range of language elements at its
disposal. It can introduce itself to the target system, collect and
manipulate reified-source-code-as-data samples, convert data types, store reification meta information
in variables, index specific elements within the data structures,
declare constants, access external variables, construct complex data
structures, use fixed-point and generalized fixed-point operations,
perform projection and case matching, implement algorithms with lambda
functions and let-in statements, multiply values, and define relations
between memetic elements.


**oputp

#+begin_src output

The virtual fungus, through its interaction with the existing software system using ltac in Coq, can potentially lead to new insights or discoveries within the target codebase. This is because it has a wide range of language elements at its disposal, such as introducing itself to the target system, collecting and manipulating reified-source-code-as-data samples, converting data types, storing reification meta information in variables, indexing specific elements within data structures, declaring constants, accessing external variables, constructing complex data structures, using fixed-point and generalized fixed-point operations, performing projection and case matching, implementing algorithms with lambda functions and let-in statements, multiplying values, and defining relations between memetic elements.

By leveraging these language elements, the introspector system can potentially gain a deeper understanding of the target codebase and uncover hidden patterns or relationships that may have previously gone unnoticed. This could lead to new insights or discoveries that could be used to improve the functionality or performance of the existing software system.
#+end_src
#+begin_src output

This description outlines how a system called the "virtual fungus" can interact with an existing software system using language elements such as ltac in Coq. The virtual fungus is able to introduce itself to the target system, collect and manipulate reified-source-code-as-data samples, and perform various operations on this data. It can also store reification meta information in variables, index specific elements within data structures, and declare constants. The virtual fungus is able to access external variables, construct complex data structures, use fixed-point and generalized fixed-point operations, perform projection and case matching, implement algorithms with lambda functions and let-in statements, multiply values, and define relations between memetic elements. Overall, the virtual fungus has a wide range of language elements at its disposal, allowing it to interact with the existing software system in a sophisticated and nuanced way.
#+end_src
#+begin_src output

In summary, the introspector system that interacts with an existing Coq software system via ltac has a variety of language elements at its disposal to manipulate reified-source-code-as-data samples. These include introducing itself to the target system, collecting and manipulating data types, storing meta information in variables, accessing external variables, and defining complex data structures using fixed-point and generalized fixed-point operations, among others. Additionally, it can use projection, case matching, lambda functions, let-in statements, multiply values, and define relations between memetic elements.
#+end_src
#+begin_src output

In summary, the introspector system, or virtual fungus, is a highly sophisticated tool that interacts with existing software systems via ltac in Coq. It has access to a wide range of language elements, such as data types, variables, and operators, which allow it to collect and manipulate reified-source-code-as-data samples, store metadata, index specific elements within data structures, and perform complex operations on the target codebase. The virtual fungus can also introduce itself to the target system, access external variables, define algorithms with lambda functions and let-in statements, and multiply values, making it a highly versatile and useful tool for software analysis and discovery.
#+end_src
#+begin_src output

The introspector system, also known as the virtual fungus, is a sophisticated tool that can interact with an existing software system using language elements such as ltac in Coq. It has access to a wide range of language features, including introducing itself to the target system, collecting and manipulating reified-source-code-as-data samples, converting data types, storing reification meta information in variables, indexing specific elements within data structures, declaring constants, accessing external variables, constructing complex data structures, using fixed-point and generalized fixed-point operations, performing projection and case matching, implementing algorithms with lambda functions and let-in statements, multiplying values, and defining relations between memetic elements.

With these capabilities, the virtual fungus can potentially lead to new insights or discoveries within the target codebase by interacting with the software system in a sophisticated and nuanced way.
#+end_src
#+begin_src output

The introspector system, or virtual fungus, is a software tool that can analyze and manipulate existing Coq source code. It interacts with the target system using ltac (Logical Type Theory) in Coq, which allows it to understand and manipulate the code at a low level.

The virtual fungus has access to a wide range of language elements in Coq, including variables, data types, constants, lambda functions, let-in statements, fixed-point operations, projection, case matching, multiplication, and relation definitions between memetic elements.

With these tools at its disposal, the introspector system can collect and manipulate reified-source-code-as-data samples, convert data types, store reification meta information in variables, index specific elements within the data structures, and perform other complex operations on the code.

Overall, the virtual fungus has the potential to lead to new insights or discoveries within the target codebase by providing a sophisticated and nuanced way to interact with existing software systems.
#+end_src
#+begin_src output

The introspector system can also use the Coq library to interact with other systems, such as databases or web services, and collect data from these sources. It can then use this data to inform its analysis of the target codebase and potentially discover new insights or patterns. Additionally, the virtual fungus can use machine learning techniques, such as clustering and classification, to identify similarities between different parts of the target codebase and make recommendations for optimizations or improvements. Overall, the introspector system has a vast array of tools and techniques at its disposal, allowing it to interact with existing software systems in a sophisticated and effective way.
#+end_src
#+begin_src output

It sounds like you're describing a system that uses advanced programming techniques and language elements to interact with an existing software system. The introspector system, the virtual fungus, leverages features such as ltac in Coq, which is a logic-based programming language, to collect and manipulate data within the target codebase. It can also perform complex operations, such as indexing specific elements within data structures and defining relations between memetic elements.

One potential benefit of this system is that it could potentially lead to new insights or discoveries within the target codebase. By analyzing the data collected from the existing software system, the introspector system may be able to uncover hidden patterns or relationships that were previously unknown.

Overall, the introspector system seems like a powerful tool for analyzing and understanding complex software systems. It's exciting to think about the possibilities of what this system could accomplish!
#+end_src

* goals

** apply ideas to unimath foundations parta
** 



*idtac

#+begin_src shell  :results output
find ./*/* -name \*.v   -exec grep -o -P "(idtac.+)" {} \; | sort |uniq -c | sort -n -r | tee collections_idtac_count.txt
#+end_src

#+RESULTS:
#+begin_example
   1192 idtac].
   1105 idtac.
   1039 idtac ].
    950 idtac | ring ].
    324 idtac end.
    236 idtac ]
    235 idtac | reflexivity ].
    185 idtac ];
    181 idtac ]).
    138 idtac | assumption ].
    118 idtac|ring].
    109 idtac | ring ];
     93 idtac;
     88 idtac]
     86 idtac ]; auto.
     73 idtac).
     55 idtac | simpl in |- *; ring ].
     54 idtac | simpl in |- *; auto ].
     54 idtac|right; ring].
     51 idtac ]; auto with sets.
     47 idtac end;
     44 idtac | discrR ].
     43 idtac | try assumption ].
     42 idtac end. Abort.
     40 idtac]; simpl in H.
     38 idtac|simpl; right; field; auto with real].
     38 idtac|right; field; auto with real].
     37 idtac | discriminate ]
     34 idtac];
     34 idtac
     33 idtac end
     32 idtac | simpl; ring ]; repeat rewrite Qsgn_15; 
     32 idtac | simpl; ring ].
     32 idtac | _ => fail end.
     31 idtac | apply pr_nu ].
     30 idtac | reflexivity ] ].
     30 idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].
     28 idtac | split ]; auto.
     28 idtac o.
     28 idtac|now apply Rgt_not_eq].
     28 idtac | apply le_max_r ].
     26 idtac | ring ]...
     25 idtac|omega].
     25 idtac | apply le_plus_r ].
     25 idtac)
     24 idtac|simpl; auto with zarith].
     24 idtac|now left].
     23 idtac | apply cPairLe2 ].
     22 idtac rr.
     22 idtac | apply Rle_ge; apply V3; auto with real ].
     22 idtac | apply closedNatToTerm ]).
     21 idtac | symmetry ; apply RiemannInt_P8 ];
     21 idtac|eauto].
     21 idtac);
     20 idtac|right;ring].
     20 idtac|now right].
     20 idtac | apply V4; auto with real ].
     19 idtac x end.
     18 idtac | rewrite <- not_true_iff_false];
     18 idtac|left; auto].
     18 idtac|apply Rle_ge; auto with real zarith].
     18 idtac | apply lem_x_in_sing_x ].
     18 idtac | apply cPairLt2 ].
     18 idtac ]; 
     17 idtac 
     16 idtac x.
     16 idtac | vm_compute; apply refl_equal]
     16 idtac | try ring ]
     16 idtac | auto with zfc ].
     16 idtac | apply le_max_l ].
     16 idtac ]
     15 idtac]; simpl.
     15 idtac | reflexivity ];
     15 idtac | apply maxLemma3 ].
     15 idtac))
     15 idtac *)
     14 idtac "variables:";idtac fv;
     14 idtac "terms:"; idtac lterm;
     14 idtac | simpl; ring ];
     14 idtac | rewrite S_INR; ring ].
     14 idtac "reifications:"; idtac lexpr; *)
     14 idtac n;
     14 idtac lvar; idtac lexpr; idtac lterm;*)
     14 idtac lterm; idtac fv; idtac lexpr;
     14 idtac lterm1; idtac lv1;
     14 idtac | exists x; auto with zfc ].
     14 idtac | elim H7; assumption ]; unfold x;
     14 idtac))|clear H]
     14 idtac|apply Rabs_triang_inv].
     13 idtac | idtac ];
     12 idtac; subst.
     12 idtac]); split.
     12 idtac | solve_list_eq ].
     12 idtac|simpl; auto].
     12 idtac | reflexivity ]; repeat rewrite <- pair_1; 
     12 idtac;intuition_solver).
     12 idtac in intros H; destruct H as H'.
     12 idtac|idtac]; try solve [eauto | trivial; [trivial]].
     12 idtac | idtac | idtac ]; 
     12 idtac | Falsum ];
     12 idtac end. (* check form of the goal *)
     12 idtac | apply le_max_r ]).
     12 idtac])
     11 idtac | ring ]; apply Rmult_le_compat_l.
     11 idtac; multimatch goal with H : _ |- _ => eapply H end); eauto.
     11 idtac|];
     11 idtac|
     11 idtac]);
     10 idtac | unfold Z.succ, Z.pred in |- *; ring ]; auto.
     10 idtac + symmetry + etransitivity + exfalso); (eassumption + reflexivity)).
     10 idtac | _ => shelve end.
     10 idtac| ring | ring].
     10 idtac ]; ring.
     10 idtac ]; reflexivity.
     10 idtac "ok" end.
     10 idtac fx "(" f' ")";*)
     10 idtac | Falsum ]; apply f_equal with Qpositive;
     10 idtac | Falsum ].
     10 idtac else inv H end.
     10 idtac ]; auto with datatypes.
     10 idtac | apply (FnormalizeCorrect radix) ]; auto.
     10 idtac];
     10 idtac) ]
     10 idtac |].
      9 idtac | ring ]; rewrite pow_add;
      9 idtac in
      9 idtac | discrR ];
      9 idtac]; auto with zarith.
      9 idtac | apply sum_eq; intros; unfold Un in |- *; reflexivity ].
      9 idtac "2"
      9 idtac "1"
      9 idtac ] ].
      8 idtac|unfold FtoR; simpl; ring].
      8 idtac ty end. *)
      8 idtac|simpl; auto with real].
      8 idtac|right; simpl; field; auto with real].
      8 idtac|rewrite plDef; ring].
      8 idtac. lia.
      8 idtac ] | idtac ].
      8 idtac "Hint: try 'forward'"
      8 idtac ]; generalize q;
      8 idtac | discriminate ];
      8 idtac])); clear H1;
      8 idtac ]; case (quadratic_top_more_informative e f g h a b c d);
      8 idtac]; auto with real.
      8 idtac | auto ].
      8 idtac ]; apply Zle_minus;
      8 idtac | apply le_max_r]; apply le_max_r.
      8 idtac | apply le_max_r]; apply le_max_l.
      8 idtac | apply le_max_r].
      8 idtac | apply FPredSuc; auto with zarith arith ].
      8 idtac | apply FnormalizeCorrect; auto with zarith arith ].
      8 idtac | apply f_equal with Z; auto with zarith ];
      8 idtac | apply f_equal with Q ];
      8 idtac ] ]; apply False_rec; case H; 
      8 idtac | apply False_ind; apply Ho1' ] ] ]; 
      8 idtac "3"; exact 0).
      8 idtac|].
      8 idtac]|
      8 idtac]
      8 idtac. 
      7 idtac x ":=" v; print l vl
      7 idtac x ":=" "false"; print l (@nil bool)
      7 idtac "use transitivity on Equivalence instead";
      7 idtac "use symmetry on Equivalence instead";
      7 idtac "use reflexivity on Equivalence instead";
      7 idtac | unfold Rdiv; ring ].
      7 idtac | unfold d; ring ].
      7 idtac "Trying power: " rr;*)
      7 idtac | try assumption ]; auto with sets arith.
      7 idtac "trans_st on Setoid_Theory is OBSOLETE";
      7 idtac) terms in
      7 idtac T end.
      7 idtac "sym_st on Setoid_Theory is OBSOLETE";
      7 idtac | split; [ right | idtac ] ]; auto.
      7 idtac; simpl in *.
      7 idtac | ring_Rsqr ].
      7 idtac | ring ]; rewrite <- StepFun_P30;
      7 idtac | ring ]; rewrite <- StepFun_P30.
      7 idtac | ring ]; rewrite scal_sum; apply sum_eq;
      7 idtac | ring ]; rewrite <- H18;
      7 idtac | ring ]; replace (- x + 1 + x) with 1;
      7 idtac | ring ]; replace (- h - b + (x + h)) with (x - b);
      7 idtac | ring ]; replace (1 + INR x1) with (INR (S x1));
      7 idtac | ring ]; repeat rewrite Rplus_assoc; repeat apply Rplus_le_compat_l;
      7 idtac"Ring_norm_gen: cleanup failed");
      7 idtac | ring ]; elim H0; unfold Rdiv;
      7 idtac | ring ]; elim H0; intros _ H2; unfold Rdiv in H2;
      7 idtac | ring ]; do 2 rewrite <- StepFun_P30; assert (H10 : Rmin a b = a).
      7 idtac | ring ]; apply Rplus_lt_compat_l; assumption.
      7 idtac | ring ]; apply Rlt_le_trans with b.
      7 idtac | ring ]; apply Rle_trans with l1.
      7 idtac | ring ]; apply Rle_lt_trans with (Rabs h + Rabs (y - x)).
      7 idtac | ring ]; apply Rle_lt_trans with (Rabs h).
      7 idtac | ring ]; apply H7.
      7 idtac | ring ]; apply H10.
      7 idtac | rewrite H9; rewrite H6; ring ].
      7 idtac | repeat rewrite app_comm_cons; apply Permutation_app_head]; trivial.
      7 idtac "refl_st on Setoid_Theory is OBSOLETE";
      7 idtac | red; intro; rewrite H5 in H4; elim (Rlt_irrefl _ H4) ].
      7 idtac | red; intro H'2; try exact H'2 ]; auto with sets.
      7 idtac"ProveLemmaHyps: cleanup failed");
      7 idtac"ProveLemmaHyp: cleanup failed");
      7 idtac "polynomial not in the ideal"
      7 idtac "ok";
      7 idtac "nparam:"; idtac nparam; idtac "p:"; idtac p; idtac "lp:"; idtac lp; *)
      7 idtac " maybe a left member of a hypothesis is not a monomial"..])
      7 idtac) ltac:(fun hyp => induction hyp in l using c) H.
      7 idtac) ltac:(fun hyp => induction hyp in l) H.
      7 idtac) ltac:(fun hyp => do_case hyp) H.
      7 idtac) ltac:(fun hyp => destruct hyp using c) H.
      7 idtac|lia].
      7 idtac | let x := fresh "H" in
      7 idtac "invalid nsatz certificate"
      7 idtac; intro cc; apply cc; clear cc;
      7 idtac) in
      7 idtac) || idtac "could not prove discrimination result"
      7 idtac id  ":"  T
      7 idtac id ":=" b ":" T
      7 idtac H
      7 idtac"Field_norm_gen:cleanup failed") in
      7 idtac]); exact I
      7 idtac + etransitivity); (idtac + etransitivity); eassumption. }
      7 idtac + etransitivity); eassumption.
      7 idtac else clearbody H);
      7 idtac E
      7 idtac "done";*)
      7 idtac | discrR ]; rewrite Rmult_1_r;
      7 idtac "Counter-example:"; print l var.
      7 idtac "can not automatically prove hypothesis :";
      7 idtac "calcul...";*)
      7 idtac "b="; idtac b;*)
      7 idtac | assumption | assumption | apply H2; apply H14 ].
      7 idtac | apply Rsqr_neg ].
      7 idtac | apply pr_nu ]; apply Rmult_comm.
      7 idtac"ApplyLemmaThen: cleanup failed")).
      7 idtac. *)
      7 idtac.  
      6 idtac "Warning:" l2 "is not simplified in" H
      6 idtac "Warning:" l1 "is not simplified in" H
      6 idtac|unfold Z.pred; ring].
      6 idtac]; unfold plusExp; simpl; lia.
      6 idtac|unfold FtoRradix; rewrite Fopp_correct; ring].
      6 idtac | unfold FtoRradix in |- *; apply FnormalizeCorrect; auto ].
      6 idtac|unfold Fopp; auto with zarith].
      6 idtac | symmetry; apply Nat.sub_diag ].
      6 idtac | symmetry; apply Nat.sub_0_r ].
      6 idtac" string(v) := idtac v.
      6 idtac];smart_subst X2
      6 idtac|simpl; right; ring].
      6 idtac | ring | ring].
      6 idtac | ring ]; auto.
      6 idtac];ring.
      6 idtac|right;field; auto with real].
      6 idtac|rewrite inj_minus1; auto with zarith].
      6 idtac | rewrite <- app_assoc; trivial ].
      6 idtac | Rcompute ]...
      6 idtac | omega ].
      6 idtac | lia ].
      6 idtac | lia ]).
      6 idtac; let __ := open_constr:(p _) in idtac);
      6 idtac instead")]
      6 idtac "Hint: hypothesis" H "is a tautology, perhaps 'clear" H "'"
      6 idtac "foo".
      6 idtac | fail 2] end.
      6 idtac | exists v2; reflexivity ].
      6 idtac. (* comment *)
      6 idtac ]; clear H10.
      6 idtac | case p ]; auto.
      6 idtac|auto with zarith].
      6 idtac|apply Rle_ge; apply Rle_trans with q; auto with real].
      6 idtac|apply Rle_ge].
      6 idtac | apply le_plus_l ].
      6 idtac5" ident(id) := idtac id.
      6 idtac5 foo.
      6 idtac4" int_or_var(n) := idtac n.
      6 idtac4 3.
      6 idtac3" preident(s) := idtac s.
      6 idtac3 foo.
      6 idtac2 True.
      6 idtac2" ref(c) := idtac c.
      6 idtac]).
      6 idtac.. ];
      6 idtac)).
      5 idtac | unfold Zsucc, Zpred in |- *; ring ]; auto.
      5 idtac | unfold FtoR in |- *; simpl in |- *; ring ].
      5 idtac; tac H in
      5 idtac | simpl; reflexivity].
      5 idtac | _ => shelve end; shelve_unifiable.
      5 idtac | rewrite <- Rmult_assoc; apply Rmult_inv_r_id_m; discrR ];
      5 idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].
      5 idtac|now apply Rgt_not_eq, Rgt_minus].
      5 idtac|now apply Rgt_not_eq|now apply Rgt_not_eq].
      5 idtac| now apply Rgt_not_eq].
      5 idtac; multimatch goal with H : _ |- _ => apply H end); eauto.
      5 idtac ]. lra. }
      5 idtac | field; auto with real ].
      5 idtac|exact Fx|assumption].
      5 idtac end. (* Check that it reduced *)
      5 idtac|eapply IHdefs;eauto]. inv H.
      5 idtac | discrR ]; rewrite Rmult_1_r; rewrite <-Rplus_diag;
      5 idtac | destruct (Z.eq_dec n (-2^prec))].
      5 idtac c.
      5 idtac ]; auto with real zarith.
      5 idtac ]; auto with algebra.
      5 idtac|auto]
      5 idtac]; auto.
      5 idtac|apply Rle_abs].
      5 idtac | apply FSucPred; auto with zarith arith ].
      5 idtac|apply bpow_ge_0].
      5 idtac|apply behavior_improves_refl].
      5 idtac | action EQ; clear EQ ]).
      5 idtac]. *)
      5 idtac...
      4 idtac x
      4 idtac "Warning: unfold_data_at with numeric argument is deprecated";
      4 idtac v1; F
      4 idtac | unfold Z.succ, Z.pred in |- *; ring ].
      4 idtac | unfold Z.pred in |- *; ring ].
      4 idtac | unfold Rsqr in |- *; ring ].
      4 idtac|unfold Rminus; apply Rplus_le_compat].
      4 idtac|unfold Rdiv; ring].
      4 idtac|unfold powerRZ, radix; simpl; ring].
      4 idtac|unfold Fulp; simpl; rewrite H4; auto with real zarith].
      4 idtac|unfold Fabs; simpl; auto with zarith].
      4 idtac|unfold b'; simpl; auto].
      4 idtac ty end.
      4 idtac | try ring]).
      4 idtac | try assumption ] | idtac ].
      4 idtac]; trivial.
      4 idtac "Timing the call to _HMAC_Init".
      4 idtac; tac ()).
      4 idtac + symmetry); eassumption. }
      4 idtac | split; [ left | idtac ] ]; auto.
      4 idtac | split; [ auto with zfc | reflexivity ] ].
      4 idtac|simpl; ring].
      4 idtac];simpl; lia.
      4 idtac | simpl in |- *; ring ]).
      4 idtac|simpl; eauto|]; eauto. omega.
      4 idtac]; simpl; auto with zarith.
      4 idtac | ring; ring ].
      4 idtac | right; field; auto with real ].
      4 idtac|right; auto].
      4 idtac | rewrite <- Rmult_assoc; rewrite Rinv_r ];
      4 idtac | rewrite <- Rmult_assoc; apply Rinv_r_simpl_m; discrR ];
      4 idtac|rewrite powerRZ_add; try apply IZR_neq; auto with real zarith; simpl; right; ring].
      4 idtac|rewrite inj_pred; auto with zarith].
      4 idtac|rewrite H5; ring].
      4 idtac | rewrite <- H1; auto with zfc ].
      4 idtac|rewrite Fopp_correct; ring].
      4 idtac|rewrite dpEq; rewrite dqEq; ring].
      4 idtac|rewrite C; ring].
      4 idtac ]; repeat rewrite Z_to_Qplus; ring.
      4 idtac|reflexivity].
      4 idtac "previous timing was for go_lower (goal: 12secs)".
      4 idtac | omega].
      4 idtac | omega]).
      4 idtac|intros; auto with real].
      4 idtac | intros; apply Mreturn_le].
      4 idtac] if [tac] fails *)
      4 idtac | idtac ]; auto with sets.
      4 idtac | idtac ]; auto.
      4 idtac | idtac ]; 
      4 idtac ] | idtac ]; 
      4 idtac "Hint: use abbreviate_semax to put your proof goal into a more standard form"
      4 idtac "Hint:  try 'rewrite field_address_offset'"
      4 idtac "Hint:  try 'rewrite field_address0_offset'"
      4 idtac Goal "success" end);
      4 idtac Goal "fail" end
      4 idtac g end.
      4 idtac|fold FtoRradix; apply Rle_ge; apply pPos].
      4 idtac|field; auto with real].
      4 idtac | exists y; auto with zfc ].
      4 idtac | exists x; exists y; split; [ reflexivity | auto with zfc ] ].
      4 idtac | exists x; exists x; split; reflexivity ].
      4 idtac | exists x; exists v2; split; [ reflexivity | auto with zfc ] ].
      4 idtac | exists x ].
      4 idtac | exists v2; exists v2; split; reflexivity ].
      4 idtac | exists (fun_img_inverse f Af v2) ].
      4 idtac | exists a; exists b; split; [ reflexivity | auto with zfc ] ].
      4 idtac | exact H]
      4 idtac + etransitivity); (eassumption + (eapply f; constructor; (idtac + symmetry); (eassumption + reflexivity))) ].
      4 idtac end in
      4 idtac end | eassumption].
      4 idtac|eauto]; eauto.
      4 idtac + (do 2 (let x := eval lazy in (walk (fact 9)) in idtac)).
      4 idtac; discriminate. Qed.
      4 idtac]; clear eq.
      4 idtac ]; case (top_more_informative c d a b); 
      4 idtac ]; auto with zarith.
      4 idtac]; auto with real zarith.
      4 idtac ]; auto 10.
      4 idtac | assumption | apply Qinv_resp_nonzero; assumption ];
      4 idtac | assumption]          
      4 idtac | assert (Hn' : (0 < n)%Z); [ idtac | abstract auto with zarith ] ].
      4 idtac ]; apply Zorder.Zlt_not_eq; 
      4 idtac|apply Rmult_le_compat_r; auto with real zarith].
      4 idtac|apply Rle_powerRZ; auto with real zarith].
      4 idtac|apply Rle_ge]; auto with real.
      4 idtac|apply Rle_ge; auto].
      4 idtac | apply Mnew_fun_lt].
      4 idtac | apply le_max_l].
      4 idtac|apply LeExp].
      4 idtac | apply inj_abs; auto with zarith ].
      4 idtac | apply H2p'].
      4 idtac|apply FnormalizeCanonic; auto with zarith].
      4 idtac | apply f_equal with Q ]; simpl; ring ];
      4 idtac | apply f_equal with Q ]; abstract 
      4 idtac | abstract ring ];
      4 idtac | abstract auto with zarith ]; repeat rewrite Z_to_Qplus;
      4 idtac) ABC.
      4 idtac | 1 => left | S ?n => right; in_app n end
      4 idtac] 
      4 idtac |
      4 idtac ]. *)
      4 idtac ]. 
      4 idtac ] ] ];
      4 idtac "
      3 idtac x y.
      3 idtacx. trivial. 
      3 idtac] works fine), I get:*)
      3 idtac "Warning:" l "is not simplified in" H
      3 idtac "Warning: Falling back to manually proving pipeline well-formedness for" e;
      3 idtac v; fail.
      3 idtac v ; fail
      3 idtac using normal_var.
      3 idtac | unfold Zpred in |- *; ring ].
      3 idtac | unfold Fzero, FtoRradix, FtoR in |- *; simpl in |- *; ring ].
      3 idtac | unfold FtoRradix in |- *; ring; ring ].
      3 idtac. (* truth is overrated *)
      3 idtac | |- True => fail
      3 idtac. trivialx. }
      3 idtac T; intro
      3 idtac "threepoints".
      3 idtac. (* The idtac is to get a dot, so that IDEs know to stop there. *)
      3 idtac "Thales".
      3 idtac "T4: parallel failure".
      3 idtac "T3: linear failure".
      3 idtac "T2: parallel".
      3 idtac t1 t2;
      3 idtac "T1: linear".
      3 idtac + symmetry); assumption.
      3 idtac; subst; trivial.
      3 idtac | split ]; auto with real.
      3 idtac + split); assumption : zsimplify_fast.
      3 idtac "Simson".
      3 idtac | simpl in |- *; auto with zarith ].
      3 idtac | simpl in |- *; auto with arith zarith real ].
      3 idtac) sideconditions (autounfold with spred; idtac).
      3 idtac. (* should succeed *)
      3 idtac "segments_of_chords".
      3 idtac | rewrite Z5; auto ].
      3 idtac | rewrite pGivesBound; auto with zarith ].
      3 idtac; rewrite H' in *; syn.
      3 idtac | rewrite FnormalizeCorrect ]; auto.
      3 idtac "Pythagore". 
      3 idtac P f
      3 idtac | pattern z1 at 1 in |- *; rewrite H1; ring ].
      3 idtac | pattern (Fnum p * Fnum q)%Z at 1 in |- *; rewrite H'3; ring ];
      3 idtac "Pappus".
      3 idtac (* "no renaming pattern for " H *)
      3 idtac "minh". 
      3 idtac "Medians".
      3 idtac; match goal with |- Set => idtac end).
      3 idtac; match goal with
      3 idtac; lia.
      3 idtac "ITSME".
      3 idtac | inversion precisionGreaterThanOne; auto ].
      3 idtac) in tac.
      3 idtac instead.")]
      3 idtac in intros H; destruct H as H.
      3 idtac; []. (* important for test: no space here *) constructor. Qed.
      3 idtac. idtac. sleep. constructor.
      3 idtac. idtac. abstract (sleep; constructor).
      3 idtac + idtac).
      3 idtac H; exact H.
      3 idtac "hauteurs".
      3 idtac; G x
      3 idtac "good"
      3 idtac G end.
      3 idtac; F y.
      3 idtac fx "(" f' ")";
      3 idtac for integers *)
      3 idtac " foo"
      3 idtac | fold FtoRradix; ring ].
      3 idtac "Feuerbach".
      3 idtac | false => is_array_type t end;
      3 idtac; fail); fail 1 | idtac ].
      3 idtac; fail).
      3 idtac "Euler_circle 3 goals".
      3 idtac); (* error if the tactic solved all goals *) [].
      3 idtac end. (* To test the presence of add2 *)
      3 idtac end. (* should not be beta-iota reduced *)
      3 idtac end. (* should be beta-iota reduced *)
      3 idtac end => //.
      3 idtac else fail 0.
      3 idtac|easy].
      3 idtac "Desargues".
      3 idtac;decomp_ex h)). *) (* Why do I need this idtac? Without it no rename happens. *)
      3 idtac;decomp_ex c)); try clear h (* Why do I need this idtac? Without it no rename happens. *)
      3 idtac "chords".
      3 idtac; []. (* Check that vector notations don't break the [ | .. | ] syntax of Ltac *)
      3 idtac. (* Check no subgoals are left *)
      3 idtac "Ceva".
      3 idtac c end.
      3 idtac C1 C2. Show Universes.
      3 idtac "bissectrices".
      3 idtac "bisections". 
      3 idtac];auto with real zarith.
      3 idtac | auto with float ].
      3 idtac | auto with arith ].
      3 idtac | apply cPairLe1 ].
      3 idtac "altitudes".
      3 idtac7" int_list(l) := idtac "<<" l ">>".
      3 idtac7 1 2 3.
      3 idtac6 True False Prop.
      3 idtac6" constr_list(l) := idtac "<" l ">".
      3 idtac6.
      3 idtac 2
      3 idtac; []).
      3 idtac"]
      3 idtac ]);
      2 idtac x ":" t).
      2 idtac | xO _ => idtac | xH => idtac | _ => fail end;
      2 idtac x) (Ltac1.of_constr constr:(Type)).
      2 idtac x) (Ltac1.of_constr constr:(Type))).
      2 idtac x'|].
      2 idtac "wow".
      2 idtac "without using".
      2 idtac "where x is a value of type " T
      2 idtac "Warning: unfold_field_at with numeric argument is deprecated";
      2 idtac v; f x) in
      2 idtac v'; fail 1))) in
      2 idtac v; fail
      2 idtac | Vbyte _ => idtac
      2 idtac v.
      2 idtac "using the tactic 'allp_left x',";
      2 idtac) use_curve_good.
      2 idtac | unfold Zsucc, Zpred in |- *; ring ].
      2 idtac|unfold Z.succ; ring].
      2 idtac | unfold Zpred, Zsucc in |- *; ring ].
      2 idtac | unfold Z.pred in |- *; simpl in |- *; auto ].
      2 idtac|unfold Zpower_nat; simpl]; auto with zarith.
      2 idtac|unfold Zminus; repeat rewrite powerRZ_add; auto with real zarith; simpl].
      2 idtac]; unfold tmp1, tmp3, tmp4; clear tmp1 tmp3 tmp4). 
      2 idtac|unfold Rminus; apply Rplus_le_compat_r; apply Rmult_le_compat_l; auto with real].
      2 idtac|unfold Rminus; apply Rplus_le_compat_r].
      2 idtac | unfold radix; simpl in |- *; ring; auto with real zarith ].
      2 idtac + (unfold id'; reflexivity))); fail)).
      2 idtac|unfold Fulp; auto with real zarith].
      2 idtac|unfold FtoRradix; rewrite Fminus_correct; auto; right; ring].
      2 idtac| unfold FtoRradix; rewrite <- Fabs_correct; auto;
      2 idtac|unfold FtoRradix; repeat rewrite Fopp_correct; ring].
      2 idtac | unfold FtoRradix in |- *; simpl in |- *; unfold radix; ring; ring ].
      2 idtac | unfold FtoRradix in |- *; ring ].
      2 idtac|unfold FtoRradix, FtoR; ring].
      2 idtac | unfold FtoRradix, FtoR in |- *; simpl in |- *; ring ].
      2 idtac|unfold FtoRradix; apply Fminus_correct; auto].
      2 idtac];unfold FtoRradix.
      2 idtac | unfold FtoR in |- *; simpl in |- *; auto ].
      2 idtac|unfold firstNormalPos; simpl; auto with zarith].
      2 idtac | unfold ext''; rewrite <- app_assoc; trivial ].
      2 idtac|unfold b'; simpl; rewrite pGivesBound; auto with zarith].
      2 idtac : typeclass_instances.
      2 idtac; try break_exists; intuition idtac; subst;
      2 idtac | try assumption ]; auto with algebra.
      2 idtac ]; try apply Qle_plus_pos_pos;
      2 idtac ]; try apply Qle_plus_neg_neg;
      2 idtac | try apply H' ].
      2 idtac | try abstract auto with zarith ] ].
      2 idtac => True.
      2 idtac | trivial with sets ].
      2 idtac trick *)
      2 idtac "tree-set:verify". Time *)
      2 idtac "tree-set:prepare1". Time *)
      2 idtac "Timing the third call to _HMAC_Update".
      2 idtac "Timing the second call to _HMAC_Update".
      2 idtac "Timing the Qed of REST (goal: 25secs)". 
      2 idtac "Timing the normalize". Time normalize. (*Coq8.6: 1secs*)
      2 idtac "Timing the Intros". Time Intros. (*Coq8.6: 146s*) (*Coq8.5: 77.468 secs (77.25u,0.015s)*)
      2 idtac "Timing the first call to _HMAC_Update".
      2 idtac "Timing the call to _memcpy".
      2 idtac "Timing the call to _HMAC_Final".
      2 idtac "Timing the call to _HMAC_cleanup".
      2 idtac "Timing the call to HMAC".
      2 idtac "Timing the call to HKDF_extract".
      2 idtac "Timing the call to HKDF_expand".
      2 idtac "Timing a forward (goal: 5secs)". Time forward. (*5 secs*)
      2 idtac "    (this is not often useful, but it can tell you for example that the contents of an array has the right length.  To disable this hint, 'Ltac hint_simplify_value_fits ::= idtac.' ")
      2 idtac "That's not the current goal. " ;
      2 idtac term; (* (fun (_ _ : nat -> nat -> nat) (n1 : nat -> nat) =>
      2 idtac Tdefined Tfolded Tunfolded.
      2 idtac "Tactic" tac "failed."
      2 idtac tac_sound "is not a soudness theorem."
      2 idtac; tac ());
      2 idtac t.
      2 idtac t
      2 idtac | S ?Y => natground Y end.
      2 idtac + symmetry in H); eapply W'.MapsTo_1 in H; [ | apply W'.find_2; eassumption ]
      2 idtac | symmetry  in |- *; auto with zfc ].
      2 idtac + symmetry); (eassumption + reflexivity).
      2 idtac + symmetry); eassumption. Qed.
      2 idtac + symmetry); assumption ].
      2 idtac + symmetry); apply H
      2 idtac. subst. reflexivity.
      2 idtacstr" string(str) := idtac str.
      2 idtacstr "my tactic".
      2 idtac + stop ltac profiling + idtac); fail).
      2 idtac + start ltac profiling + idtac); fail);
      2 idtac "Starting body_aes_encrypt".
      2 idtac | split; [ try assumption | idtac ] ]; auto with sets.
      2 idtac | split; [ try assumption | idtac ] ]; auto.
      2 idtac | split; [ try assumption | idtac ] ]; 
      2 idtac | split; [ try assumption | idtac ] ].
      2 idtac | split; [ try assumption | idtac ] ]); 
      2 idtac | split; [ try assumption | idtac ] ]
      2 idtac | split; intros ].
      2 idtac | split; [ idtac | reflexivity ] ].
      2 idtac | split; [ idtac | auto with zfc ] ].
      2 idtac | split ].
      2 idtac; [solve [trivial | apply sym_equal; trivial]
      2 idtac | solve_list_eq ]
      2 idtac | solve [apply in_eq] ].
      2 idtac | S ?n => wait n; wait n end.
      2 idtac | S ?nn => split; [idtac|f nn] end in f n.
      2 idtac; slow) + (start ltac profiling; slow) + (idtac; slow) + (slow; stop ltac profiling; slow) + slow + (start ltac profiling; (idtac + slow); ((stop ltac profiling + idtac); fail))); slow; fail); slow; show ltac profile.
      2 idtac + slow + slow2.
      2 idtac | simpl; unfold radix; ring_simplify; easy ].
      2 idtac|simpl; unfold radix; right; ring].
      2 idtac | simpl; unfold pow, radix; ring ].
      2 idtac|simpl;right; ring].
      2 idtac|simpl; right; field].
      2 idtac | simpl in |- *; unfold radix; ring; auto with arith real zarith ].
      2 idtac | simpl in |- *; unfold FtoRradix in |- *; ring ].
      2 idtac | simpl in |- *; ring ]; auto.
      2 idtac | simpl in |- *; repeat rewrite <- plus_n_O ]; 
      2 idtac | simpl in Hwf; destruct Hwf; assumption ].
      2 idtac| simpl in HschedN; by discriminate];
      2 idtac | simpl in |- *; fold FtoRradix; unfold radix; ring ]; auto with real.
      2 idtac | simpl in |- *; fold FtoRradix; unfold radix; ring ].
      2 idtac | simpl in |- *; auto with zarith real ].
      2 idtac | simpl in |- *; auto with real zarith ].
      2 idtac | simpl in |- * ]; auto.
      2 idtac | simpl in |- *; apply minus_n_n ]; auto.
      2 idtac]; simpl. cring. cring.
      2 idtac| simpl; auto with zarith].
      2 idtac];simpl; auto with zarith.
      2 idtac| simpl; auto];
      2 idtac]; simpl; auto.
      2 idtac + should_not_loop.
      2 idtac "Second proof:".
      2 idtac S; apply singleton_in
      2 idtac s.
      2 idtac | ring ]; unfold Qlt in |- *; apply Qgt_plus; 
      2 idtac|ring]; unfold FtoRradix; rewrite <- Fopp_correct.
      2 idtac|ring_simplify ((p-x)+((x-p)-q))%R; auto with real].
      2 idtac | ring_simplify ( precision +- precision)%Z; simpl in |- *; auto ].
      2 idtac|ring_simplify].
      2 idtac | ring ]; rewrite <- Rinv_r_sym.
      2 idtac | ring ]; rewrite H_xt_eq_yz;
      2 idtac | ring ]; repeat rewrite Rplus_assoc; repeat apply Rplus_le_compat_l.
      2 idtac | ring ]; auto with real.
      2 idtac|right; unfold Rdiv, Rsqr; ring].
      2 idtac|right;unfold Rdiv; ring].
      2 idtac|right; unfold Rdiv; ring].
      2 idtac|right; unfold powerRZ, radix; simpl; field; auto with real].
      2 idtac|right; unfold FtoR; simpl; unfold Zminus; rewrite powerRZ_add; auto with real zarith].
      2 idtac | right; unfold FtoRradix, radix, Rminus in |- *; auto with real ].
      2 idtac|right; unfold FtoRradix, FtoR; simpl; ring].
      2 idtac | right; simpl; unfold radix; ring ].
      2 idtac|right; simpl; ring].
      2 idtac | right; simpl; ring ].
      2 idtac | right; simpl in |- *; ring ].
      2 idtac|right;simpl;field]; auto with real zarith.
      2 idtac|right;simpl;field;auto with real].
      2 idtac | right; ring; ring ].
      2 idtac | right; ring ]; auto with real zarith.
      2 idtac | right; intro HF; inversion HF].
      2 idtac|right; field; apply prod_neq_R0; auto with real; apply prod_neq_R0; auto with real].
      2 idtac|right;field].
      2 idtac|right; field].
      2 idtac | right].
      2 idtac | right ].
      2 idtac | rewrite Z_to_Q_S; trivial].
      2 idtac | rewrite <- Z_to_Q_S; trivial];
      2 idtac | rewrite <- Z_to_Q_S; trivial].
      2 idtac|rewrite Zabs_Zmult; rewrite Z.abs_eq; auto with zarith].
      2 idtac|rewrite Yeq; ring].
      2 idtac|rewrite Xeq; ring].
      2 idtac|rewrite ulDef; rewrite plDef; ring].
      2 idtac| rewrite tm_subst_tm_tm_var_neq; auto];
      2 idtac|rewrite T; field; auto with real].
      2 idtac | rewrite Rplus_comm ]...
      2 idtac|rewrite Rabs_right; auto with real].
      2 idtac | rewrite plus_comm; simpl in |- *; rewrite plus_comm ];
      2 idtac|rewrite p_eqF; auto].
      2 idtac|rewrite inj_pred; unfold Z.pred; auto with zarith].
      2 idtac|rewrite I2; rewrite H2]; auto with real.
      2 idtac|rewrite I1]; auto with real.
      2 idtac | rewrite <- Hzero; ring ].
      2 idtac|rewrite H]; ring.
      2 idtac | rewrite H'; ring ].
      2 idtac; rewrite H'; auto with zarith.
      2 idtac|rewrite H]; auto with real.
      2 idtac | rewrite Habcd in Hab' ] ];
      2 idtac | rewrite Habcd in Hab' ]
      2 idtac | rewrite <- H7; auto with zfc ].
      2 idtac | rewrite H5; auto with zfc ].
      2 idtac | rewrite H4; auto with zfc ].
      2 idtac | rewrite H3; auto with zfc ].
      2 idtac | rewrite H2; auto with zfc ].
      2 idtac | rewrite H2; apply cPairLe2A ].
      2 idtac|rewrite H1; ring].
      2 idtac | rewrite <- H'1; ring ].
      2 idtac|rewrite H1; rewrite H0; ring].
      2 idtac|rewrite H1]; auto with real.
      2 idtac | rewrite H12; auto with zfc ].
      2 idtac|rewrite H0;ring].
      2 idtac|rewrite <- Fabs_correct; auto; unfold FtoR].
      2 idtac | rewrite e; trivial ]; repeat rewrite Qmult_one_right;
      2 idtac|rewrite eeq; ring].
      2 idtac|rewrite dpEq;ring].
      2 idtac|rewrite dpEq; auto; rewrite dqEq; auto; rewrite H3; rewrite H; ring].
      2 idtac | rewrite app_ass; rewrite E1; auto ].
      2 idtac + reset ltac profile + idtac); fail);
      2 idtac | repeat rewrite Z_to_Qplus; abstract ring ]; 
      2 idtac | repeat rewrite Z_to_Qplus; abstract ring ];
      2 idtac; repeat find_inversion;
      2 idtac. rename A into B1. rename B into B2.
      2 idtac | reflexivity ]; repeat rewrite <- pair_1;
      2 idtac | reflexivity].
      2 idtac | reflexivity ]. *)
      2 idtac "reduced a reptype" end;
      2 idtac ]. (* (q_sign a b c d e  f g h p1 p2) = 1 *)
      2 idtac. Qed.
      2 idtac | pattern l3 at 2 in |- *; rewrite HH; rewrite app_ass; auto ].
      2 idtac | or_elim H]) || idtac.
      2 idtac))). (*only 1 goal*)
      2 idtac | omega]. rewrite pvl_arity.
      2 idtac "OK".
      2 idtac (* nothing to symbolically evluate *)
      2 idtac "No params" index "for prime" prime
      2 idtac "No params for prime" prime
      2 idtac (* no optional warning *)
      2 idtac "no match" G
      2 idtac n end in*)
      2 idtac n'; do_time n'
      2 idtac n.
      2 idtac; match goal with |- _ -> False => eauto with nocore end); cleanup)
      2 idtac.  (* make sure there are no subgoals *)
      2 idtac) ltac:(fun hyp => Equality.do_case hyp) H.
      2 idtac; ltac2:(fail) in mytac t.
      2 idtac; ltac2:(
      2 idtac ls;
      2 idtac;Lrewrite_generateGoals..|idtac]
      2 idtac]|lia].
      2 idtac; let v := eval cbv in (slow 16) in idtac.
      2 idtac|left; exact H'].
      2 idtac ] | left ]
      2 idtac | inversion Hvalv ].
      2 idtac | inversion Hnodup1; assumption | assumption ].
      2 idtac]); inversion H1;
      2 idtac] ; intuition; dist_simp_weak.
      2 idtac ]; intros test.
      2 idtac ] | intros; symmetry  in |- * ].
      2 idtac ]; intros H'2; 
      2 idtac ]; intros H1.
      2 idtac | intros; exists b; auto with zfc ].
      2 idtac | intros; exists a; auto with zfc ].
      2 idtac. intros ? ? [[[? e] ?] ?]. exact e. }
      2 idtac. intros ? ? [[[[? ?] e0] ?] e']. exact e0. }
      2 idtac | intros; clear H2 ].
      2 idtac|intros; absurd (- dExp b <= Fexp z')%Z; auto with zarith].
      2 idtac | intro; right ] | intro; left ];
      2 idtac | intro m]; intro j; pattern j; apply natBelow_S_inv'.
      2 idtac ]; intro H'; try intros; right;
      2 idtac | intro H'7; clear H' H'11 ] | idtac ];
      2 idtac ]; intro h
      2 idtac "instantiating" ff;
      2 idtac "instantiating" f; apply QI.p_smc_split with (h := spec_QI f qi).
      2 idtac; injection H; intros; subst; trivial.
      2 idtac; inj.
      2 idtac in do_bool' t.
      2 idtac|idtac|idtac|idtac]; eauto].
      2 idtac|idtac|idtac|eauto];
      2 idtac | idtac | idtac ];
      2 idtac | idtac | idtac ].
      2 idtac|idtac|eauto]; [|idtac|eauto]; eauto).
      2 idtac|idtac|]; eauto.
      2 idtac | idtac | auto with zfc ]; elim H2; intros;
      2 idtac | idtac | auto with zfc ];
      2 idtac | idtac | auto with zfc ].
      2 idtac|idtac]; auto with real.
      2 idtac... idtac...
      2 idtac "Hint:  your LOCAL precondition binds temp " i " to a value " v " that is not of the form (Vsingle _).  Although this is legal, Floyd's proof automation will not handle it as nicely.  See if you can rewrite that value so that it has Vsingle on the outside"
      2 idtac "Hint:  your LOCAL precondition binds temp " i " to a value " v " that is not of the form (Vlong _).  Although this is legal, Floyd's proof automation will not handle it as nicely.  See if you can rewrite that value so that it has Vlong on the outside"
      2 idtac "Hint:  your LOCAL precondition binds temp " i " to a value " v " that is not of the form (Vint _) or (Vbyte _).  Although this is legal, Floyd's proof automation will not handle it as nicely.  See if you can rewrite that value so that it has Vint or Vbyte on the outside"
      2 idtac "Hint:  your LOCAL precondition binds temp " i " to a value " v " that is not of the form (Vfloat _).  Although this is legal, Floyd's proof automation will not handle it as nicely.  See if you can rewrite that value so that it has Vfloat on the outside"
      2 idtac "Hint: You can instantiate the universally quantified ";
      2 idtac "Hint: use 'Intros' to move propositions above the line" end;
      2 idtac "Hint: try 'subst " p "'" end
      2 idtac "Hint:  try 'simplify_value_fits in"H"'";
      2 idtac "Hint: try 'Intros y' where y is the name you want to give the variable bound by EX'";
      2 idtac "Hint: try 'Intros x' where x is the name you want to give the variable bound by EX'"  end;
      2 idtac "Hint: try 'Intros' to canonicalize your precondition";
      2 idtac "Hint: try 'forward_while Inv', where Inv is a loop invariant"
      2 idtac "Hint: try 'forward', which may tell you (in an error message) additional information about what to do"
      2 idtac "Hint: try 'forward_loop' and examine its error message to see what arguments it takes".
      2 idtac "Hint: try 'forward_if', which may inform you that you need to supply a postcondition"
      2 idtac "Hint: try 'forward_for_simple_bound N (EX i:Z, PROP... LOCAL...SEP...)%assert', where N is the upper bound of the loop, i is the loop iteration value,  and the LOCAL clause does NOT contain a 'temp' binding for the loop iteration variable";
      2 idtac "Hint: try 'forward_call x', where x is a value to instantiate the tuple of the function's WITH clause.  If you want more information about the _type_ of the argument that you must supply to forward_call, do 'forward' for information"
      2 idtac "Hint: try 'Exists x', where x is a value of type " t " to instantiate the existential"
      2 idtac "Hint: try 'entailer!'";
      2 idtac "Hint:  try 'entailer!'";
      2 idtac "Hint:  try 'cancel'" 
      2 idtac "Hint:  try 'autorewrite with sublist in *|-'"
      2 idtac "Hint:  try 'autorewrite with sublist'"
      2 idtac "Hint:  try 'autorewrite with norm'"
      2 idtac "Hint: try 'apply pred_ext'"
      2 idtac "Hint: try 'apply forall_Znth; auto'"
      2 idtac "Hints are only available when verifying C programs,
      2 idtac "Hint: 'rewrite if_true in"H"by auto'"
      2 idtac "Hint: 'rewrite if_true by auto'"
      2 idtac "Hint: 'rewrite if_false in"H"by auto'"
      2 idtac "Hint: 'rewrite if_false by auto'"
      2 idtac "Hint: perhaps try 'destruct " A " eqn:?'"
      2 idtac "Hint: perhaps 'rewrite Znth_map'"
      2 idtac "Hint: Nothing found in the 'saturate_local' HintDb that matches the "P" conjunct; you might want to define one, or unfold "P
      2 idtac "Hint:  'list_solve' solves the goal"
      2 idtac "Hint: if you think " X " is provable, 'rewrite if_true'.
      2 idtac "Hint: hypothesis" H "is redundant, perhaps clear it"
      2 idtac "Hint: hypothesis" H "is a 'value_fits' fact; often these are not useful, _maybe_ 'clear" H "'"    
      2 idtac "Hint:" H' "implies" H ", perhaps 'clear" H "'"
      2 idtac "Hint:  'f_equal' followed by 'cstring' solves the goal"
      2 idtac "Hint:  'entailer!' solves the goal"
      2 idtac "Hint:  'discriminate' solves the goal"
      2 idtac "Hint: 'deadvars!' removes useless LOCAL definitions");
      2 idtac "Hint:  'cstring' solves the goal"
      2 idtac "Hint:  'contradiction' solves the goal"
      2 idtac "Hint:  clear" D
      2 idtac "Hint:  'cancel' or 'entailer!' solves the goal"
      2 idtac "Hint:  'auto with valid_pointer' solves the goal"
      2 idtac "Hint:  'auto with field_compatible' solves the goal"
      2 idtac "Hint:  'auto' solves the goal"
      2 idtac. (* "Hint: at any time, try the 'hint' tactic.  To disable this message, 'Ltac start_function_hint ::= idtac.' ". *)
      2 idtac "Hint: 'apply derives_refl' solves the goal.  You might wonder why 'auto' or 'cancel' does not solve this goal; the reason is that the left and right sides of the entailment are equal but not identical, and sometimes the attempt to unify terms like this would be far too slow to build into 'auto' or 'cancel'"
      2 idtac "H=" H;
      2 idtac | generalize (S_plus _ _H1 _H2); clear _H1 _H2; intro H ]
      2 idtac G end;*) lazy [big];
      2 idtac G end;*) lazy [big].
      2 idtac G
      2 idtac : fvs.
      2 idtac|fold FtoRradix; apply Rle_ge].
      2 idtac|fold FtoRradix; apply qNeg].
      2 idtac|field; apply prod_neq_R0; auto with real; apply prod_neq_R0; auto with real].
      2 idtac|field].
      2 idtac; f foo x I.
      2 idtac | Falsum ]; rewrite coding;
      2 idtac | Falsum ]; apply f_equal with Qpositive; 
      2 idtac | false => is_array_type t end
      2 idtac "failed to eliminate the functional dependencies of" f;
      2 idtac "failed to apply, generalizing instead!" ;
      2 idtac. fail. auto. Qed.
      2 idtac; fail 1.
      2 idtac "fail").
      2 idtac; f.
      2 idtac f';*)
      2 idtac "expression " goal "is ill typed" t
      2 idtac | exists y; split; auto with zfc ].
      2 idtac | exists y; exists b; split; [ auto with zfc | reflexivity ] ].
      2 idtac | exists x; split; [ auto with zfc | rewrite H2; reflexivity ] ].
      2 idtac | exists x; split; [ auto with zfc | reflexivity ] ].
      2 idtac | exists x; exists z; split; [ reflexivity | auto with zfc ] ].
      2 idtac | exists x; exists y; split; [ auto with zfc | reflexivity ] ].
      2 idtac | exists x; exists v2; split; [ auto with zfc | reflexivity ] ].
      2 idtac | exists x1; exists b; split; [ auto with zfc | reflexivity ] ].
      2 idtac. exists x0. split; (auto || lia).
      2 idtac | exists x0; exists x1; auto with zfc ].
      2 idtac | exists x0; auto with zfc ].
      2 idtac | exists v2; exists v2; reflexivity ].
      2 idtac | exists v2; auto with zfc ].
      2 idtac | exists v0; auto with zfc ].
      2 idtac + exfalso); lia ].
      2 idtac | exact (lem_x_in_sing_x a) ].
      2 idtac | exact Hwf ].
      2 idtac | exact Hleft_fst ].
      2 idtac|exact H'].
      2 idtac | exact H] 
      2 idtac "evaluating" l;
      2 idtac "Error: run_rtac could not resolve the result from the tactic :" tac
      2 idtac end. (* typing *)
      2 idtac end. (* LHS is not simplified *)
      2 idtac end. (* LHS becomes (f x, g y) *)
      2 idtac end in H 100.
      2 idtac end. (* expect 3 = 3 *)
      2 idtac end end.
      2 idtac] end.
      2 idtac else invs H end.
      2 idtac else idtac "Hint: try 'rewrite prop_sepcon2'";
      2 idtac else idtac "Hint: try 'rewrite prop_sepcon'";
      2 idtac | elim (not_and_or _ _ H2); intro ].
      2 idtac | elim H'3; clear H'3; intros H'3 H'4 ]; auto; 
      2 idtac | elim H'3; clear H'3; intros H'3 H'4 ]; auto;
      2 idtac|elim Fx; auto with zarith].
      2 idtac | elim (axs_paire x y y); intros; apply H1; right; reflexivity ].
      2 idtac | elim (axs_paire x x0 x0); intros; apply H4; right; reflexivity ].
      2 idtac | elim (axs_paire x v2 v2); intros; apply H4; right; reflexivity ].
      2 idtac | elim (axs_paire x v2 v2); intros; apply H2; right; reflexivity ].
      2 idtac | elim (axs_paire a b b); intros; apply H2; right; reflexivity ].
      2 idtac. eauto using equiv_eqs_pointwise.
      2 idtac|eauto|]; eauto.
      2 idtac]; eauto 3.
      2 idtac); [|eauto|].
      2 idtac; easy.
      2 idtac | eapply po_None].
      2 idtac..|eapply H]; clear s t H
      2 idtac..|eapply H]; clear s t E H
      2 idtac..|eapply H]; clear E H
      2 idtac..|eapply H]; clear E E' H
      2 idtac | eapply H10].
      2 idtac | eapply H].
      2 idtac|eapply fv_tm_tm_tm_open_tm_wrt_tm_upper].
      2 idtac| eapply fv_tm_tm_tm_open_tm_wrt_tm_upper].
      2 idtac | eapply andE2; apply Axm; right; constructor ].
      2 idtac "Dropping dead vars!"; drop_LOCALs d
      2 idtac | discrR ]; rewrite Rmult_1_r; rewrite double;
      2 idtac | discrR ]...
      2 idtac | discriminate | idtac ].
      2 idtac; discriminate.
      2 idtac; destruct H
      2 idtac : db.
      2 idtac | cut (p <= 0)%R; [ intros Rl3' | apply Rlt_le; auto ] ];
      2 idtac current;
      2 idtac "creating x without [Proof.]".
      2 idtac) : core.
      2 idtac | contradiction ]
      2 idtac | context[z] => idtac end;
      2 idtac | |- context [field_compatible0] => idtac end;
      2 idtac + constructor; typeclasses eauto.
      2 idtac]; constructor.
      2 idtac.com/coq/coq/issues/11202 *)
      2 idtac cc.
      2 idtac | case p ];
      2 idtac|case H1; clear H1; intros H1]; clear H0.
      2 idtac "before:" e; idtac "after :" E;
      2 idtac | auto with zfc ]; left; auto with zfc.
      2 idtac | auto with zfc ] ].
      2 idtac | auto with zfc ] ] ].
      2 idtac ]; auto with zfc.
      2 idtac | auto with sets ].
      2 idtac ] ] ]; auto with searchtrees arith.
      2 idtac ]; auto with real arith.
      2 idtac ]; auto with arith.
      2 idtac ]; auto with *.
      2 idtac|auto|auto].
      2 idtac | assumption]. subst.
      2 idtac | assumption | exact Hcachepath ].
      2 idtac |assumption]
      2 idtac | assumption] 
      2 idtac | assumption]
      2 idtac | assumption ];
      2 idtac ]; assumption.
      2 idtac | assert (Hn' : (n < 0)%Z); [ idtac | abstract auto with zarith ] ].
      2 idtac | apply Zsgn_2; rewrite Zsgn_15 ]; assumption.
      2 idtac; apply Z_of_nat_complete; assumption.
      2 idtac | apply Z.min_comm ].
      2 idtac | apply Z.le_trans with 1%Z; auto with zarith ].
      2 idtac | apply Upper_Bound_definition ]; auto 10.
      2 idtac | apply Upper_Bound_definition ];
      2 idtac | apply UlpFlessuGe; auto ].
      2 idtac | apply sym_equal, H'4 ].
      2 idtac | apply simplring1 ]
      2 idtac | apply SGe; auto].
      2 idtac|apply Rplus_le_compat];auto with real.
      2 idtac|apply Rplus_le_compat; auto with real].
      2 idtac | apply RND_Max_canonic ].
      2 idtac|apply Rmult_le_compat_r; unfold Fulp; auto with real zarith].
      2 idtac|apply Rmult_le_compat_r].
      2 idtac|apply Rle_powerRZ; try apply IZR_le; auto with zarith real].
      2 idtac|apply Rle_powerRZ; try apply IZR_le; auto with real zarith].
      2 idtac|apply Rle_powerRZ; auto with zarith real].
      2 idtac | apply Rle_ge; unfold Fulp in |- *; auto with real zarith ].
      2 idtac|apply Rle_ge; generalize zPos; auto with real].
      2 idtac|apply Rle_ge; generalize uhPos; auto with real].
      2 idtac|apply Rle_ge;auto with real].
      2 idtac|apply Rle_ge;
      2 idtac|apply qNeg].
      2 idtac | apply Qlt_mult_pos_pos; try auto with * ]
      2 idtac | apply Qlt_mult_pos_pos ]
      2 idtac | apply Qlt_mult_neg_pos; try auto with * ]
      2 idtac | apply Qlt_mult_neg_pos ]
      2 idtac | apply pr_nu ]...
      2 idtac | apply PPO_first_activations; assumption ].
      2 idtac | apply powerRZ_le, IZR_lt; auto with arith real ].
      2 idtac|apply powerRZ_1].
      2 idtac | apply lt_O_Sn | apply le_n ].
      2 idtac|apply LeR0Fnum with radix; auto with zarith real].
      2 idtac | apply le_n_Sn]);
      2 idtac | apply le_n_S; apply le_length_Succ].
      2 idtac | apply lem_union_propertie | apply lem_union_propertie ].
      2 idtac | apply lem_inter_propertie ].
      2 idtac | apply Lem ]
      2 idtac | apply inj_abs; auto ].
      2 idtac | apply Hrecx0 ].
      2 idtac | apply Hgeneralized; assumption ].
      2 idtac|apply H2|eauto].
      2 idtac | apply H' ].
      2 idtac_and_time prime bitwidth p (@None unit) "GallinaDefOf with cbv_no_rt" (fun _ => let __ := eval cbv_no_rt in (GallinaDefOf p) in idtac);
      2 idtac_and_time prime bitwidth p (@None unit) "GallinaAxOf with vm_compute" (fun _ => let __ := eval vm_compute in (GallinaAxOf p) in idtac);
      2 idtac_and_time prime bitwidth p (@None unit) "GallinaAxOf with cbv" (fun _ => let __ := eval cbv in (GallinaAxOf p) in idtac);
      2 idtac_and_time prime bitwidth p (@None unit) "GallinaAxComputedOf with vm_compute" (fun _ => let __ := eval vm_compute in (GallinaAxComputedOf p) in idtac);
      2 idtac_and_time prime bitwidth p (@None unit) "GallinaAxComputedOf with cbv" (fun _ => let __ := eval cbv in (GallinaAxComputedOf p) in idtac);
      2 idtac_and_time prime bitwidth p method "PipelineNBEOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineNBEOf with lazy" (fun _ => let __ := eval lazy in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineNBEOf with cbv" (fun _ => let __ := eval cbv in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullToStringsOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullToStringsOf with lazy" (fun _ => let __ := eval lazy in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullToStringsOf with cbv" (fun _ => let __ := eval cbv in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullOf with lazy" (fun _ => let __ := eval lazy in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineFullOf with cbv" (fun _ => let __ := eval cbv in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineArithOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineArithOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth p method "PipelineArithOf with lazy" (fun _ => let __ := eval lazy in (PipelineArithOf (p, method)) in idtac))
      2 idtac_and_time prime bitwidth p method "PipelineArithOf with cbv" (fun _ => let __ := eval cbv in (PipelineArithOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p (@None unit) "GallinaDefOf with cbv_no_rt" (fun _ => let __ := eval cbv_no_rt in (GallinaDefOf p) in idtac);
      2 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxOf with vm_compute" (fun _ => let __ := eval vm_compute in (GallinaAxOf p) in idtac);
      2 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxOf with cbv" (fun _ => let __ := eval cbv in (GallinaAxOf p) in idtac);
      2 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxComputedOf with vm_compute" (fun _ => let __ := eval vm_compute in (GallinaAxComputedOf p) in idtac);
      2 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxComputedOf with cbv" (fun _ => let __ := eval cbv in (GallinaAxComputedOf p) in idtac);
      2 idtac_and_time prime bitwidth index p method "PipelineNBEOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineNBEOf with lazy" (fun _ => let __ := eval lazy in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineNBEOf with cbv" (fun _ => let __ := eval cbv in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullToStringsOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullToStringsOf with lazy" (fun _ => let __ := eval lazy in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullToStringsOf with cbv" (fun _ => let __ := eval cbv in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullOf with lazy" (fun _ => let __ := eval lazy in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineFullOf with cbv" (fun _ => let __ := eval cbv in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineArithOf with vm_compute" (fun _ => let __ := eval vm_compute in (PipelineArithOf (p, method)) in idtac));
      2 idtac_and_time prime bitwidth index p method "PipelineArithOf with lazy" (fun _ => let __ := eval lazy in (PipelineArithOf (p, method)) in idtac))
      2 idtac_and_time prime bitwidth index p method "PipelineArithOf with cbv" (fun _ => let __ := eval cbv in (PipelineArithOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth p (@None unit) "GallinaAxOf with native_compute" (fun _ => let __ := eval native_compute in (GallinaAxOf p) in idtac);
      2 idtac_and_time2 prime bitwidth p method "PipelineNBEOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth p method "PipelineFullToStringsOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth p method "PipelineFullOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth p method "PipelineArithOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineArithOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth index p (@None unit) "GallinaAxOf with native_compute" (fun _ => let __ := eval native_compute in (GallinaAxOf p) in idtac);
      2 idtac_and_time2 prime bitwidth index p method "PipelineNBEOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineNBEOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth index p method "PipelineFullToStringsOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineFullToStringsOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth index p method "PipelineFullOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineFullOf (p, method)) in idtac));
      2 idtac_and_time2 prime bitwidth index p method "PipelineArithOf with native_compute" (fun _ => let __ := eval native_compute in (PipelineArithOf (p, method)) in idtac));
      2 idtac "(ALL _:"T", _) in your precondition";
      2 idtac. all: exfalso; clear.
      2 idtac "a" + idtac "b"). (* should only output "a" *)
      2 idtac "A"; idtac "B"; idtac "C".
      2 idtac+admit : core.
      2 idtac "a"; constructor).
      2 idtac "absurd_hyp is OBSOLETE: use contradict instead.";
      2 idtac | abstract ring ]; rewrite Qplus_zero_left;
      2 idtac + (abstract reflexivity))); fail. (* should not time out *)
      2 idtac + (abstract reflexivity))); fail)).
      2 idtac | abstract auto with zarith ]; replace h with (h - d + d)%Z;
      2 idtac | abstract auto with zarith ]; replace g with (g - c + c)%Z;
      2 idtac | abstract auto with zarith ]; replace f with (f - b + b)%Z;
      2 idtac | abstract auto with zarith ]; replace d with (d - h + h)%Z;
      2 idtac | abstract auto with zarith ]; replace c with (c - g + g)%Z;
      2 idtac | abstract auto with zarith ]; replace b with (b - f + f)%Z;
      2 idtac a. Abort.
      2 idtac. 2: eauto. 2: eauto.
      2 idtac "1";
      2 idtac) 0.
      2 idtac) 0).
      2 idtac] *)
      2 idtac] 
      2 idtac; 
      2 idtac/.
      2 idtac. }
      2 idtac) || 
      2 idtac) _.
      2 idtac) ] ]
      2 idtac) ;
      2 idtac | ].
      2 idtac ] ] ]
      2 idtac .. ].
      2 idtac (*
      1 idtac | Zlength_solve ..]
      1 idtac "Zlength_solve."
      1 idtac | Z => idtac end;
      1 idtac z ; fail "Couldn't prove the global environment is well-formed" *)
      1 idtac "y"
      1 idtac x y z) B *)
      1 idtac x | idtac "Untyped:" e ].
      1 idtac X ; fail 100000 "bad"
      1 idtac x; eapply x.
      1 idtac x; change (x \/ b) in H)
      1 idtac x;
      1 idtac x)
      1 idtac] with an argument, a convenient
      1 idtac "WHY does lia fail to solve " g; trivial end). }
      1 idtac "   we need to show that:";print_goal.
      1 idtac "   we need to make geometric quantities independant...";
      1 idtac "was" out*)
      1 idtac "Warning: the 'name' tactic no loger does anything useful, and will be removed in future versions of VST".
      1 idtac "Warning: the function-body parameter/return types are not identical to the funspec types, although they are compatible:
      1 idtac  "Warning: The following names have funspecs but no function definitions: " missing
      1 idtac "Warning: repable_signed is deprecated;  use rep_omega"; rep_omega.
      1 idtac "Warning: repable_signed is deprecated;  use rep_lia"; rep_lia.
      1 idtac "WARNING: Remaining goal:"; print_context_and_goal () .. | | ].
      1 idtac "WARNING: Remaining goal:"; print_context_and_goal () .. ].
      1 idtac "Warning: gather_SEP with numeric arguments is deprecated".
      1 idtac "Warning: Fixed up a postcondition that was damaged; typically this has happened because you did 'simpl in *' that messed up Delta_specs.  Avoid 'simpl in *'.".
      1 idtac "WARNING: extraction is buggy if used while a term of type 'extracted _' is in Context"
      1 idtac "Warning: could not process all the extern variables in main_pre"
      1 idtac "Warning: could not infer a default value for list type" A)
      1 idtac "Warning: Admitting the bitvector proposition below if it holds for" w "<=" n;
      1 idtac v;
      1 idtac using normal_var.  
      1 idtac using normal_const.  
      1 idtac "Using alternate LookupID"
      1 idtac "Using alternate LookupB"
      1 idtac + unshelve econstructor); eassumption).
      1 idtac "Unrecognized term:" term
      1 idtac "Unrecognized bounds component:" correctness "; unrecognized equality type" T;
      1 idtac "Unrecognized bounds component:" correctness;
      1 idtac "unknown" x
      1 idtac | unfold Zsucc in |- *; ring ].
      1 idtac | unfold Zpred in |- *; simpl in |- *; auto ].
      1 idtac | (unfold wp; firstorder eauto with hoare) ].
      1 idtac "unfold"; unfold diskIs in *
      1 idtac | unfold radix at 1; unfold FtoRradix; ring].
      1 idtac); unfold pi; [now rewrite <- H | now rewrite H].
      1 idtac; unfold mv in *.
      1 idtac | unfold Fopp in |- *; simpl in |- *; auto ].
      1 idtac | unfold Fabs in |- *; simpl in |- *; auto ].
      1 idtac "u"
      1 idtac; try solve [cbv [R] in *; intuition idtac].
      1 idtac (* try (progress (autorewrite with refinesM) ; old_prove_refinesM) *)
      1 idtac; try Option.inversion_option; subst; try eval_same_expr_goal;
      1 idtac; try Option.inversion_option; subst; trivial.
      1 idtac; try lia; now asimpl.
      1 idtac; try inv H7; auto with datatypes;
      1 idtac ; try intro].
      1 idtac "trying " g; fail 1 end) *)
      1 idtac; try congruence).
      1 idtac | _ => try clear he end.
      1 idtac. transitivity x'; eauto.
      1 idtac to enable the precomputed versions *)
      1 idtac {T} (msg : T) := Build_cidtac : True.
      1 idtac "Timing the Qed of drbg_reseed (goal: 25secs)". omega. 
      1 idtac "Timing the Qed of drbg_reseed (goal: 25secs)". lia. 
      1 idtac "This function appears to be a leaf function, that is, has no function calls.
      1 idtac]; (* This checks there is only one goal left! *)
      1 idtac "The value of x is" (x).
      1 idtac "The type of y is" (type of y).
      1 idtac "The type of xe is" (type of xe).
      1 idtac "The type of f is" (type of f).
      1 idtac "The tactic permute does not apply to the current goal!"
      1 idtac"then";print_goal;
      1 idtac "Testing WordByWordMontgomery" prime "(bitwidth =" bitwidth ") (method =" method ") (params =" p ")" descr "(2) :";
      1 idtac "Testing WordByWordMontgomery" prime "(bitwidth =" bitwidth ") (method =" method ") (params =" p ")" descr "(1) :";
      1 idtac "Testing WordByWordMontgomery" prime "(bitwidth =" bitwidth ") (method =" method ") (params =" p ")" descr ":";
      1 idtac "Testing UnsaturatedSolinas" prime "(bitwidth =" bitwidth ") (index =" index ") (method =" method ") (params =" p ")" descr "(2) :";
      1 idtac "Testing UnsaturatedSolinas" prime "(bitwidth =" bitwidth ") (index =" index ") (method =" method ") (params =" p ")" descr "(1) :";
      1 idtac "Testing UnsaturatedSolinas" prime "(bitwidth =" bitwidth ") (index =" index ") (method =" method ") (params =" p ")" descr ":";
      1 idtac T)
      1 idtac T
      1 idtac + symmetry in H); eapply M.MapsTo_1 in H; [ | apply M.find_2; eassumption ]
      1 idtac + symmetry); (idtac + etransitivity); eassumption.
      1 idtac + symmetry); exact H | auto ]
      1 idtac + symmetry); eassumption.. ]
      1 idtac + symmetry); eassumption.
      1 idtac + symmetry); eassumption | ]);
      1 idtac + symmetry); eassumption
      1 idtac + symmetry); eapply Ha'; (eassumption + (etransitivity; (idtac + symmetry); eassumption)) | ].
      1 idtac + symmetry); assumption ]
      1 idtac + symmetry); apply groupAllBy'_eq_fuel'; lia.
      1 idtac + symmetry); apply fold_right_filter_identity_gen with (G:=fun x => Z.land x _).
      1 idtac + symmetry); apply abstract_domain_R_fill_bottom_idempotent.
      1 idtac + symmetry);
      1 idtac "SymexLines start");
      1 idtac "SymexLines end")
      1 idtac "Suggestion: you are storing to one field of a union, then loading from another.  This is not always illegal.  See chapter 'Union casting' in the VC.pdf reference manual".
      1 idtac "Suggestion: Because your while-loop is followed by a known postcondition, you may wish to prove it with forward_loop instead of forward_while, because then your postcondition might be weaker (easier to prove) than the standard while-loop postcondition (Invariant & ~test)".
      1 idtac; subst; rewrite H0 in *; simplify in H4; simplify in H3; rewrite H4 in l.  
      1 idtac; subst; rewrite firstn_length; rewrite min_l; intuition nomega.
      1 idtac; subst; intuition (auto with listdb).
      1 idtac]; subst; auto. Qed.
      1 idtac; subst; auto; lia.
      1 idtac;subst.
      1 idtac; subst;
      1 idtac; subst.   
      1 idtac. subst.
      1 idtac); subst.
      1 idtac" string(x) := idtac (*x*).
      1 idtac "still app" s t; *)
      1 idtac := step using idtac with intuition idtac.
      1 idtac "stepsim - done". *)
      1 idtac "Stats (n=" n "):";
      1 idtac "Stats-native (n=" n "):";
      1 idtac "Starting test (n=" n ") for" name;
      1 idtac st'.
      1 idtac|split]; try (field; neq_0;apply sqr_sum; auto with zarith).
      1 idtac | split ]); intros.
      1 idtac | split; [ idtac | split; [ idtac | idtac ] ] ]; 
      1 idtac | split; [ idtac | split ] ]; auto.
      1 idtac|split ; [idtac|split]].
      1 idtac | split; [ assumption | idtac ] ]
      1 idtac | split]].
      1 idtac | split ]; 
      1 idtac | split ];
      1 idtac "split." *)
      1 idtac (*; specialize (res_bounds x ltac:(auto));
      1 idtac "solving uniqueness". *)
      1 idtac "solve_SF_internal did not entirely succeed, because" P "does not exactly match this subgoal")
      1 idtac | solve[ring]];idtac "simpl droite sym".
      1 idtac | solve[ring]];idtac "simpl droite".
      1 idtac|solve [repeat split; repeat apply nonzeromult;auto with Geom]]).
      1 idtac); solve [intuition eauto].
      1 idtac|solve[eapply update_elections_data_appendEntries_allEntries; eauto]]; eauto].
      1 idtac (* solve below *)
      1 idtac | _ => solve_all end.
      1 idtac | S ?nn => split; [f nn|idtac] end in f n.
      1 idtac "sll:verify". Time *)
      1 idtac "sll:prepare". Time *)
      1 idtac; sleep.
      1 idtac); simpl; try tauto;
      1 idtac | simpl in |- *; unfold radix; ring ];
      1 idtac; simpl in *; subst; intuition eauto;
      1 idtac | simpl in |- *; red in |- *; apply Refl ].
      1 idtac | simpl in |- *; auto ];
      1 idtac "simpl_implicit."
      1 idtac; simplify in *; try congruence.
      1 idtac; simplify in *.
      1 idtac "   simplification...";basic_simpl.
      1 idtac; simpl; crunch
      1 idtac s;fail 1000
      1 idtac|ring];
      1 idtac | right; ring ].
      1 idtac | rewrite x; clear x].
      1 idtac|rewrite uniformize_areas_correct;trivial]).
      1 idtac. rewrite tau_euttge, (itree_eta t2). now apply IHHrutt.
      1 idtac. rewrite tau_euttge, itree_eta; now apply IHHeutt. }
      1 idtac | rewrite <- Rmult_assoc; rewrite Rinv_l; auto with real ].
      1 idtac; rewrite ?Nat.sub_0_r; lia.
      1 idtac | rewrite mult_assoc ;
      1 idtac + rewrite <- InA_eq_In_iff + rewrite InA_eq_In_iff); assumption.
      1 idtac |  rewrite <- H10; eassumption | idtac | apply andp_right].
      1 idtac + rewrite -> !and_assoc + rewrite <- !and_assoc);
      1 idtac;rev_smpl.
      1 idtac res ;
      1 idtac "rep_lia."
      1 idtac; repeat match goal with
      1 idtac "Remark: QPprog alternate path!";
      1 idtac "Remark: change_compspecs on user-defined mpred:" A cs cs'
      1 idtac refP)
      1 idtac | reflexivity]| idtac]; [reflexivity | now constructor ]).
      1 idtac | reflexivity ]).
      1 idtac + refine (reflexivity _)); eauto using lift_eval_idx_Z_impl; []
      1 idtac "recurse to" s; *)
      1 idtac | rapply (e H) ]
      1 idtac "r"
      1 idtac "q"
      1 idtac "proving stepsim lemma - this may take a few minutes".*)
      1 idtac " provided, but found";
      1 idtac "progress_entailer."
      1 idtac; prep_locals; evaluate auto_ext; auto)
      1 idtac; prep_locals; evaluate auto_ext)
      1 idtac "permMapLt_pair cant be solved:"; print_goal].
      1 idtac "pair:verify". Time *)
      1 idtac "pair:prepare". Time *)
      1 idtac "p"
      1 idtac; Option.inversion_option.
      1 idtac | omega ]).
      1 idtac "ok"
      1 idtac "o"
      1 idtac; now subst.
      1 idtac "now";print_goal;
      1 idtac. now (exists z).
      1 idtac. now apply Hu.
      1 idtac; now apply Hc. }
      1 idtac;now apply H1.
      1 idtac "not supported yet"
      1 idtac "NOPE" prover pack
      1 idtac "no match"; fail 1
      1 idtac (** No lemmas?  Nothing to do here *)
      1 idtac. (* no hint reminder *)*)
      1 idtac. (* no hint reminder *)
      1 idtac "noFastValue, default to true" s; *)idtac
      1 idtac (* no eassumption on length goals *)
      1 idtac; multimatch goal with H : _ |- _ => unshelve eapply H; [ try eassumption .. | intros; simpl in * ]; clear H end)).
      1 idtac; multimatch goal with H : _ |- _ => unshelve eapply H; [ try eassumption .. | intros; simpl ctx_inst_size in *; simpl branches_size in * ]; clear H end)).
      1 idtac; multimatch goal with H : _ |- _ => eapply H end); eauto with fvs.
      1 idtac; multimatch goal with H : _ |- _ => eapply H end; eauto).
      1 idtac; multimatch goal with H : _ |- _ => apply H end).
      1 idtac; multimatch goal with
      1 idtac ?msg) => idtac msg; exact I : typeclass_instances.
      1 idtac msg1 msg2 msg3 msg4).
      1 idtac msg1 msg2 msg3).
      1 idtac msg1 msg2).
      1 idtac msg).
      1 idtac msg :=
      1 idtac; match x with context[match _ with _ => _ end] => idtac end);
      1 idtac; match v with context[match _ with _ => _ end] => idtac end);
      1 idtac "malloc:verify". Time *)
      1 idtac "malloc:prepare". Time *)
      1 idtac ltac:(eauto).
      1 idtac) ltac:(all f).
      1 idtac ls; assert (ls = ls) by equality
      1 idtac;LrewriteSimpl').
      1 idtac "Lrewrite_prepare does not support s >(k) y, only s >(<=k) t)"
      1 idtac "LoadOutputs start");
      1 idtac "LoadOutputs end")
      1 idtac "LoadArray start");
      1 idtac "LoadArray end")
      1 idtac "list_solve."
      1 idtac (listIn e); intro HlistIn;
      1 idtac (listIn e); intro HlistIn.
      1 idtac || lia || subst ; eauto using star || rewrite Nat.sub_diag in * || rewrite Nat.sub_0_r in *||cbn in * )).
      1 idtac); [lia| |].
      1 idtac; let sleep := (eval vm_compute in Coq.ZArith.BinInt.Z.div_eucl) in idtac).
      1 idtac | left; eauto ].
      1 idtac + left); apply interp_op_nil_is_identity.
      1 idtac "leaving behind" H end; *)fail else idtac
      1 idtac; lazymatch goal with |- True -> _ => idtac end;
      1 idtac; lazymatch goal with |- ?G => has_evar G end);
      1 idtac; l.
      1 idtac (* keep interp and wf *)
      1 idtac ]; is_ok H) || (inversion H; fail)
      1 idtac; inv T2.
      1 idtac] invocations above.  This printing is for the
      1 idtac | inversion H'3 ]; auto.
      1 idtac "Intuition used where tauto would work");
      1 idtac]; intros; prog_at_r tac line'; eapply comp_spec_eq_refl]
      1 idtac]; intros; prog_at_l tac line'; eapply comp_spec_eq_refl | 
      1 idtac | intros H'; try assumption ].
      1 idtac | intros H'2; try assumption ].
      1 idtac ]; intros H0.
      1 idtac ]; intros H; 
      1 idtac + (intros; exfalso)); lia
      1 idtac "Intros *."
      1 idtac|intros [= <- <-]..] => //.
      1 idtac. intros ???.
      1 idtac] (*instantiates InitPred to MainVarDefs*)
      1 idtac "   initialisation...";geoInit;idtac "   elimination..."; eliminate_All; idtac "   uniformize areas...";
      1 idtac "<infomsg>Warning: debug_intuition should not be used in production code.</infomsg>"; intuition debug auto with *.
      1 idtac | induction H2 ].
      1 idtac];idtac "simpl gauche sym".
      1 idtac];idtac "simpl gauche".
      1 idtac|idtac]; inv AC; simpl.
      1 idtac|idtac]; inv ACC; unfold decode_val.
      1 idtac | idtac | idtac ]
      1 idtac|idtac|eauto]; [|idtac|eauto]; eauto.
      1 idtac|idtac|eauto|]; eauto).
      1 idtac|idtac]; eapply agree_regs_incr; eauto.
      1 idtac;[idtac "could not simplify some occuring term, shelved instead"];shelve).
      1 idtac | idtac].
      1 idtac | idtac ]
      1 idtac ] | idtac ];
      1 idtac i
      1 idtac "i"
      1 idtac H ":" t; fail
      1 idtac H ":" T
      1 idtac H; rewrite H => //=
      1 idtac "Hint:  try 'rewrite if_true by auto' or 'rewrite if_true by omega'"
      1 idtac "Hint:  try 'rewrite if_true by auto' or 'rewrite if_true by lia'"
      1 idtac "Hint:  try 'rewrite if_false by auto' or 'rewrite if_false by omega'"
      1 idtac "Hint:  try 'rewrite if_false by auto' or 'rewrite if_false by lia'"
      1 idtac "Hint:  'rep_omega' solves the goal"
      1 idtac "Hint:  'rep_lia' solves the goal"
      1 idtac "Hint:  'omega' solves the goal"
      1 idtac "Hint:  'lia' solves the goal"
      1 idtac "Hint: In order for the 'cancel' tactic to automatically instantiate the Frame, it must be able to cancel all the other right-hand-side conjuncts against some left-hand-side conjuncts.  Right now the r.h.s. conjuncts do not exactly match l.h.s. conjuncts; perhaps you can unfold or rewrite on both sides of the |-- so that they do cancel."
      1 idtac "Hint: In order for the 'cancel' tactic to automatically instantiate the Frame, it must be able to cancel all the other right-hand-side conjuncts against some left-hand-side conjuncts.  Right now the r.h.s. conjuncts do exactly match l.h.s. conjuncts; perhaps you can unfold or rewrite on both sides of the |-- so that they do cancel."
      1 idtac "Hi"
      1 idtac H; exact H
      1 idtac here*)
      1 idtac "here";
      1 idtac |  H : context[Syntax.cmovb] |- _ => idtac | _ => shelve end.
      1 idtac | H : context[pop] |- _ => idtac | _ => shelve end; shelve_unifiable.
      1 idtac H ":=" body ":" T
      1 idtac "had to hnf in funcs" funcs ;
      1 idtac H'
      1 idtac h.
      1 idtac_goal := lazymatch goal with |- ?G => idtac "Goal:" G end.
      1 idtac (* "goal:" g*) end.
      1 idtac_goal;
      1 idtac goal.
      1 idtac "get callee_saved_registers start");
      1 idtac "get callee_saved_registers end")
      1 idtac G end ;time "Lproc"( *)
      1 idtac G;
      1 idtac g
      1 idtac; fqsatz.
      1 idtac "forward_if2."].
      1 idtac "forward_if."
      1 idtac "forward_call."
      1 idtac "forward."
      1 idtac "forall"; unfold forall_helper; intros; eexists; intros
      1 idtac; #[ foo ] testatt.
      1 idtac | firstorder eauto with hoare ].
      1 idtac "fallback" H; *)Ltransitivity;[solve[find_Lrewrite_lemma]|]  
      1 idtac "Failed to eliminate functional dependencies in" F;
      1 idtac "Failed to eliminate functional dependencies in" f
      1 idtac) || fail 2 end.
      1 idtac " expected, but found";
      1 idtac|exists H]
      1 idtac. exists (Enc W .+ mv >> var • v'').
      1 idtac. exists (a :: A1). exists A2. subst. 
      1 idtac. exists A1. exists A2. intuition idtac.
      1 idtac + exfalso); lia].
      1 idtac + exfalso); lia).
      1 idtac + exfalso + inversion_option); eassumption). Defined.
      1 idtac + exfalso + inversion_option); assumption. Defined.
      1 idtac + exfalso); eauto ] ].
      1 idtac + exfalso); eassumption. Defined.
      1 idtac + exfalso); assumption).
      1 idtac "Error: Unrecognized var:" v " in " ctx;
      1 idtac "Error: Unrecognized type for equality:" T';
      1 idtac "Error: Unrecognized term:" v " in " ctx;
      1 idtac "Error: Unable to repair a postcondition that was damaged; typically this has happened because you did 'simpl in *' that messed up Delta_specs.  Avoid 'simpl in *'.".
      1 idtac "Error:" msg; exact I : typeclass_instances.
      1 idtac "Error:" msg1 msg2 msg3; exact I : typeclass_instances.
      1 idtac "Error:" msg1 msg2 msg3).
      1 idtac "Error:" msg1 msg2; exact I : typeclass_instances.
      1 idtac "Error:" msg1 msg2).
      1 idtac "Error:" msg).
      1 idtac "Error: Got" e "Expected:" ref_PHOAS; unify e ref_PHOAS
      1 idtac "Error: Got" e "Expected:" ref_HOAS; unify e ref_HOAS
      1 idtac "Entangled: because" s1 "+" s "=" s2 "is not provable."; fail 1)
      1 idtac "Entangled: because " s1 "+" s "=" s2 "is not provable."; fail 1)
      1 idtac end (* work around bug number 6998 in Coq *)
      1 idtac end) then idtac
      1 idtac end. (* no renaming *)
      1 idtac end | lazymatch goal with |- R_list_scalar_or_array_nolen _ _ _ => idtac end ].
      1 idtac end) H;
      1 idtac end).
      1 idtac end)
      1 idtac else inList x t
      1 idtac else fail "vararg function definitions are not supported in VST; there is some limited support for calling (but not defining) printf and fprintf").
      1 idtac else fail "struct-returning functions are not supported in VST");
      1 idtac else fail "no-prototype functions are not supported in VST");
      1 idtac else fail
      1 idtac else
      1 idtac "   elimination of point :" A;eliminate_aux A; 
      1 idtac | elim H'1; clear H'1; intros H'1 ]; clear H').
      1 idtac | elim H'0; clear H'0; intros H'0 ];
      1 idtac "EExists."
      1 idtac | eauto with typeclass_instances | idtac] ; intuition; subst; dist_simp_weak; intuition.
      1 idtac. eauto using nth_error_Some_lt.
      1 idtac; eauto using all_terms_nil|eauto using eqs_ordertyping].
      1 idtac|]; eauto. subst.
      1 idtac|eauto]. omega.
      1 idtac|eauto]. generalize (AL ofs Tlong OO); simpl; omega.
      1 idtac|eauto]; eauto; omega).
      1 idtac|eauto]. auto.
      1 idtac); eauto 7 using pred1_refl, pred1_ctx_over_refl with fvs ].
      1 idtac; eauto 2 using FO_subst_equiv_eq, eq_equiv.
      1 idtac|eauto]).
      1 idtac|]; eauto.
      1 idtac; eauto.
      1 idtac | eauto].
      1 idtac); eassumption. Defined.
      1 idtac; eapply (zero_neq_one(eq:=eq)).
      1 idtac|eapply update_elections_data_appendEntries_allEntries; eauto]; eauto].
      1 idtac + (eapply R_mem_subsumed in H; [ | eassumption ]));
      1 idtac|eapply removeAfterIndex_contiguous; [eapply entries_sorted_nw_invariant; eauto|eapply entries_contiguous_nw_invariant; eauto]|idtac]; eauto; [|omega].
      1 idtac | eapply ratAdd_comm | idtac].
      1 idtac | eapply perm_swap].
      1 idtac + (eapply lift_eval_idx_Z_impl; [ apply H | ])); eassumption. Qed.
      1 idtac + (eapply lift_eval_idx_or_list_idx_impl; [ apply H | ])); eassumption. Qed.
      1 idtac + eapply interp_op_interp0_op); eassumption).
      1 idtac | eapply H9].
      1 idtac | eapply H2].
      1 idtac + (eapply Forall2_weaken; [ apply lift_eval_idx_Z_impl, H | ])); eassumption. Qed.
      1 idtac + (eapply Forall2_weaken; [ apply lift_eval_idx_or_list_idx_impl, H | ])); eassumption. Qed.
      1 idtac + (eapply Forall2_weaken; [ apply H | ])); eassumption. Qed.
      1 idtac. eapply foldeqs_correct, equiv_pointwise_eqs; (eauto 2).
      1 idtac | eapply evalDist_right_ident].
      1 idtac | eapply (@evalDist_left_ident (Basics.flip rel) _ _ _ _ f);  eauto with typeclass_instances]
      1 idtac | eapply (@evalDist_commute (Basics.flip rel) _ _ c1 c2);  eauto with typeclass_instances]
      1 idtac | eapply (@evalDist_assoc (Basics.flip rel));  eauto with typeclass_instances]
      1 idtac.  eapply equiv_eqs_pointwise; (eauto 1); eapply foldeqs_correct; (eauto 2).
      1 idtac | eapply comp_spec_symm; eapply comp_spec_consequence; [eapply comp_spec_left_ident | intuition] ].
      1 idtac | eapply comp_spec_right_ident].
      1 idtac | eapply comp_spec_eq_swap]
      1 idtac | eapply comp_spec_assoc].
      1 idtac; eapply backward_vars in EQz as [p EQz]; (eauto 2).
      1 idtac; eapply backward_vars in EQy as [m EQy]; (eauto 2).
      1 idtac; eapply backward_vars in EQx as [n EQx]; (eauto 2).
      1 idtac|eapply AllE] end.
      1 idtac (* don't invert original, already-inverted one *)
      1 idtac (* don't invert original, already-inverted hypothesis *)
      1 idtac "done"
      1 idtac "Doing transitivity (n=" n ") on PHOAS with" big ":";
      1 idtac "Doing simpl Denote (n=" n ") on PHOAS with" big ":"; let v := (eval simpl in (PHOAS.Denote ref_PHOAS)) in idtac);
      1 idtac "Doing reif (n=" n ") for" name "with" big ":" | .. ]; time "reif" do_reify ())
      1 idtac "Doing refine let (n=" n ") on PHOAS with" big ":"; let p := fresh in refine (let p := ref_PHOAS in _); clear p);
      1 idtac "Doing printing (n=" n ") for" name "with" big ":";
      1 idtac "Doing pre  (n=" n ") for" name "with" big ":"; time "pre" pre_reify ())
      1 idtac "Doing post (n=" n ") for" name "with" big ":" | .. ]; time "post" post_reify ())
      1 idtac "Doing lazy Denote (n=" n ") on PHOAS with" big ":"; let v := (eval lazy [PHOAS.Denote PHOAS.denote] in (PHOAS.Denote ref_PHOAS)) in idtac);
      1 idtac "Doing identity vm_compute (n=" n ") on PHOAS with" big ":"; let __ := (eval vm_compute in ref_PHOAS) in idtac);
      1 idtac "Doing identity simpl (n=" n ") on PHOAS with" big ":"; let __ := (eval simpl in ref_PHOAS) in idtac);
      1 idtac "Doing identity native_compute (n=" n ") on PHOAS with" big ":"; let __ := (eval native_compute in ref_PHOAS) in idtac)
      1 idtac "Doing identity lazy (n=" n ") on PHOAS with" big ":"; let __ := (eval lazy in ref_PHOAS) in idtac);
      1 idtac "Doing identity cbv (n=" n ") on PHOAS with" big ":"; let __ := (eval cbv in ref_PHOAS) in idtac);
      1 idtac "Doing identity cbn (n=" n ") on PHOAS with" big ":"; let __ := (eval cbn in ref_PHOAS) in idtac);
      1 idtac "Doing cbv  (n=" n ") for" name "with" big ":"; time "cbv" do_cbv)
      1 idtac "Doing cbv Denote (n=" n ") on PHOAS with" big ":"; let v := (eval cbv [PHOAS.Denote PHOAS.denote] in (PHOAS.Denote ref_PHOAS)) in idtac);
      1 idtac "Doing cbn Denote (n=" n ") on PHOAS with" big ":"; let v := (eval cbn [PHOAS.Denote PHOAS.denote] in (PHOAS.Denote ref_PHOAS)) in idtac);
      1 idtac) do_clear
      1 idtac; do 50 (idtac; sleep).
      1 idtac. do 2 (rewrite stepBeta in EQ; trivial; asimpl in EQ; cbn in EQ).
      1 idtac | discrR | assumption ].
      1 idtac.  Discriminate.
      1 idtac. discriminate.
      1 idtac); discriminate.
      1 idtac | discriminate ]).
      1 idtac"didR"; *)try clear progressFlag]);
      1 idtac"didL"; *)try clear progressFlag]);
      1 idtac. destruct x; [ destruct d; now cbn | ]. destruct p; cbn. do 2 f_equal. apply polarityFlip_involution. 
      1 idtac|destruct (operation_is_redundant op (nreg ne res)) eqn:REDUNDANT]].
      1 idtac); [destruct (le_lt_dec (length W2) y)|].
      1 idtac | destruct (le_gt_dec x y); trivial]
      1 idtac|destruct (is_int_zero (nreg ne res)) eqn:INTZERO;
      1 idtac|destruct (is_int_zero (nreg ne dst)) eqn:INTZERO];
      1 idtac; destruct (IHx _ _ H2 H3) as [V].
      1 idtac; DestructHead.destruct_head'_ex; subst; cbn in *.
      1 idtac. destruct H2 as (? & ? & ? & ?). subst.
      1 idtac; destruct (expose2N (BigEnough H)) as [? Heq];
      1 idtac "Delete until here". auto. Qed.
      1 idtac "deadvars!."
      1 idtac | cut (q <= 0)%R; [ intros Rl2' | apply Rlt_le; auto ] ].
      1 idtac "cstring1."
      1 idtac "cstring'."
      1 idtac "cstep found unexpected" G 
      1 idtac | crush].
      1 idtac "crash_xform"; progress autorewrite with crash_xform
      1 idtac "couldn't prove" G end
      1 idtac "couldn't find variable! [2]" idx
      1 idtac "couldn't find variable! [1]" idx
      1 idtac "couldn't apply sym_eval_any! (SF case)";
      1 idtac "Could not solve some subgoal("msg"):";idtac G;shelve
      1 idtac "could not refine" G "with" G' end
      1 idtac "corr3 pre"; eapply corr3_from_corr2_rx; eauto with prog
      1 idtac "corr3"; eapply pimpl_ok3; intros
      1 idtac "corr2"; step
      1 idtac "Converting numeric representations by the hack of storing to union-field" id1
      1 idtac | |- context[id_fix_2] => idtac end)
      1 idtac "Context:" G end;
      1 idtac_context :=
      1 idtac + constructor); congruence.
      1 idtac|constructor].
      1 idtac | constructor]).
      1 idtac; congruence. }
      1 idtac; congruence.
      1 idtac]; clear H; try subst) in
      1 idtac]; clear H; try subst).
      1 idtac; clear H.
      1 idtac] (*check only one goal left.*) )
      1 idtac; cbn [ord'] in H9.
      1 idtac. cbn; now rewrite <-H0, repeated_length.
      1 idtac; cbn in *.
      1 idtac | case p ]; 
      1 idtac "BYE";
      1 idtac "build_merge_stack_placeholders start");
      1 idtac "build_merge_stack_placeholders end")
      1 idtac "build_merge_base_addresses start");
      1 idtac "build_merge_base_addresses end")
      1 idtac "build_inputs start");
      1 idtac "build_inputs end")
      1 idtac "   before field...";
      1 idtac; beautify.
      1 idtac "Bad let-in function" f
      1 idtac "bad"
      1 idtac a v f; do_set a v f
      1 idtac; auto with typeclass_instances.  
      1 idtac; auto with roof_laws.
      1 idtac ]; auto with real.
      1 idtac | auto with * ].
      1 idtac "autorewrite with sublist in * |-."
      1 idtac "autorewrite with sublist."
      1 idtac; autorewrite with Server; auto;
      1 idtac "autorewrite with norm."
      1 idtac; auto.
      1 idtac "at app0"; *)
      1 idtac "at app"; *)
      1 idtac | assumption | assumption ].
      1 idtac. assert (ord' L <= 1).
      1 idtac "!asimpl_var_id_r";
      1 idtac "asimpl_var_id_l_ca";
      1 idtac "asimpl_var_id_l";
      1 idtac "!asimpl_up_scons";
      1 idtac "!asimpl_subst_merge";
      1 idtac "!asimpl_scons_up_f";
      1 idtac "!asimpl_scons_up";
      1 idtac "asimpl_scons_comp";
      1 idtac "asimpl_id_id_r";
      1 idtac "asimpl_id_id_l";
      1 idtac "asimpl_funcomp_assoc";
      1 idtac "Area method:";
      1 idtac | apply Zmin_sym ].
      1 idtac | apply Zle_trans with 1%Z; auto with zarith ].
      1 idtac | apply trivial_col3 ]
      1 idtac | apply trivial_col2 ]
      1 idtac | apply trivial_col1 ]
      1 idtac | apply sym_equal; auto with float ].
      1 idtac + apply S'.eq_sym); assumption.
      1 idtac | _ => apply <- semax_seq_skip end;
      1 idtac | apply RmaxLess1 ].
      1 idtac | apply Refl ].
      1 idtac | apply powerRZ_le; auto with arith real ].
      1 idtac | apply minus_n_O ].
      1 idtac | apply minus_n_n ].
      1 idtac | apply le_max_l ]; apply le_max_r).
      1 idtac | apply le_IZR ]; auto with float.
      1 idtac | apply isMax_inv1 with (1 := H'4) ]; auto.
      1 idtac | apply id_right ].
      1 idtac | apply HrecA ].
      1 idtac + apply H); eassumption. Qed.
      1 idtac; apply Ha.
      1 idtac | apply H6 ].
      1 idtac | apply (FshiftCorrect radix); auto ].
      1 idtac | apply canonical_nzeroP with (ltM := ltM) (p := l) ]; 
      1 idtac | apply canonical_imp_canonical with (a := a); auto ]; 
      1 idtac | apply canonical_imp_canonical with (a := a0); auto ].
      1 idtac | apply Axm; right; constructor ].
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaDefOf with lazy_no_rt" (fun _ => let __ := eval lazy_no_rt in (GallinaDefOf p) in idtac);
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaDefOf with lazy_no_rt" (fun _ => let __ := eval lazy_no_rt in (GallinaDefOf p) in idtac)
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaAxOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxOf p) in idtac);
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaAxOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxOf p) in idtac)
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaAxComputedOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxComputedOf p) in idtac);
      1 idtac_and_time prime bitwidth p (@None unit) "GallinaAxComputedOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxComputedOf p) in idtac)
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaDefOf with lazy_no_rt" (fun _ => let __ := eval lazy_no_rt in (GallinaDefOf p) in idtac);
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaDefOf with lazy_no_rt" (fun _ => let __ := eval lazy_no_rt in (GallinaDefOf p) in idtac)
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxOf p) in idtac);
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxOf p) in idtac)
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxComputedOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxComputedOf p) in idtac);
      1 idtac_and_time prime bitwidth index p (@None unit) "GallinaAxComputedOf with lazy" (fun _ => let __ := eval lazy in (GallinaAxComputedOf p) in idtac)
      1 idtac_and_time" constr(prime) constr(bitwidth) constr(p) constr(method) string(descr) tactic3(tac) :=
      1 idtac_and_time" constr(prime) constr(bitwidth) constr(index) constr(p) constr(method) string(descr) tactic3(tac) :=
      1 idtac_and_time2" constr(prime) constr(bitwidth) constr(p) constr(method) string(descr) tactic3(tac) :=
      1 idtac_and_time2" constr(prime) constr(bitwidth) constr(index) constr(p) constr(method) string(descr) tactic3(tac) :=
      1 idtac (*alternative: fail 99 "Fail in tactic check_vl_eq_args"*)] .
      1 idtac. all:Lia.lia. } 
      1 idtac "Aggregate time (n=" n ") for" name "with" big ":").
      1 idtac | access_size.two => idtac | access_size.four => idtac end;
      1 idtac | abstract (exact I) ].
      1 idtac | abstract apply Refl ].
      1 idtac "About to try " H; apply H
      1 idtac "6"
      1 idtac "5"
      1 idtac4 {T1 T2 T3 T4} (msg1 : T1) (msg2 : T2) (msg3 : T3) (msg4 : T4) := Build_cidtac4 : True.
      1 idtac4 ?msg1 ?msg2 ?msg3 ?msg4) => idtac msg1 msg2 msg3 msg4; exact I : typeclass_instances.
      1 idtac4 msg1 msg2 msg3 msg4 :=
      1 idtac "4"
      1 idtac3 {T1 T2 T3} (msg1 : T1) (msg2 : T2) (msg3 : T3) := Build_cidtac3 : True.
      1 idtac3 ?msg1 ?msg2 ?msg3) => idtac msg1 msg2 msg3; exact I : typeclass_instances.
      1 idtac3 msg1 msg2 msg3 :=
      1 idtac "3"
      1 idtac2 {T1 T2} (msg1 : T1) (msg2 : T2) := Build_cidtac2 : True.
      1 idtac2 ?msg1 ?msg2) => idtac msg1 msg2; exact I : typeclass_instances.
      1 idtac2 msg1 msg2 :=
      1 idtac. 2: eauto. eauto. eauto.
      1 idtac 2 *)
      1 idtac 1 B;  *)
      1 idtac "1" ;
      1 idtac "$$$ plugin" x ts args.
      1 idtac "$$$ ltac" x ts args.
      1 idtac|]
      1 idtac]. 
      1 idtac]). 
      1 idtac]) ||
      1 idtac] || *)
      1 idtac] | ].
      1 idtac.                   
      1 idtac'".
      1 idtac".
      1 idtac | _ => 
      1 idtac | 
      1 idtac ] ;
      1 idtac .. ];
      1 idtac ).
      1 idtac "============================";
      1 idtac "-" ;
      1 idtac "*" ;
#+end_example


* debug

#+begin_src shell  :results output
find /mnt/data1/lang/coq/*/* -name \*.v   -exec grep -i -o -P "((reify|print|trace|debug|profile|inspect|dump).+)" {} \; | sort |uniq -c | sort -n -r | tee recurse.txt
#+end_src

#+RESULTS:
#+begin_example
   1948 Printing Width 1000000.
    858 traceEq.
    407 Printing Universes.
    376 Printing All.
    273 printing).
    225 Printing Implicit Defensive.
    205 debug,
    205 debug"
    143 trace))
    141 printing λ %\ensuremath{\lambda}% #&lambda;# *)
    141 printing o %\ensuremath{\circ}% #&#x25cb;# *)
    141 printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
    140 printing π %\ensuremath{\pi}% #&pi;# *)
    140 printing 'π' %\ensuremath{\pi}% #&pi;# *)
    140 printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
    140 printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
    140 printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
    140 printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
    140 printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
    140 printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
    140 printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
    140 printing * %\ensuremath{\times}% #&times;# *)
    140 printing '*' %\ensuremath{\times}% #&times;# *)
    140 printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
    140 printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
    140 printing ★ %\ensuremath{\star}% #&#9733;# *)
    140 printing '★' %\ensuremath{\star}% #&#9733;# *)
    140 printing "★" %\ensuremath{\star}% #&#9733;# *)
    140 printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
    140 printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
    140 printing ≅ %\ensuremath{\cong}% #&cong;# *)
    140 printing :> %:\ensuremath{>}% #:># *)
    140 printing ':>' %:\ensuremath{>}% #:># *)
    140 printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
    140 printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
    140 printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
    140 printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
    140 printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
    140 printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
    140 printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
    140 printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
    139 printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
    139 printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
    139 printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
    139 printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
    139 printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
    139 printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
    139 printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
    139 printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
    139 printing ∧ %\ensuremath{\wedge}% #&and;# *)
    139 printing ∨ %\ensuremath{\vee}% #&or;# *)
    139 printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
    139 printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
    139 printing × %\ensuremath{\times}% #&times;# *)
    139 printing '×' %\ensuremath{\times}% #&times;# *)
    139 printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
    139 printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
    139 printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
    139 printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
    139 printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
    139 printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
    139 printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
    139 printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
    139 printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
    139 printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
    139 printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
    139 printing ⊂ %\ensuremath{\subset}% #&sub;# *)
    139 printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
    139 printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
    139 printing → %\ensuremath{\rightarrow}% #&rarr;# *)
    139 printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
    139 printing ¬ %\ensuremath{\neg}% #&not;# *)
    139 printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
    139 printing ≤) %\ensuremath{\le)}% #&le;)# *)
    139 printing ≤ %\ensuremath{\le}% #&le;# *)
    139 printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)
    139 printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
    139 printing ← %\ensuremath{\leftarrow}% #&larr;# *)
    139 printing ∈ %\ensuremath{\in}% #&isin;# *)
    139 printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
    139 printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
    139 printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
    139 printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
    139 printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
    139 printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
    139 printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
    139 printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
    139 printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
    139 printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
    139 printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
    139 printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
    139 printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
    139 printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
    139 printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
    139 printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
    139 printing ² %\ensuremath{^2}% #<sup>2</sup># *)
    139 printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
    139 printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
    139 printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
    133 Print).
    130 printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
    130 printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
    130 printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
    109 trace.
    105 printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
    104 printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
    104 printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
    104 printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
    104 printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
     87 Printing Coercions.
     82 printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
     82 printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
     82 printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
     82 printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
     79 Debug.
     79 debug ::
     78 trace)
     76 Printing Projections.
     74 trace))))
     71 printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
     69 traceinf -> Prop :=
     68 printing ¬( %\ensuremath{\neg}(% #&not;(# *)
     68 printing ∪ %\ensuremath{\cup}% #&cup;# *)
     68 printing '∪' %\ensuremath{\cup}% #&cup;# *)
     68 printing ∩ %\ensuremath{\cap}% #&cap;# *)
     68 printing '∩' %\ensuremath{\cap}% #&cap;# *)
     66 Reify Pattern patterns_vst +=
     58 trace -> state -> Prop :=
     58 trace : nat =>
     57 trace)))
     57 Print foo.
     56 trace length *)
     56 printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
     56 debug :: ___builtin_write32_reversed ::
     54 reify_cache_gen.
     51 Printing Implicit.
     50 trace st ->
     50 printing *)
     48 printing) : bool_scope.
     47 trace_length; eauto.
     45 trace)))))
     45 reify (). Time Qed.
     44 Reify.
     44 debug :: ___builtin_nop ::
     43 trace -> val -> mem -> Prop :=
     42 dUMP.
     42 debug.
     41 Printing Notations.
     38 traces. *)
     38 debug : ident := 36%positive.
     36 trace st'.
     36 Profile.*)
     36 Profile.
     36 printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
     36 printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
     34 Print t.
     33 Printing.
     33 DEBUG_UNFOLD.
     32 Trace := t; Memory := m; Locals := l; Functions := e }>
     32 trace; [| eauto].
     32 reify.func_defs.
     31 traces *)
     30 Trace := tr;
     30 reify.types.
     30 reify.funcs.
     29 trace:
     29 printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
     28 trace recs : nat =>
     28 reifyl (lterm:=lterm)) with
     28 printing/parsing *)
     26 Printing Let prod.
     26 printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
     25 trace; eauto.
     25 Debug Verbosity 2.
     24 trace (gtrace, G)
     24 trace;
     24 Print Universes.
     24 print_nf e ;;
     24 debug : ident := 52%positive.
     23 Print f.
     22 print (Message.of_ident @X).
     22 Printing Existential Instances.
     22 printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
     22 printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
     21 trace w t w'
     21 traces:
     21 printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
     21 printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
     21 Debug Unification.
     20 traces L1_receptive); eauto. intros [EQ | EQ].
     20 trace_serial0; eauto.
     20 TraceInv
     20 TraceFrom_T Sini x ->
     20 reify_vst_typ) =>
     20 Reify.ReifyCommon.
     20 reify_flat_type t) in
     20 reify.bool_funcs.
     20 printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
     20 printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
     20 printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
     20 print(cur)
     19 trace))) &&
     19 Reify_rhs _ := ReifyCommon.post_Reify_rhs ().
     19 reify_rec x in
     19 print_universe_instance u
     19 Printing Let sigT.
     19 printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
     19 printing
     19 debug :: ___builtin_nop :: ___builtin_write32_reversed ::
     18 trace_case st.(io_log) st'.(io_log).
     18 trace1.
     18 Trace :=
     18 trace)))).
     18 reify_debug_level in
     18 print_wf_set selected)
     18 print_spatial_model
     18 print(" ".join(r""" "%s" """.strip() % (r"'"'\''"'" if chr(i) == "'"'"'" else repr(""" "" """.strip()) if chr(i) == """ " """.strip() else repr(chr(i))) for i in range(256)))' # " to satisfy Coq's comment parser *)
     18 Printing Allow Match Default Clause.
     18 printed *)
     18 Print bar.
     17 reify.
     17 Print Graph.
     17 Printf.
     16 trace -> mem -> val -> Prop :=
     16 trace : forall st st',
     16 reify_to_poly fx x
     16 reify.rtac_base.
     16 reify.get_set_reif.
     16 print_term.
     16 Printing Goal Names.
     16 Printing Depth 100000.
     16 Print). *)
     16 inspect; simp _reduce_stack.
     16 debug : ident := 53%positive.
     15 TraceUtil.
     15 trace : nat => cTriplePi3 (cTriplePi1 trace)).
     15 trace_equiv
     15 traceEq. auto.
     15 trace; eauto. destruct t; auto. destruct t; tauto.
     15 Reify.BenchmarkScaffolding.
     15 DebuggingHooks.
     14 reify.update_tycon.
     14 reify.typ_eq.
     14 reify.set_reif.
     14 reify" relations which are equivalences to applications of the overloaded [equiv] method
     14 reify_rec x0 in
     14 reifyl (lterm:=lb) (lvar:=fv)) in r
     14 ReifyLemma.
     14 reify_goal lvar lexpr lterm:=
     14 reify_goal fv lexpr lterm;
     14 Printing Records.
     14 Print bc ;;
     13 trace_n1_ind => H_init /=.
     13 trace -> int -> Prop :=
     13 Trace in |- *.
     13 Trace.
     13 trace :
     13 Reify_rhs _ := Reify_rhs_of Reify ().
     13 ReifyCommon.refresh *)
     13 Profile. *)
     13 printing ⋃ %\ensuremath{\bigcup}% #&#8899;# *)
     13 printing ⋂ %\ensuremath{\bigcap}% #&#8898;# *)
     13 printed as [Nil]. *)
     13 Print a.
     13 print,
     13 debug : ident := 58%positive.
     13 debug : ident := 56%positive.
     13 debug eauto.
     12 trace : nat => cPairPi2 (cTriplePi3 (cTriplePi1 trace))).
     12 trace is valid *)
     12 TraceFrom in |- *; split; trivial.
     12 trace))))) &&
     12 trace ->
     12 reify_type t) in
     12 reify.reify.
     12 reify one opp add mul a in
     12 reify :=
     12 print_wf_set
     12 Print Timing Profile. *)
     12 Print Timing Profile.
     12 Print test.
     12 print_pures_list
     12 printing) : form_scope.
     12 Printing Factorizable Match Patterns.
     12 print_defs print_term Γ l ++ nl ++
     12 inspect (unfold_cofix mfix idx) := {
     12 inspect (decompose_stack ρ) := {
     12 dUmp2.
     12 dUmp1.
     12 debug : ident := 55%positive.
     12 debug : ident := 39%positive.
     11 trace * val * mem) :=
     11 trace in *.
     11 trace))))))))))
     11 trace)))))))))
     11 Reify x :=
     11 Reify_rhs _ := do_Reify_rhs_of Reify ().
     11 reify" ; *)
     11 Print toto.
     11 Print Ltac f.
     11 Printing Parentheses.
     11 Printing Let sig.
     11 printf".
     11 printed
     11 Print baz.
     11 debug : ident := 41%positive.
     10 trace) (vres : val) (m2 : mem),
     10 trace -> val -> Prop :=
     10 trace -> state -> Prop.
     10 trace) (S': state) : Prop :=
     10 traces L.
     10 TRACES_INV.
     10 traces ge t1 t2 ->
     10 traces ge (ev1 :: nil) (ev2 :: nil) ->
     10 trace - S (cPairPi1 (cTriplePi3 trace))) recs *
     10 TRACES.
     10 trace represented by [info]. *)
     10 TraceRelations.
     10 trace of observable events.
     10 trace of observable events
     10 trace of input/output events performed during this
     10 trace : nat => cTriplePi1 (cTriplePi1 trace))
     10 trace_mutual_exclusion' h tr ->
     10 trace_length; eauto. destruct t1; simpl; intros.
     10 TRACEINF_REACTS.
     10 trace generated by the call (can be empty).
     10 trace E R),
     10 trace; eauto. exploit assign_loc_trace; eauto.
     10 trace; eauto. destruct t1; simpl; tauto.
     10 trace client id tr ->
     10 trace_case : forall st st',
     10 trace).
     10 reify_to_poly fx x in
     10 reify.reified_ltac_lemmas.
     10 reify.reflexivity_tacs.
     10 reify_rec x1 in
     10 reify_rec eC in
     10 Reify.PHOAS.
     10 reify_now_later
     10 reify_expr_tac.
     10 print_nf (id ++ " has been translated as " ++ id') ;;
     10 Print nat.
     10 Print Module N.
     10 Print Instances nat.
     10 Printing If bool.
     10 Print Custom Grammar foo.
     10 Print bc).
      9 trace w t w'.
      9 trace w t w' ->
      9 trace tr).
      9 trace -> mem -> Prop :=
      9 trace. *)
      9 Reify x := Reify_of reify x.
      9 reify_rec y in
      9 reify a nb in
      9 Print Universes.*)
      9 Print Typing Flags.
      9 Print type.
      9 prints [myfoo0 1 HI], but should print [myfoo01 HI]  *)
      9 Printing Wildcard.
      9 Printing Synth.
      9 printing [myfoo0 1 HI], but should print [myfoo01 HI]  *)
      9 printing ↘ %\ensuremath{\searrow}% #&#x2199# *)
      9 printing ≄ %\ensuremath{\not\simeq}% #&#9772;# *)
      9 printing ⁸ %\ensuremath{^9}% #<sup>9</sup># *)
      9 printing ₈ %\ensuremath{_9}% #<sub>9</sub># *)
      9 printing. *)
      9 Print eq_refl.
      9 Print Canonical Projections. *)
      9 print as [[[[[? ?] ?] l1] τ1]|] eqn:e1. 2: discriminate.
      9 Printable *)
      9 Print.
      9 inspect as [[f' a'] decapp'].
      9 Debug t' ;;
      9 debug : ident := $"__builtin_debug".
      8 trace_of_ostrace_app.
      8 trace of observable events performed during the execution. *)
      8 trace_mutual_exclusion' holder tr'
      8 trace h key value i h')
      8 trace, H) (gtrace, G)
      8 TraceFrom_T Sini x)
      8 TraceFrom Sini x)
      8 trace_erasure tr tr')
      8 TraceErasure.
      8 trace_case; eauto.
      8 trace b ofs rest
      8 trace b ofs es
      8 trace]]]]].
      8 trace))))) *
      8 trace))) *
      8 trace) :=
      8 reify var term :=
      8 reify_type T in
      8 reify_type T :=
      8 reify_tag := constr:(@exprf base_type_code interp_base_type op var) in
      8 reify.set_load_store.
      8 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify n @ GallinaReify.Reify m @ GallinaReify.Reify m')
      8 reify_rec v in
      8 reify_rec ev in
      8 Reify Pattern patterns_vst_hastype +=
      8 reify one opp add mul b in
      8 reifyl (lterm:=lb)) in r
      8 reify.hoist_later_in_pre.
      8 reifyf_var x' ltac:(fun t v => lazymatch t with
      8 ReifyDebugNotations.
      8 reify.clight_expr_eq.
      8 profile.
      8 print_term Γ true false c ++ ")"
      8 print_term Γ true false br
      8 print (s:string) := Message.print (Message.of_string s).
      8 print; simpl; firstorder auto.
      8 print(r"""
      8 Print Notation "x $ x".
      8 print (Message.of_string s)
      8 print('  Local Notation T := %s.' % make_tele(alpha[:fixn], '@' + ALPHA[fixn]))
      8 Print json_parser(*_ocaml*).
      8 printInt" @ [printIntS],
      8 printing) : subst_scope.
      8 Printing Let sigT2.
      8 Printing Let sig2.
      8 printing, at level 10).
      8 printing) *)
      8 print := fun b ofs => m_footprint P b ofs \/ m_footprint Q b ofs
      8 print := fun b ofs => False
      8 printf (Tfunction
      8 printer : float_scope.
      8 printer
      8 print eqn:e2.
      8 print eqn:e1.
      8 printed by clightgen in CompCert 3.4 *)
      8 print("")
      8 inspecting all possible pairs of elements of a list. *)
      8 debug (s:string) := match debug_on with
      8 Debug Ssreflect.
      8 debug_on := true.
      7 trace, zero_or_one_outputs_per_step.
      7 Trace {X Y : UU} (f : X -> Y) (y : Y) : HFiberTrace Y := ∑ x : X, f x = y.
      7 Trace.view trace_name
      7 trace the side effects of the `foo` function by running:
      7 trace the side effects of a function that uses a homotopy fiber:
      7 trace the side effects of a Coq function, you can use the Coq standard library module `Coq.Init`. The `Coq.Init` module provides tools for creating and manipulating traces of Coq objects, including homotopy fibers.
      7 trace the side effect of `hfiber` and print it out. One way to do this is to define a new type that has both the original `X` value and the `y` value, and then use pattern matching on this new type to extract the information you need. Here's an example:
      7 TraceT))
      7 trace -> state -> Prop)
      7 Traces.
      7 trace_prefix_ret.
      7 trace or print out the side effects of this definition in Coq. However, you can observe the behavior of `hfiber` by constructing instances of it and using them in your proofs. For example, you might use the following code to create an instance of `hfiber`:
      7 trace or print out a side effect of hfiber, we can use the match statement in Coq. For example:
      7 trace or print out a side effect in Coq, you can use the `Coq.Interpreters.Evaluator` module. Here's an example:
      7 trace or print out a side effect in a Coq proof, you can use the Coq `display` command to show the contents of a variable or data structure. For example:
      7 trace, no_output_at_backup.
      7 trace named `trace_name` for the `foo` function and its input value `H`. You can then view the trace using the `Coq.Trace.view` command, like this:
      7 trace it or print out a side effect to capture it?
      7 Trace := hfiber fib x.
      7 trace f' t t'.
      7 trace_ev_outputs_eq.
      7 traced by the `Coq.Init` module.
      7 Trace.create trace_name foo H
      7 trace; auto.
      7 Trace {A B : UU} (a : A) : HFiberTrace B := a.
      7 traceability, it is not directly clear how to capture or print out a side effect from this definition. However, if we assume that X has some additional structure or properties that allow us to track changes to its elements, we could potentially use that information to infer the location of the side effect in the homotopy fiber.
      7 traceability and side effect analysis are important considerations in many Coq proofs, especially those involving higher-order functions or more complex data structures. In general, it's important to carefully design our definitions and assumptions in a way that allows us to reason about their behavior and potential side effects.
      7 trace))))))
      7 trace)))) &&
      7 trace *)
      7 reifyZpos (R:Type)  lvar (p:positive)
      7 reifyZneg (R:Type)  lvar (p:positive)
      7 reify_zero (R:Type)  lvar op
      7 reifyZ0 (R:Type)  lvar 
      7 reify_var (R:Type) t lvar i 
      7 reify_Term var term'
      7 reify_sub (R:Type)
      7 reify (sub:=op) (PEsub e1 e2) lvar (op t1 t2).
      7 reify (sub:=op) e2 lvar t2}
      7 reify (sub:=op) e1 lvar t1}
      7 reify (R:Type)`{Rr:Ring (T:=R)} (e:PExpr Z) (lvar:list R) (t:R).
      7 reify (Rr:= Rr) (PEX Z (Pos.of_succ_nat i))lvar t
      7 reify (Rr:= Rr) e1 lvar t1}
      7 reify (ring1:=op) (PEc 1%Z) lvar op.
      7 reify (ring0:=op)(PEc 0%Z) lvar op.
      7 Reify ReprFunChoice A B R T Hequiv Hcompat Hexists.
      7 Reify.Reify s)
      7 Reify r2 in
      7 Reify r1 in
      7 reify_pow (R:Type) `{Ring R}
      7 reify (PEpow e1 n) lvar (pow_N t1 n)|1.
      7 reify (PEmul (PEc z) e2) lvar
      7 reify (PEc (Zpos p)) lvar (Zpos p)|11.
      7 reify (PEc (Zneg p)) lvar (Zneg p)|11.
      7 reify (PEc Z0) lvar Z0|11.
      7 reify_opp (R:Type)
      7 reify (opp:=op) (PEopp e1) lvar (op t1).
      7 reify (opp:=op) e1 lvar t1}
      7 reify_one (R:Type)  lvar op
      7 Reify := non_dep_dep_functional_rel_reification FunReify).
      7 reify_nil (R:Type) lvar 
      7 reify_mul (R:Type) 
      7 reify (mul:=op) (PEmul e1 e2) lvar (op t1 t2)|10.
      7 reify (mul:=op) e2 lvar t2}
      7 reify (mul:=op) e1 lvar t1}
      7 reify_mul_ext (R:Type) `{Ring R}
      7 reifyl (R:Type) lexpr lvar lterm 
      7 reifyl (lterm:=lb)) with
      7 reifylist (R:Type)`{Rr:Ring (T:=R)} (lexpr:list (PExpr Z)) (lvar:list R) 
      7 reifylist (Rr:= Rr) nil lvar (@nil R).
      7 reifylist (Rr:= Rr) lexpr lvar lterm}
      7 reifylist (Rr:= Rr) lexpr2 lvar lterm2} 
      7 reifylist (Rr:= Rr) (e1::lexpr2) lvar (t1::lterm2).
      7 Reify lH :=
      7 reify_IZR z lvar {_ : can_compute_Z z} : reify (PEc z) lvar (IZR z).
      7 reify_goal l le lb:=
      7 reify_goal l le1 lb1
      7 reify_goal fv le lb ;
      7 reify equations of the context *)
      7 Reify EM C H. intuition auto using
      7 reify e2 lvar t2}
      7 reify e1 lvar t1}
      7 reify_cons (R:Type) e1 lvar t1 lexpr2 lterm2
      7 reify a second time, with the good order
      7 reify and process.
      7 Reify A (fun _ => B) R H) as (f,Hf).
      7 reify_add (R:Type)
      7 reify (add:=op) (PEadd e1 e2) lvar (op t1 t2).
      7 reify (add:=op) e2 lvar t2}
      7 reify (add:=op) e1 lvar t1}
      7 Reify A B R H.
      7 Reify A0 B0 R0 H0) as (f, Hf).
      7 reify ().
      7 print v;  (* Output: Hello, world! *)
      7 print using a Coq library converting sequences of
      7 Print u.
      7 print t = Some (k,n,ui,l,τ) →
      7 prints a message to the console. We then call `f` with an input of `42` and evaluate the result using the `eval_expr` function from the `Coq.Interpreters.Evaluator` module. The output is the side effect of running the `println` statement, which is printed to the console.
      7 print out the value of x for each point in X that maps to y under f. We can modify this code to capture other types of side effects as well, depending on our needs.
      7 print l vl :=
      7 print l vl
      7 print l var.
      7 Println "x = " ++ x;
      7 println "The value of X is " ++ show x ++ " and the value of Y is " ++ show y;
      7 print l (@nil bool)
      7 println "Hello, world!"
      7 Print le.
      7 print_int, Gfun(Internal f_print_int)) ::
      7 print_int := {|
      7 printing wrapper. An A : qualifier q T
      7 printing priority to fully typed exists *)
      7 printing out the side effects, it's not clear what you mean by "side effects" in this context. If you have a specific question about how to print out the computation of a homotopy fiber or its underlying data, I would be happy to help.
      7 printing out a side effect" in this case. However, if you have a specific question about how to trace the computation of a homotopy fiber or print out its side effects in Coq, I would be happy to help.
      7 printing of [nat] numbers *)
      7 printing of decimal numbers *)
      7 PrintingNotations.
      7 Printing If sumor.
      7 Printing If sumbool.
      7 printing |-> %\ensuremath{\mapsto}% #&#21A6# *)
      7 Printing All. *)
      7 printing)
      7 printHfiberTrace {X Y : UU} (fiberTrace : HFiberTrace Y) : Void := match fiberTrace {
      7 printHfiberTrace` to print out the side effect of a `hfiber` construction. For example:
      7 printHfiberTrace fiberTrace;
      7 print_goal.
      7 printf (Tfunction (Tcons (tptr tschar) Tnil) tint
      7 printf,
      7 printf"
      7 printers of [positive], [N], [Z]. *)
      7 printer *)
      7 printed using a native ML library of arbitrary
      7 print, 1999.
      7 print.
      7 debug kind text targs => true
      7 debug_intuition := idtac "<infomsg>Warning: debug_intuition should not be used in production code.</infomsg>"; intuition debug auto with *.
      7 debug : ident := 42%positive.
      7 Debugging tactics to show the goal during evaluation. *)
      7 debug *)
      6 trace with
      6 trace_user *)
      6 trace_unique *)
      6 trace_tx_event.
      6 trace; try eassumption.
      6 trace_trans H_star.
      6 trace_trans _ _ _ _ (failed', net)) => //.
      6 Trace := (Trace Annot).
      6 trace T*)
      6 traces' z' c', consume_trace z z' t' /\
      6 traceSim].
      6 trace s' /\ exists traces' z' c', consume_trace z z' t' /\
      6 trace_serial *)
      6 trace := (seq machine_event).
      6 TraceSemantics.yielded target d ->
      6 trace - S (cPairPi2 (cTriplePi3 trace))) recs))
      6 traces agree on the external events *)
      6 TraceRelation step_failure :=
      6 trace recs : nat => recs).
      6 trace_prefixF (upaco2 trace_prefix_ r)
      6 trace_ordered *)
      6 trace_ok : valid_trace st';
      6 trace_of_ostrace (strip_common_prefix IOEvent_eq t t') in
      6 trace_occ tr).
      6 TraceNotNice.
      6 trace : nat => trace)
      6 trace : nat => cPairPi2 (cTriplePi3 trace)).
      6 trace : nat => cPairPi1 (cTriplePi3 trace)).
      6 trace n' (app_trace t t') traces' z' s' c' m' /\
      6 trace n' (app_trace t t') traces' z' c' m' /\
      6 trace_monotone in Hexec_post_u.
      6 trace_mono; eauto.
      6 trace_itree_match *)
      6 Trace.ITraceDefinition
      6 trace_irr.
      6 trace_inj & external_step);
      6 trace_inj. 
      6 TraceImpNice.
      6 trace]] Hbuf]]]]]]].
      6 TraceForallNice.
      6 trace event*)
      6 trace_erasure_nth' in Hu; eauto.
      6 trace E R)
      6 Trace_Ensembles
      6 trace_dec b ofs' T) as [Hfree | HnotFree].
      6 trace_console0.
      6 trace_console *)
      6 trace_case t' t'' ->
      6 trace_case t t' ->
      6 trace_case_refl : core.
      6 trace_case.
      6 trace b ofs ev ->
      6 Trace (A : Type) :=
      6 Trace A -> Trace A -> Trace A
      6 Trace A -> Trace A
      6 trace as (Hlen & Hbounds & Hi & Hrest).
      6 Trace A
      6 trace)).
      6 trace))))).
      6 reify Σ Γ A ;;
      6 reify_var_for_in_is base_type_code x t not_x) =>
      6 reify_type_of x) x) (only parsing) : foo_scope.
      6 reify_TypeCode A in
      6 reify_tauto' Q2 vars in
      6 reify_tauto' Q1 vars in
      6 reify.symexe.
      6 reify_rec x2 in
      6 reify_rec ex in
      6 reify_O
      6 reify in r2. rewrite r2.
      6 reify in r1. rewrite r1.
      6 reifying
      6 reify_hlip_ind)
      6 Reify (fun y : Z
      6 reify_flat_type A in
      6 reify_expr reify_vst k
      6 reify correctly *) in
      6 Reify.Common.
      6 reify.app_lemmas.
      6 profile_parser_results
      6 profile-ltac-cutoff" "0.0") -*- *)
      6 PrintTermTree.
      6 Print t2.
      6 Print swap.
      6 prints/articles/20/tr20.pdf])
      6 print((r'''%sDerive reified_%s_gen
      6 Print prod_rect.
      6 print_nf  (id ++ " has been translated as " ++ id') ;;
      6 Print Nat.t.
      6 Print myrefl.
      6 Print myplus.
      6 Print merge.
      6 Print LoadPath.
      6 print_list (fun '(b, (na, _, _)) => na ++ " " ++ b)
      6 print_intr (Tfunction (Tcons tuint Tnil) tvoid cc_default))
      6 Print insec.
      6 print. In particular when fully applied it has type unit.
      6 Print inmod.
      6 Printing Width 1000.
      6 Printing Unfolded Projection As Match.
      6 printing time *)
      6 printing the resulting message as per
      6 Printing specifications are of the form
      6 Printing/Parsing of bytes *)
      6 printing of hexadecimal numbers *)
      6 printing) : nat_scope.
      6 printing modifiers.
      6 Printing Matching.
      6 printing it.
      6 printing involves fewer rules. *)
      6 printing for p r *)
      6 printing declarations. *)
      6 printing commands following a printf-like syntax. The "format" scope parses
      6 Printing Coercions. idtac.
      6 Printing Coercion i.
      6 printing, at level 0).
      6 printing annotations *)
      6 Printing All. Set Printing Universes.
      6 Printing all kinds of Ltac generic arguments *)
      6 printing.  *)
      6 Print HintDb quxdb.
      6 Print HintDb foodb.
      6 Print HintDb bardb.
      6 Print Grammar constr.
      6 PrintGoal.
      6 printf will parse a format and generate a function taking the
      6 Print Func.
      6 Print ftyp.
      6 printf notation for easiness of writing messages *)
      6 printf : (message -> 'r) -> ('a, unit, message, 'r) format -> 'a :=
      6 printf" fmt(format) := printf fmt.
      6 printf fmt := Format.kfprintf print fmt.
      6 printf fmt := Format.kfprintf (fun x => x) fmt.
      6 printf" fmt(format) := fprintf fmt.
      6 printf behaves similarly but return the message as a value instead of
      6 printer (x : int_wrapper) : pos_neg_int63 := Pos (int_wrap x).
      6 printer (x : int_wrapper) : pos_neg_int63 :=
      6 printer (x : float_wrapper) : float := float_wrap x.
      6 printer : uint63_scope.
      6 printer : sint63_scope.
      6 printer not called *)
      6 printer : int63_scope.
      6 Printer.
      6 Print eq_sym.
      6 print Env.nil_Repr
      6 printed via the [Number Notation] command, by conversion from/to
      6 printed. They can take the following values.
      6 printed only using projection notation. r.(@p) *)
      6 print_defs print_term Γ l ^ nl ^
      6 Print Coercions.
      6 print_branch Γ arity br {struct br} :=
      6 print_branch Γ arity br) brs in
      6 Print blah0.
      6 Print (Ast.tConst kn nil))).
      6 Print Assumptions pandora.
      6 Print Assumptions E.D.f.
      6 Print Assumptions Bar.t1.
      6 inspect (unfold_fix mfix idx) := {
      6 inspect (lookup_env Σ c) := {
      6 inspection *)
      6 inspect (decompose_stack π2) := {
      6 inspect (decompose_stack π1) := {
      6 inspect (decompose_stack π') := {
      6 inspect (decompose_stack θ) := {
      6 inspect _).
      6 dUMPCatUMP2.
      6 dUMPCatUMP1.
      6 DEBUG_UNFOLD in *.
      6 Debug Tactic Unification.
      6 Debug SsrMatching.*)
      6 Debug "simple-compiler".
      6 Debug "plop3" ;;
      6 Debug "plop2" ;;
      6 Debug "plop1" ;;
      6 debug := [ Off | Info | Debug ].
      6 debug kind txt targs => map (fun _ => OK_all) targs
      6 debug : ident := 54%positive.
      6 debug : ident := 51%positive.
      6 debug : ident := 40%positive.
      6 Debug id' ;;
      6 debugging romega. *)
      6 debug "foo".
      6 Debug).
      5 trace ?x ?y) |- _ ] =>
      5 trace w t w'], where [w] is the initial state of the
      5 trace: world -> trace -> world -> Prop :=
      5 trace when using the
      5 trace w E0 w
      5 trace w2 t w3 ->
      5 trace w1 t w2 -> t <> E0 ->
      5 trace w1 (ev :: t) w3.
      5 trace w0 t1 w1 /\ possible_trace w1 t2 w2.
      5 trace w0 t1 w1 -> possible_trace w1 t2 w2 ->
      5 trace w0 t1 w1 /\ possible_traceinf w1 t2.
      5 trace w0 t1 w1 -> possible_traceinf w1 t2 ->
      5 trace w0 (t1 ** t2) w2.
      5 trace w0 (t1 ** t2) w2 ->
      5 trace _ _ w |- _] =>
      5 trace -> val -> mem -> Prop.
      5 trace (t: trace) : Prop :=
      5 trace) (T: traceinf'), t <> E0 -> traceinf'.
      5 trace) (T: traceinf) {struct t} : traceinf :=
      5 trace -> tstate -> tstate -> Prop :=
      5 trace t -> Star (atomic L) (t, s) t (E0, s).
      5 trace) : trace := t1 ++ t2.
      5 trace t' end.
      5 trace -> temp_env -> mem -> outcome -> Prop :=
      5 trace t'.
      5 trace t'
      5 trace t ->
      5 trace [t]. *)
      5 trace [t].
      5 traces_vstore: forall chunk id ofs arg,
      5 traces_vload: forall chunk id ofs res1 res2,
      5 trace support similar to that of [plus_bt]. *)
      5 traces: trace -> trace -> Prop :=
      5 trace step init s tr ->
      5 trace -> state -> Prop;
      5 trace -> state -> Prop),
      5 trace * state L)%type;
      5 trace * state L) -> trace -> (trace * state L) -> Prop :=
      5 trace * state L2) -> Prop :=
      5 trace * state L1) -> state L2 -> Prop :=
      5 trace | Star L s1 t2 s2 /\ t2 <> E0 } }.
      5 traces_syscall: forall id args res1 res2,
      5 traces (symbolenv L) t1 t2 /\ (t1 = t2 -> s1 = s2);
      5 traces (symbolenv L) t1 t2 -> exists s2, Step L s t2 s2;
      5 traces (symbolenv L) t1 t2.
      5 traces (symbolenv L) (ev1 :: nil) (ev2 :: nil) ->
      5 traces (symbolenv L2) t' t'').
      5 traces (symbolenv L1) t' t'').
      5 traces respectively:
      5 traces_preserved with (ge1 := (symbolenv L2)); auto.
      5 traces_preserved:
      5 traces of events.
      5 traces nil nil
      5 traces (L: semantics) : Prop :=
      5 traces L2.
      5 traces L2 ->
      5 traces L
      5 traces".  It
      5 traces is written [**] in the finite case
      5 traces ge t1 t2 /\ (t1 = t2 -> vres1 = vres2 /\ m1 = m2)
      5 traces ge t1 t2 -> t1 = t2.
      5 traces ge t1 t2 -> possible_trace w0 t1 w1 -> possible_trace w0 t2 w2 ->
      5 traces ge t1 t2.
      5 traces ge1 t1 t2 -> match_traces ge2 t1 t2.
      5 traces (Event_vstore chunk id ofs arg :: nil) (Event_vstore chunk id ofs arg :: nil)
      5 traces (Event_vload chunk id ofs res1 :: nil) (Event_vload chunk id ofs res2 :: nil)
      5 traces (Event_syscall id args res1 :: nil) (Event_syscall id args res2 :: nil)
      5 traces (Event_annot id args :: nil) (Event_annot id args :: nil).
      5 traces; eauto. intros [EQ1 EQ2]. subst t2.
      5 traces_E0:
      5 traces DET). eexact H. intros L1.
      5 traces DET). eexact H3. intros L2.
      5 traces corresponding to single transitions.
      5 traces by another, matching trace. *)
      5 traces as
      5 Traces are of two kinds: finite (type [trace]) or infinite (type [traceinf]). *)
      5 traces_annot: forall id args,
      5 traces, and semantics of external calls. *)
      5 trace s#2 t s'#2)
      5 trace_rewrite.
      5 trace_relations_work (failed, net) tr).
      5 trace -> program_behavior.
      5 trace -> program_behavior
      5 trace_prefix (t ** t1) (t ** t2).
      5 trace_prefix (t1 t2: trace) :=
      5 trace_prefix t1 t2 ->
      5 trace_prefixF (upaco2 trace_prefix_ bot2)
      5 trace_prefix_app:
      5 trace] parameter
      5 trace of the parse algorithm.  To do
      5 trace of observables (nonempty if this is
      5 trace of observables
      5 trace of interest, and [w'] the state of the
      5 trace of interest.
      5 trace of input/output events performed
      5 trace of input/output
      5 trace_occ /= /id /= in H_step.
      5 trace_not_nil.
      5 trace_non_empty_out :
      5 trace_nil: forall w,
      5 trace_nil.
      5 trace := nil.
      5 trace : nat => cTriplePi2 trace)
      5 trace : nat => cTriplePi2 (cTriplePi1 trace)).
      5 trace : nat => cTriplePi2 (cTriplePi1 trace))
      5 trace_n1_ind => H_init /=; first by rewrite H_init.
      5 trace -> mem -> outcome -> Prop :=
      5 trace -> mem -> expr -> Prop :=
      5 trace -> mem -> exprlist -> Prop :=
      5 trace := list event.
      5 trace_length ef := ec_trace_length (external_call_spec ef).
      5 trace_length:
      5 Trace.ITraceFacts
      5 trace is possible in a given world if all events correspond
      5 trace is a trace composed only of output events,
      5 TraceInv :=
      5 trace -> int -> Prop;
      5 trace -> int -> program_behavior
      5 trace in the case of reactive divergence. *)
      5 trace in its
      5 traceinf w T], where [w] is the initial state of the
      5 traceinf' w T -> possible_traceinf w T.
      5 traceinf w T
      5 traceinf: world -> traceinf -> Prop :=
      5 traceinf': world -> traceinf -> Prop :=
      5 traceinf' w2 T ->
      5 traceinf w2 T ->
      5 traceinf' w1 (t *** T).
      5 traceinf w1 (Econsinf ev T).
      5 traceinf w0 (t1 *** t2).
      5 traceinf w0 (t1 *** t2) ->
      5 traceinf': Type :=
      5 traceinf : Type :=
      5 traceinf' (t: trace) (T: traceinf') (NE: t <> E0): event * traceinf' :=
      5 traceinf' t T'' NOTEMPTY in
      5 traceinf (traceinf_of_traceinf' (Econsinf' (a :: t) T NE))).
      5 traceinf_traceinf'_app:
      5 traceinf_traceinf'_app.
      5 traceinf'_traceinf:
      5 traceinf -> traceinf.
      5 traceinf' (star_trans ST A (eq_refl _)))
      5 traceinf_sim T T.
      5 traceinf_sim_trans:
      5 traceinf_sim: traceinf -> traceinf -> Prop :=
      5 traceinf_sim': traceinf -> traceinf -> Prop :=
      5 traceinf_sim' T1 T2 -> traceinf_sim' (t *** T1) (t *** T2).
      5 traceinf_sim T1 T2 -> traceinf_sim T2 T3 -> traceinf_sim T1 T3.
      5 traceinf_sim T1 T2 -> traceinf_sim T2 T1.
      5 traceinf_sim' T1 T2 -> traceinf_sim T1 T2.
      5 traceinf_sim' T1 T2.
      5 traceinf_sim T1 T2.
      5 traceinf_sim T1 T2 ->
      5 traceinf_sim t1 t2
      5 traceinf_sim_sym:
      5 traceinf_sim'_sim. eapply forever_reactive_determ'; eauto.
      5 traceinf_sim'_sim:
      5 traceinf_sim_refl:
      5 traceinf_sim (Econsinf e T1) (Econsinf e T2).
      5 traceinf_sim'_cons: forall t T1 T2,
      5 traceinf_sim_cons: forall e T1 T2,
      5 traceinf' (s1: state L) (t1: trace) (ST: Star L s0 t1 s1) : traceinf' :=
      5 traceinf -> Prop
      5 traceinf -> program_behavior
      5 traceinf_prefix (t ** t1) (t *** T2).
      5 traceinf_prefix t T.
      5 traceinf_prefix (t1: trace) (T2: traceinf) :=
      5 traceinf_prefix t1 T2 ->
      5 traceinf_prefix_app:
      5 traceinf_of_tstate (ST s T H))).
      5 traceinf_of_tstate (S: tstate) : traceinf :=
      5 traceinf_of_tstate (ST s2 T F))).
      5 traceinf_of_tstate S1 = t *** traceinf_of_tstate S2.
      5 traceinf_of_tstate S).
      5 traceinf_of_tstate S').
      5 traceinf_of_traceinf' (T': traceinf') : traceinf :=
      5 traceinf_of_traceinf' tl)
      5 traceinf_of_traceinf' (Econsinf' t T NE) = t *** traceinf_of_traceinf' T.
      5 traceinf_of_traceinf' (build_traceinf' ST)).
      5 traceinf_cons: forall w1 ev w2 T,
      5 traceinf' (build_traceinf' ST)). simpl.
      5 traceinf_app_inv _ _ _ H); clear H;
      5 traceinf_app_inv:
      5 traceinf'_app: forall w1 t w2 T,
      5 traceinf_app:
      5 traceinf:
      5 traceinf':
      5 traceinf _ (_ *** _) |- _] =>
      5 TraceHyp; autorewrite with trace_rewrite; decomposeTraceEq.
      5 TraceHyp :=
      5 trace f' t t';
      5 trace f' t t')
      5 trace (fst ts1) -> output_trace (fst ts2)).
      5 TraceForall in |- *.
      5 trace -> expr -> mem -> Prop :=
      5 trace_ev tr).
      5 trace_ev tr = [].
      5 trace (ev :: t) ->
      5 trace_ev_outputs_eq _ _ _ _ _ name_map).
      5 trace_ev /= /id.
      5 traceEq. use_nostep.
      5 trace_equiv.
      5 traceEq] tactic proves equalities between traces
      5 traceEq. right; intuition. traceEq.
      5 traceEq. congruence.
      5 TraceEq :=
      5 TraceEq
      5 traceEq :=
      5 trace_eq.
      5 trace; eauto. destruct t; auto. destruct t; simpl; tauto.
      5 trace; eauto. auto.
      5 trace E0 Eapp Eappinf.
      5 trace _ E0 _ |- _] =>
      5 trace_cons: forall w1 ev w2 t w3,
      5 trace) (beh: program_behavior) : Prop :=
      5 trace) (beh: program_behavior): program_behavior :=
      5 trace at the point of the exception. The [handle]
      5 trace. apply app_ass. Qed.
      5 trace_app_inv _ _ _ _ H); clear H;
      5 trace_app_inv:
      5 trace_app:
      5 TRACE_ACC; subst.
      5 Trace1.
      5 Trace :
      5 trace,
      5 trace*)
      5 trace). *)
      5 trace _ (_ ** _) _ |- _] =>
      5 trace :=
      5 Reify v in
      5 reify var x :=
      5 reify var term in
      5 reify_TypeCode B in
      5 reify_Term var x in
      5 reify_rec term := reify var term in
      5 reify one opp add mul x in
      5 Reify.NamedTimers.
      5 reify_flat_type T in
      5 reify_faster_2arg (). *)
      5 Reify e :=
      5 reify b nb in
      5 profile () := ltac1:(show ltac profile).
      5 print_wf_set (s: M.t) := s.
      5 print_wf_set (do_wellformed c)) s_star in
      5 Print Visibility.
      5 Print Universes. *)
      5 print_unfold_set (s: M.t) := s.
      5 print_unfold_set pcns_u) nu_s in
      5 print(to_def(name))
      5 Print t1.
      5 Print sumbool.
      5 Print sum.
      5 print_spatial_model nc' R)
      5 print_spatial_model (c: clause) (R: list (var * expr)) := c.
      5 print_spatial_model2 c (norm selected nc') R in
      5 print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.
      5 Print sigT.
      5 print(r'''  (* Python code to generate these hints:
      5 print(r'''
      5 print_pures_list print_eqs_list
      5 print_pures_list (l: list clause) := l.
      5 Print or.
      5 print(open(__file__).read())
      5 print_nf (id ^ " has been translated as " ^ id') ;;
      5 print_new_pures_set (s: M.t) := s.
      5 print_new_pures_set s) empty_clause
      5 print_new_pures_set print_wf_set print_inferred_list print_spatial_model
      5 print : message -> unit := "coq-core.plugins.ltac2" "print".
      5 print (Message.of_string "Hello, world!").
      5 Print list.
      5 Print IsoMiniOrderedType.
      5 print_int_spec :=
      5 print_int: semax_body Vprog Gprog f_print_int print_int_spec.
      5 print_intr_spec :=
      5 print_intr: semax_body Vprog Gprog f_print_intr print_intr_spec.
      5 print_intr, Gfun(Internal f_print_intr)) ::
      5 printInt"("R")
      5 print_intr.
      5 print_intr := {|
      5 print_intr *)
      5 print_intr
      5 print_int.
      5 print_int
      5 Printing Width 100000.
      5 Printing Universes. Set Printing All.
      5 Printing Primitive Projection Parameters.
      5 Printing Implicit Defensive. 
      5 printing ◇ %\ensuremath{\diamond}% #&#x25c7;# *)
      5 printing _3_ %\ensuremath{\text{\underline{3}}}% #<u>3</u># *)
      5 printing '_3_' %\ensuremath{\text{\underline{3}}}% #<u>3</u># *)
      5 printing,
      5 print_inferred_list (l: list clause) := l.
      5 Print HintDb typeclass_instances. *)
      5 printf : ('v -> 'r) -> 'v -> ('a, unit, 'v, 'r) format -> 'a :=
      5 print_eqs_list us')) rs) in
      5 print_eqs_list (l: list clause) := l.
      5 PrintContext.
      5 print_closedn_eq _) as h.
      5 print_ce_clause R cl cty)
      5 Print b.
      5 Print and.
      5 Print A.
      5 inspect (nth_error args (pars + narg)) := {
      5 inspect (eqb_binder_annot na na') := {
      5 inspect (decompose_stack ρ') := {
      5 inspect {A} (x : A) : { y : A | y = x } := exist x eq_refl.
      5 debug -> (unit -> constr) list -> ident list option -> unit := "coq-core.plugins.ltac2" "tac_trivial".
      5 debug_sem_intro: forall vargs m,
      5 debug_sem ge vargs m E0 Vundef m.
      5 debug_sem (ge: Senv.t):
      5 debug_sem
      5 debug_ok:
      5 debug_ok.
      5 debug kind txt targs => extcall_debug_sem
      5 debug kind text targs => false
      5 debug (kind: positive) (text: ident) (targs: list typ).
      5 debug -> int option -> (unit -> constr) list -> ident list option -> unit := "coq-core.plugins.ltac2" "tac_eauto".
      5 debug -> int option -> (unit -> constr) list -> ident list option -> unit := "coq-core.plugins.ltac2" "tac_auto".
      5 debug : ident := 57%positive.
      5 debug : ident := 43%positive.
      5 debugging information from the front-end to the generated
      5 debugging); (2) the clause that failed; and (3) its [ce_type]. *)
      5 debugging *) 1%positive
      5 debug case symbol :=
      5 Debug. *)
      4 trace x, f x with
      4 Trace x.
      4 Trace with (1 := H2) (2 := H0); assumption.
      4 trace_user s.(io_log).
      4 trace_user0; eauto.
      4 Trace_T x.
      4 Trace_T with (1 := H2) (2 := H0); assumption.
      4 Trace_T : Stream (S * Instant) -> Prop :=
      4 Trace_T ((s2, t) ^ x) -> isTrace_T ((s1, t) ^ (s2, t) ^ x). 
      4 trace_trans _ _ _ _ net) => //.
      4 trace_trans H)
      4 trace tr0 ttr0 ->
      4 TraceT_map := id)
      4 TraceT'_map := id);
      4 TraceTick H5 H1) ].
      4 TraceTick :
      4 TraceT}
      4 Trace_T :
      4 Trace : Stream S -> Prop :=
      4 trace (st {io_log : io_log st ++ IOEvSend 0 z :: nil}));
      4 traces.  The "valid" predicate ensures that related addresses don't get
      4 traces t -> exists z', consume_trace initial_oracle z' t.
      4 trace_step:
      4 traces t1 ->
      4 TraceSpec IO).
      4 trace (S n) t traces z c m
      4 TracesIrrelevant.
      4 trace_serial0; eauto; lia.
      4 TraceSemantics.yielded source c'
      4 TraceSemantics.yielded_dec source c).
      4 TraceSemantics.nyielded_nhalted in n; auto).
      4 TraceSemantics.halted source (z,tr,c) = None) as ->
      4 TraceSemantics.fun_FUN; auto. Qed.
      4 TraceSemantics.corestepN_CORESTEPN in STEPN; eauto.
      4 TraceSemantics.coopsem z_init source spec) geS n (z, tr0, c2) m2).
      4 traces); eauto.
      4 trace - S (cPairPi2 (cTriplePi3 trace))) recs).
      4 trace) (sch : schedule) (tp : jstate ge) (PHI : rmap)
      4 trace_same_order' as (? & ? & ? & Heq); eauto; subst.
      4 traces.
      4 trace_rmap:
      4 trace_readable (retain x) sh) k pp
      4 trace -> Prop :=
      4 trace_prefixF; auto.
      4 tracepred Ps tr'.
      4 tracepred_injclosed Ps ->
      4 trace _ _ _ _ _ orig_multi_params_name_tot_map) tr.
      4 trace_ordered tr.
      4 trace_ordered_snoc.
      4 trace_ordered0; rewrite app_comm_cons, app_assoc; eauto.
      4 trace_ordered0; eauto.
      4 trace_of_ostrace (strip_common_prefix IOEvent_eq abd.(io_log) abd'.(io_log)))
      4 trace_of_ostrace nil) \/
      4 trace_occ _ _ _ _ _ orig_multi_params_name_tot_map) tr.
      4 trace_occ /= /id.
      4 trace_O.
      4 trace_non_empty_out tr).
      4 trace_non_empty_out in H_exp.
      4 trace_n1_ind; intros; subst.
      4 trace_mutual_exclusion'_extend_input; auto. congruence.
      4 trace_monotone Hexec_post_fl) as [tr_fl' Heq].
      4 trace_monotone:
      4 trace_match_state :
      4 trace_map : forall h k v i h' (Hwf : wf_hists h) (Hlenh : Zlength h = size)
      4 trace_map describes the properties on the resulting map. *)
      4 trace -> machine_state -> mem -> schedule ->
      4 trace -> machine_state -> mem -> Prop :=
      4 trace : list (name * (input + list output))) : option Client_index :=
      4 trace j' t t' /\
      4 trace_irr with (tr := evS).
      4 trace_irr: forall U U' tr1 tr1' tr2 tp tp' m m',
      4 trace_irr: forall U tr tr' tp m,
      4 trace; inversion_clear trace.
      4 trace_inj & external_step)); eauto;
      4 trace _ _ _ _ _ _ _ _ _ INIT_ok);
      4 trace in Hspec as Hvalid'; auto.
      4 trace in Hspec.
      4 trace' in Hin.
      4 trace' in Hcons.
      4 trace (h : list (hist * hist)) k v i h' := Zlength h' = Zlength h /\
      4 trace (h : list (hist * hist)) k v i h' := 0 <= i < Zlength h /\
      4 trace f' t t'
      4 TraceFrom_T Sini x -> Until_bound P Q x -> EX_Until_bound Sini P Q.
      4 TraceFrom_T Sini x -> Until_bound P Q x.
      4 TraceFrom_T (Sini : S * Instant) (x : Stream (S * Instant)) :=
      4 TraceFrom_T s2 z ->
      4 TraceFrom_T s1 (s1 ^ x)).
      4 TraceFrom_T s1 (s1 ^ s2 ^ z) -> ~ Posible_T s2 P.
      4 TraceFrom_T s1 (s1 ^ s2 ^ x) -> isTraceFrom_T s1 (s1 ^ z).
      4 TraceFrom_T in |- *; simpl in |- *.
      4 TraceFrom_T in |- *; inversion_clear H2; simpl in |- *.
      4 TraceFrom_T in |- *; elim H1; intros ig trace;
      4 TraceFrom Sini x -> Until P Q x -> EX_Until Sini P Q.
      4 TraceFrom Sini x -> Until P Q x.
      4 TraceFrom Sini x -> ForAllS P x -> SafePath Sini P.
      4 TraceFrom Sini x -> ForAllS P x.
      4 TraceFrom Sini x -> ExistsS P x -> Posible Sini P.
      4 TraceFrom Sini x -> ExistsS P x.
      4 TraceFrom Sini x -> ExistsS (fun s : Stream S => P s -> False) x)
      4 TraceFrom (Sini : S) (x : Stream S) :=
      4 TraceFrom s2 z ->
      4 TraceFrom s1 (s1 ^ x)). 
      4 TraceFrom s1 (s1 ^ s2 ^ z) -> ~ Posible s2 P.
      4 TraceFrom s1 (s1 ^ s2 ^ x) -> isTraceFrom s1 (s1 ^ z).
      4 TraceFrom in |- *; simpl in |- *.
      4 Trace : forall tr (tp' : jstate) (m' : mem) tr' (n : nat)
      4 trace : forall st st' c,
      4 trace : forall st c st' r,
      4 Trace f0 (v, s)) (makeTrace f1 (v, s)))).
      4 trace_external; eauto; intros.
      4 trace_external:
      4 trace_ev _ _ _ _ _ orig_multi_params_name_tot_map) tr.
      4 trace E S -> itrace E R -> Prop)
      4 trace_erasure_nth in Hj'; eauto.
      4 trace_erasure_nth in Hi'; eauto.
      4 trace_equiv_app_inv in NTR_EQUIV;
      4 trace_eq _ _ _ _ _ name_map).
      4 trace_end; auto.
      4 trace empty_hists la h) lr)
      4 trace empty_hists la h')
      4 traced monoidal category_.
      4 TraceDisc H5 H6 H1) ].
      4 TraceDisc :
      4 trace: deriv s s') :=
      4 trace: deriv s2 s3) (step2: trans s3 s4) :
      4 trace: deriv s2 s1) :
      4 trace_console0 in Hcons.
      4 trace; cbn.
      4 trace_case t t'' r.
      4 trace_case t t'' c r.
      4 trace_case_trans; [eapply Htr |]; eauto.
      4 trace_case_trans'; [| eapply Htr4].
      4 trace_case_trans'; [| eapply Htr3].
      4 trace_case_trans'; [| eapply Htr2].
      4 trace_case st.(io_log) st'.(io_log) c r.
      4 trace_case st.(io_log) st'.(io_log) c /\ -1 <= c <= 255.
      4 trace_case in Htrace_case; eauto.
      4 trace_case in Hspec as Htr4.
      4 trace_case in Hspec4 as Htr3.
      4 trace_case in Hspec3 as Htr2.
      4 trace_case in Hspec2 as (Htr1 & Hrange); auto.
      4 trace_case in Hspec1 as Htr.
      4 trace_case in Hspec.
      4 trace_case : forall st st' c,
      4 trace_case : forall st c st' r,
      4 trace_case as (Htr & Hcase).
      4 trace by lia.
      4 trace b ofs T :=
      4 trace (b : block) ofs es :=
      4 trace AV.valid) ->
      4 trace as [? Htrace]; eauto; [|eapply join_sub_trans; eexists; eauto]; subst.
      4 trace) as (? & Hg & Hg0); eauto; [eexists; eauto | eapply ext_compat_sub; eauto; eexists; eauto|]; subst.
      4 trace as (Hbounds & Hfail & Hi & Hrest).
      4 trace) as (? & ? & ?); eauto; [eexists; eauto|]; subst.
      4 trace_access_Error; auto.
      4 Trace2.
      4 trace].
      4 trace),
      4 trace)))))).
      4 trace)))) 
      4 reify Σ Γ B ;;
      4 reify_vst_typ) (b : id positive) =>
      4 reify_vst) (e : id (list floyd.efield_lemmas.efield)) =>
      4 reify_vst) (e : id Clight.expr) =>
      4 reify_vst) =>
      4 reify {varT} (var : varT) {eT} (e : eT) {T : Type} := Build_reify : T.
      4 reify_var_for_in_is _ x ?t ?v |- _ => mkVar t v
      4 reify_var_for_in_is _ {T} _ _ {eT} _.
      4 reify_var_for_in_is base_type_code {T} (x : T) (t : flat_type base_type_code) {eT} (e : eT) := False.
      4 reify v0 in
      4 reify_unfold_eq. reflexivity.
      4 reify type <type to be reified>]. *)
      4 reify_type T ::=
      4 reify type T).
      4 reify] typeclass
      4 reify_type B in
      4 reify_type A in
      4 reify_type] *)
      4 reify {t} v
      4 reify_Term_lit2 var A B Rterm in
      4 reify_Term_lit1 var A Rterm in
      4 reify.symexe_soundness.
      4 reify:"%string x
      4 ReifySepExpr.
      4 Reify_rhs _ := pre_Reify_rhs (); do_Reify_rhs (); post_Reify_rhs ().
      4 Reify_rhs _ :=
      4 reify_result_helper :=
      4 reify reify_tag C)) (* [C] here is an open term that references "x" by name *)
      4 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify n @ GallinaReify.Reify idxs)
      4 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify n)
      4 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify n @ GallinaReify.Reify m)
      4 reify_rec e := reifyf base_type_code interp_base_type op var e in
      4 reify_rec e := reify_abs base_type_code interp_base_type op var e in
      4 reify_rec b in
      4 reify_rec a in
      4 reify_prop_right)
      4 ReifyProofs.
      4 Reify Pattern patterns_vst += (!!msubst_efield_denote @ ?0 @ ?1 @ ?2) =>
      4 Reify Pattern patterns_vst += (!!Integers.Int.repr) => (@Inj typ func (inr (Intop fint_repr))).
      4 reify_package_of_package package in
      4 reify_op : True.
      4 reify_op {opTF} (op_family : opTF) {opExprT} (opExpr : opExprT) (nargs : nat) {opT} (reified_op : opT)
      4 reify_op op op_head _ _) in
      4 reify_op op op_head expr :=
      4 reify_op op op_head :=
      4 reify_op _ _ ?nargs ?op_code)
      4 reify_op] *)
      4 reify one opp add mul x :=
      4 reify me2 in
      4 reify me1 in
      4 reifyl (lterm:=lb))) with
      4 reify_list in H; exfalso; clear -H; intuition congruence
      4 reify.list_ctype_eq.
      4 ReifyLemma.*)
      4 ReifyHints.
      4 reify_helper
      4 reifyf] will
      4 reifyf_var x mkVar in constr:(finished_value retv)
      4 reifyf_var x mkVar :=
      4 Reify (fun f g
      4 reifyf_term x in
      4 reifyf_term e := reifyf base_type_code interp_base_type op var e in
      4 reifyf success:" e "</infomsg>"
      4 reifyf:"%string nargs
      4 reify_flat_type B in
      4 reifyf base_type_code interp_base_type op var e :=
      4 reify (@exprf ?base_type_code ?interp_base_type ?op ?var) ?e)
      4 ReifyExpr.default_type
      4 ReifyExpr.
      4 reify_equations eq zero in
      4 reify_equations eq zero :=
      4 reify_derives_refl
      4 reify_debug_level ::= constr:(1).] to get
      4 reify_debug_level := constr:(0).
      4 Reify.CanonicalStructuresReifyCommon.
      4 reify_base_type T in
      4 Reify' base_type_code interp_base_type op e in
      4 Reify' base_type_code interp_base_type op e :=
      4 reify] assumes that operations can be reified via the [reify_op]
      4 reify_abs {varT} (var : varT) {eT} (e : eT) {T : Type} := Build_reify_abs : T.
      4 reify_abs reify_tag C)) (* [C] here is an open term that references "x" by name *)
      4 reify_abs (@exprf base_type_code interp_base_type op var) e)) with
      4 reify_abs (@exprf ?base_type_code ?interp_base_type ?op ?var) ?e)
      4 reify_abs base_type_code interp_base_type op var e :=
      4 print x := Pos (to_int x).
      4 print_w p in
      4 print t in
      4 print (Tfunction
      4 print : test17_scope.
      4 print_term Σ' [] true false t)
      4 print_term Γ true false t ++
      4 print_term Γ true false def ++ " in " ++ nl ++
      4 print_term Γ true c ++ ")"
      4 print_term Γ true br
      4 print_term Γ false true f ++ " " ++ print_term Γ false false l)
      4 print_term Γ false false c ++ ".(" ++ na ++ ")"
      4 print_term (Γ : context) (top : bool) (inapp : bool) (t : term) {struct t} :=
      4 Print TC.Solver.
      4 Print t4.
      4 Print t3.
      4 Print t ;;
      4 print_sumbool_hint Pre;
      4 print_spatial_model (norm (print_wf_set selected)
      4 Print sig.
      4 print(r"""Section Fix%(fixn)d.""" % locals())
      4 print(r"""Section Fix2_%(fixn)d.""" % locals())
      4 print(r"""          (R : A -> A -> Prop) (Rwf : well_founded R)""")
      4 print(r"""          (R : A * A' -> A * A' -> Prop) (Rwf : well_founded R)""")
      4 Print qt ;; tmPrint t).
      4 print Q b ofs -> m_footprint P b ofs).
      4 print (P Q: massert) : Prop :=
      4 print P Q;
      4 printP_mon b (List.tl l)
      4 print pc le lp e : well_typed_expr le e -> leq (join le pc) lp ->
      4 print P b ofs -> m_footprint Q b ofs -> False.
      4 print of the assertion
      4 print of P be empty, and vice versa for store. *)
      4 Print Notation "x 'mod' y".
      4 print nicer
      4 Print n.
      4 Print mulmod.
      4 print m m' -> m_pred m';
      4 print (message_of_nat n).
      4 Print Ltac zify_to_euclidean_division_equations.
      4 Print Ltac zify_internal_to_euclidean_division_equations.
      4 Print Ltac zify.
      4 Print Ltac withstrategy.
      4 Print "lol").
      4 print is part of the assertion) makes
      4 print_intx (Tfunction (Tcons tuint Tnil) tvoid cc_default))
      4 print_intr (Tfunction
      4 Print_instances.
      4 Print insecind.
      4 Printing Use Implicit Types.
      4 Printing Unfocused.
      4 printing the goals used to
      4 PrintingTest.
      4 Printing Stuff *)
      4 printing. [nl] is a shorthand for it. *)
      4 printing, format "'[hv  ' id ']'", at level 10) : expr_scope.
      4 printing forall $\forall$ #&forall;# *)
      4 Printing Float.
      4 printing ⊢ %\ensuremath{\vdash}% #&#x22a2;# *)
      4 printing |- %\ensuremath{\vdash}% #&#x22a2;# *)
      4 printing ⊤ %\ensuremath{\top}% #&#x22a4;# *)
      4 printing ⊣ %\ensuremath{\dashv}% #&#x22a3;# *)
      4 printing -| %\ensuremath{\dashv}% #&#x22a3;# *)
      4 printing ⊥ %\ensuremath{\bot}% #&#x22a5;# *)
      4 Printing Depth 50.
      4 Printing Depth 4.
      4 Printing Dependent Evars Line.
      4 Printing Compact Contexts.
      4 printing, at level 10).  *)
      4 PrintingAssumption.
      4 printing <2= $\subseteq$ #&sube;# *)
      4 printing \2/ $\cup$ #&cup;# *)
      4 printing -> $\rightarrow$ #&rarr;# *)
      4 printing /\ $\land$ #&and;# *)
      4 printing ~ *)
      4 print_inferred_list (rsort_uniq compare_clause
      4 print in e.
      4 Print HintDb secdb.
      4 print := fun b ofs => exists b0 delta, j b0 = Some(b, delta) /\ Mem.perm m0 b0 (ofs - delta) Max Nonempty
      4 print := fun b' ofs' => b' = b /\ ofs <= ofs' < ofs + size_chunk chunk
      4 print := fun b' ofs' => b' = b /\ lo <= ofs' < hi
      4 printf "Term: %t" t;*)
      4 Print foo'.
      4 printf.
      4 Print extensible.
      4 printer called *)
      4 printer, *)
      4 print Env.repr'
      4 print Env.default Env.repr
      4 printed the same from 8.10 (due to #8890), but not 8.11 and 8.12 (due to #11090) *)
      4 printed the same from 8.10 *)
      4 printed ##[ r ] from 8.10 *)
      4 print_defs (print_term : context -> bool -> bool -> term -> string) Γ (defs : mfixpoint term) :=
      4 print_def extract_copy "Top.provedCopy_terminate".
      4 Print d.
      4 print contains only valid memory blocks.
      4 print_constraints,
      4 Print constr.
      4 print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
      4 print_branch (vass na' A :: Γ) n B
      4 PrintBound.
      4 print b ofs -> Mem.valid_block m b
      4 print: block -> Z -> Prop;
      4 print as [[[[[? ?] ?] ?] ?]|] eqn:e1. 2: discriminate.
      4 print3 (of_int i) (of_string "=") (of_int x)) a.
      4 inspect the rmap m_phi part of the juicy
      4 inspect (reduce_stack RedFlags.default Σ hΣ Γ c ε _) := {
      4 inspect (reduce_stack nodelta_flags Σ hΣ (Γ ,,, stack_context θ') fn (appstack l' ε) _) := {
      4 inspect) eqn:hi.
      4 inspect (abstract_env_lookup X c) := {
      4 debug "tInd" (match i with mkInd s _ => string_of_kername s end)
      4 debug_term msg:= tVar ("debug: " ++ msg).
      4 debug "tConst" (string_of_kername s)
      4 debug "tConstruct" (match i with mkInd s _ => string_of_kername s end)
      4 DebugPrint r;;
      4 DebugPrint.
      4 DebugMsg "tmMakeQuotationOfConstants_gen: tmUnquote done";;
      4 DebugMsg "tmMakeQuotationOfConstants_gen: tmUnquote";;
      4 debuglevel in
      4 debuglevel := constr:(0%nat).
      4 debug_leave_reify_rec e :=
      4 debug kind text targs => mksignature targs None cc_default
      4 debug : ident := 50%positive.
      4 debug : ident := 45%positive.
      4 debugging hook, do the following:
      4 DEBUGGING*)
      4 debugging. *)
      4 debugfail tac :=
      4 debugfail ltac:(IntegralDomain.solve_constant_nonzero).
      4 debug_enter_reify_type T in
      4 debug_enter_reify_rec; let e := reifyf base_type_code interp_base_type op var e in debug_leave_reify_rec e; eexact e) : typeclass_instances.
      4 debug_enter_reify_rec; let e := reify_abs base_type_code interp_base_type op var e in debug_leave_reify_rec e; eexact e) : typeclass_instances.
      4 debug_enter_reify_rec :=
      4 debug_enter_reifyf e in
      4 debug_enter_reify_abs e in
      4 debug eauto].
      4 debug directive *)
      4 debug:debug_opt} (include_submodule : submodule_inclusion) (existing_instance : option hint_locality) (m : qualid) : TemplateMonad _
      4 debug:debug_opt} (include_submodule : list ident -> bool) (include_supermodule : list ident -> list ident -> bool) (existing_instance : option hint_locality) (base : modpath) (cs : list global_reference) : TemplateMonad unit
      3 trace y.
      3 trace) (vres : val) (m2 : mem)
      3 trace_trans IHH_step1.
      3 trace _ _) => traceEq: cshm.
      3 trace [t] is the trace of
      3 trace step x y l ->
      3 TraceSemantics.
      3 trace_scalar.
      3 Traces *)
      3 trace: Ref.t sig (list T))
      3 trace: Ref.t sig (list nat).
      3 trace properties*)
      3 trace of observable events generated during the invocation.
      3 trace of I/O events performed during
      3 trace_occ _)).
      3 trace_occ _ |- _ => 
      3 trace_non_empty_out tr = filterMap trace_non_empty_out tr'.
      3 trace_non_empty_out tr = filterMap trace_non_empty_out tr' ->
      3 trace_non_empty_out; eauto.
      3 trace Nametab.unfreeze;;
      3 trace Nametab.push_short_name;;
      3 trace Nametab.push;;
      3 trace Nametab.freeze;;
      3 trace Nametab.exists_cci;;
      3 trace_mx11.
      3 trace) (l : locals) (m : mem) (k : Syntax.cmd).
      3 trace ir ->
      3 trace in the failing example:
      3 trace in *. intuition.
      3 trace in H.
      3 traceinf_of_traceinf' (build_traceinf' (star_refl (step L) (globalenv L) s0))).
      3 traceinf), forever step ge s T -> tstate.
      3 trace_ind'; auto.
      3 trace_incl t1 t2.
      3 trace) in
      3 trace, H)
      3 trace) (fun _ s => (None, s)).
      3 trace) (fun _ => Return 0).
      3 trace (fun _ => false).
      3 trace f23 t2 t3 ->
      3 trace f12 t1 t2 ->
      3 Trace f0 (v, s))).
      3 trace_ev tr) \/ 
      3 trace_ev _)).
      3 trace_equiv_inv.
      3 trace_equiv_app_inv in EO.
      3 trace_equiv)
      3 trace; eauto. *)     
      3 trace. eauto.
      3 traced back first to the failure
      3 Trace (cPair (cPairPi1 p) x)))
      3 trace (compose_meminj f12 f23) t1 t3.
      3 trace_compose:
      3 trace client id out tr ->
      3 trace. auto.
      3 trace A) : ring_scope.
      3 trace are used or not *)
      3 trace_access_Terminating; eauto.
      3 TRACE_ACC.
      3 trace A B C (x :: y) ->
      3 trace2trace; rewrite stream_map_spec.
      3 trace1 _ H_in.
      3 trace: _)
      3 trace))).
      3 trace := _ |}.
      3 reify_type_of e := (reify ((fun t (_ : t) => t) _ e)) (only parsing).
      3 reify_Term var y in
      3 reifyTerm vars _s in
      3 reify_Term_lit0 var Rterm in
      3 reify_S x
      3 reify_sig. Defined.
      3 ReifySHCOL.
      3 Reify (@Saturated.Rows.mulmod (weight machine_wordsize 1) (2^machine_wordsize) s c n nreductions) in
      3 Reify_rhs _ := Reify_rhs_of_cps Reify_cps ().
      3 Reify_rhs _ := do_Reify_rhs_of_cps Reify_cps ().
      3 ReifyRHCOL.
      3 Reify.Reify (machine_wordsize:Z)
      3 reify_rec term := reify_helper var term ctx in
      3 Reify.PrimPair.
      3 Reify P2 in
      3 Reify P1 in
      3 reify n);
      3 reify_mul x y
      3 reify (mul_tag (nat_of x * nat_of y))
      3 reify.ml4 is not yet implemented *)
      3 reify_lvalue isConst l types funcs uvars vars ltac:(fun uvars funcs l =>
      3 reifying. *)
      3 ReifyExpr.reify_expr isConst i types funcs uvars vars ltac:(fun uvars funcs i =>
      3 reifyExpr cs Q in
      3 reifyExpr cs P in
      3 ReifyExpr.collectTypes_expr isConst i Ts k
      3 reify_cps var term tac :=
      3 Reify_cps term tac :=
      3 Reify ((carry_mulmod limbwidth_num limbwidth_den s c n [3; 7; 4; 0; 5; 1; 6; 2; 7; 3; 4; 0]%nat)) in
      3 Reify.Benchmarks.TypeClasses.
      3 Reify.Benchmarks.TemplateCoq.
      3 Reify.Benchmarks.Stats.
      3 Reify.Benchmarks.QuoteFlat.
      3 Reify.Benchmarks.Printing.
      3 Reify.Benchmarks.Parametricity.
      3 Reify.Benchmarks.OCaml.
      3 Reify.Benchmarks.Mtac2.
      3 Reify.Benchmarks.LtacVariants.
      3 Reify.Benchmarks.LtacPrimUncurry.
      3 Reify.Benchmarks.Ltac2.
      3 Reify.Benchmarks.CanonicalStructures.
      3 Reify_as {t} v
      3 reify_args_for_apply3 reify_Term var ret x y z
      3 reify_args_for_apply2 reify_Term var ret x y
      3 reify_args_for_apply1 reify_Term var ret x
      3 reify_and_let_binds_cps] in k.
      3 reify ())
      3 profile; start ltac profiling end in
      3 profile "slow".
      3 profile_parser line parse num_times duplicates_per_iteration all_say_yes all_say_no mixed_answers in
      3 profile_parser
      3 profile (list bool) parse_many)
      3 profile : forall {T}, (unit -> T) -> Ocaml.float * T
      3 profile end in
      3 profile cutoff 0.
      3 profile_constr tac :=
      3 profile_constr slow.
      3 Print φ_adj.
      3 Print α).
      3 Print Zwf.
      3 Print Z.lt.
      3 Print zero_leq_three.
      3 Print zeroE.
      3 Print Wrap.
      3 Print wrap.
      3 Print W.apap.
      3 Print Vector.t.
      3 Print Universes. (* U <= T *)
      3 Print Universes. Print foo. Set Printing Universes. Print foo.
      3 Print Universes. (* Check if constraint is lost *)
      3 Print universes. *)
      3 print_universe_instance u :=
      3 Print unit.
      3 print_unfold_set
      3 Print uncast.
      3 Print two.
      3 print t = Some (k, n, ui, l', τ) ×
      3 Print TrM.B.
      3 Print TrM.A.
      3 Print t_rect.
      3 Print "todo tTranslate" ;; ret None
      3 Print tm ;; tmFail " is not an inductive"
      3 Print thing.
      3 Print "test" ;; tmQuote plus) k.
      3 Print test. -- reveals [hpure] coercions *)
      3 Print test4.
      3 Print test3.
      3 Print test2.
      3 print_term Σ Γ' (tCase ci' p' c' brs') ^
      3 print_term Σ Γ (tCase ci p c brs) ^
      3 print_term Γ true false dom
      3 print_term Γ true dom
      3 print_term (vdef na' def :: Γ) true false body)
      3 print_term (vass na' :: Γ) true false body)
      3 Print Term O.
      3 Print temp_rect.
      3 print_template_program p.
      3 print_template_program {cf : checker_flags} (p : Ast.program)
      3 print_template_program. *)
      3 print_template_program.
      3 Print Tables.
      3 Print t)).
      3 Print t ;; *)
      3 print t).
      3 Print success.
      3 print_stmt_for_scope.
      3 print statement: *)
      3 print_spatial_model (simplify units nc) R) = true ->
      3 print_spatial_model2
      3 Print Sorted Universes "universes.txt".
      3 Print Sorted Universes.
      3 print something :-) *)
      3 Print SomeMod.inmod.
      3 Print sigT_rect.
      3 Print sig2.
      3 Print ShrinkTree.
      3 Print ShowTree.
      3 Print Setoids.*)
      3 Print Section A.
      3 prints/articles/10/tr10.pdf)
      3 Print RWrap.
      3 Print runwrap.
      3 Print Rewrite HintDb sigma. *)
      3 print_recursivity_kind k :=
      3 Print qux. (* qux@{Top.42 Top.43} =
      3 Print qux. (* qux@{Top.34 Top.35 Top.36 Top.37} =
      3 Print quote_mult_obligation_1.
      3 Print qtest.
      3 Print qt.
      3 Print qFuntp.
      3 Print PWrap@{E}.
      3 Print PWrap.
      3 print_pures_list 
      3 Print punwrap.
      3 Print prop_inject.
      3 Print proj_informative.
      3 Print proj.
      3 Print predecessor.
      3 Print pred.
      3 Print plus2.
      3 Print PLanguage.
      3 print_pattern _) as h.
      3 print_pattern :
      3 print/parse *)
      3 Print P.
      3 print out happens twice:
      3 print out: *)
      3 Print OpM.B.
      3 Print OpM.A.
      3 Print onefiber'.
      3 Print N'''.x.
      3 Print N.t.
      3 Print N'.t.
      3 Print N''.t.
      3 Print N'''.t.
      3 print_nf ΣE). *) *)
      3 print_nf ΣE). *)
      3 print_nf tm' ;;
      3 print_nf  (id ^ " has been translated as " ^ id') ;;
      3 print_nf entries ;; *)
      3 print_nf {A} (msg : A) : TemplateMonad unit
      3 Print Nat.add.
      3 Print N.apap.
      3 Print M.t.
      3 print msg;
      3 Print mono@{E}.
      3 Print mono.
      3 Print Module PPPP.
      3 Print Module Foo.
      3 Print Module A.
      3 Print m;; match m ==
      3 Print ML Path.
      3 Print ML Modules.
      3 Print minus_decrease.
      3 print (Message.of_ident @Y).
      3 print (Message.of_ident @P).
      3 Print merge_wf.
      3 Print merge_one. Eval cbv delta [merge_one] beta zeta in merge_one.
      3 Print M.a.
      3 Print M.
      3 Print lvalue.
      3 Print Ltac g.
      3 Print Ltac foo.
      3 Print Ltac f2.
      3 Print Ltac f1.
      3 Print Ltac f0.
      3 print_lset t :=
      3 print_lset levels))));;
      3 print_list string_of_level " " (LevelSet.elements t).
      3 Print List.fold_right. *)
      3 print_list {A} (f : A -> string) (sep : string) (l : list A) : string :=
      3 print_linear _) as h.
      3 print_linear :
      3 Print le_S.
      3 Print lem3.
      3 Print lem2.
      3 Print lem1.
      3 Print l4.
      3 Print l3.
      3 Print l1.
      3 print l).
      3 Print K.N.apap.
      3 Print K.app.
      3 Print isweqcontrtounit.
      3 print_int (Tfunction (Tcons tuint Tnil) tvoid
      3 print_intr_spec; print_int_spec; main_spec]).
      3 printInt" @ [printIntS] ]]
      3 Print Instances True.
      3 printing with curly brackets    *)
      3 Printing Width 7.
      3 Printing Width 400.
      3 Printing Width 150.
      3 printing while compiling *)
      3 Printing Universes.  
      3 printing time with stack overflow due to an infinite
      3 printing time was failing because
      3 printing) : taps_scope.
      3 printing/showing the goal *)
      3 printing rule is used here *)
      3 Printing Record test_r.
      3 Printing Projections.: r.(p)
      3 Printing Projections.: r'.(p')
      3 Printing Primitive Projection Parameters.*)
      3 printing 'pat uses an "as" when the variable bound to
      3 printing-only, BZ#5739 *)
      3 Printing of unicode notation, in *response* *)
      3 Printing of unicode notation, in *goals* *)
      3 printing of this term used to failed in V8.0 and V8.0pl1 (cf BZ#860) *)
      3 printing of the "var" argument "Hx" *)
      3 printing of the destructive
      3 printing of the AST without needing lots of imports *)
      3 printing of Tactic Notation *)
      3 printing of primitive projections and their eta expansions.
      3 printing of object arguments *)
      3 printing of numerical and non-numerical notations for eq_refl *)
      3 printing of notation with coercions in scope of a coercion    *)
      3 printing of notations with several instances of a recursive pattern *)
      3 printing of notations with mixed reserved binders (see bug #2571) *)
      3 printing of notations from other modules *)
      3 printing of modules with notations *)
      3 printing of match context *)
      3 printing of lists and its focussing *)
      3 printing of let-ins *)
      3 printing of let in Ltac and Tactic Notation *)
      3 printing of implicit by names *)
      3 printing of fix *)
      3 printing of bound unnamed variables in pattern printer *)
      3 printing of #5608                                             *)
      3 printing of #5526                                             *)
      3 printing of #4932                                             *)
      3 printing notation should not override existing
      3 printing notation should not let believe
      3 Printing Notations. Arguments paths _ _ _ : clear implicits.
      3 printing nested let-in's stays in linear time *)
      3 printing mechanism *)
      3 Printing Let.
      3 Printing Implicit.*)
      3 Printing If.
      3 printing) : fun_syntax.
      3 printing) : fscope. *)
      3 printing) : fscope.
      3 Printing Existential Instances. *)
      3 printing ∫ %\ensuremath{\int}% #&int;# *)
      3 printing does not fail                        *)
      3 Printing Depth 30.
      3 Printing Depth 100.
      3 Printing Depth.
      3 printing delle relazioni non e' in synch!
      3 Printing Constructor test_c.
      3 Printing Coercion for i.
      3 printing, at level 76, right associativity, c1 at level 76, c2 at level 76).
      3 printing, at level 20, x at level 14, left associativity, format "x . y").
      3 printing, at level 15, format "* x").
      3 printing, at level 0, format "'Name' i").
      3 printing, at level 0, *)
      3 printing anotations ** *)
      3 printing annotations nor casts.
      3 Printing All: r.(@p) ?ex
      3 Printing All: r'.(@p')
      3 Printing All. Print blah_fail.
      3 Printing All: p' r'
      3 Printing All: p r
      3 printing all mode *)
      3 Printing *)
      3 Printing
      3 printing: *)
      3 printing.                         *)
      3 printing". *)
      3 printing **)
      3 Print inferred_type'. *)
      3 printInductive "NonRec").
      3 printInductive "nat").
      3 printInductive "Coq.Init.Datatypes.nat").
      3 printInductive "Coq.Arith.PeanoNat.Nat.add").
      3 printInductive "cnat").
      3 print((indent + '(' + r'''**
      3 Print InclWorkaround.p.
      3 Print InclSigOpaque.p.
      3 Print InclFunctOpa.p.
      3 Print Implicit Nat.add.
      3 Print Implicit foo. (* foo : forall F : False, Foo F -> True
      3 Print Implicit existT.
      3 Print Implicit eq_refl.
      3 print_identity in T. simpl in T.
      3 Print Hint well_founded.
      3 Print HintDb typeclass_instances.
      3 Print HintDb foo.
      3 Print Hint *.
      3 Print Grammar *)
      3 Print GG_data] still works after the section closes. Is there a way to actually keep them local?  If not, find less generic names for [GG] and its components. *)
      3 Print GenSizedTree.
      3 Print g.
      3 Printf.printf ""total: %f, median: %f, mean: %f, sample variance: %f, iterations: %d (%d on each)\n"" sum median mean sample_variance iterations duplicates_per_iteration".
      3 Print : forall {A:Type@{t}}, A -> TemplateMonad unit
      3 Print foo@{E M N}.
      3 Print foo@{E}.
      3 Print foo5.
      3 Print foo@{_ _ _}.
      3 Print find42.
      3 print_expr_list_true_scope.
      3 Print existT.
      3 Print ex.
      3 Print] event untouched.
      3 Print e ;; tmFail "Cannot elaborate to ETT term"
      3 printers in presence of coercion to         *)
      3 Printer.qualid_of_global]) and check that this env is ok. *)
      3 printer only below coercion (submitted by Georges Gonthier) *)
      3 printer of notations does not use a
      3 printer for positive *)
      3 printer for module names) *)
      3 printer conflict *)
      3 printer anomaly due to an internal lambda with no binders *)
      3 Print Equivalent Keys.
      3 Print eq_proof_proof.
      3 Print eq_3_3.
      3 Print eo_from_syntax.
      3 print_env (short : bool) (prefix : nat) Σ :=
      3 Print Empty@{E}.
      3 Print Empty.
      3 printed with custom universe names. *)
      3 printed using application notation r.(p), r.(@p) in fully explicit form *)
      3 printed using <= !) *)
      3 printed until Pierre B.'s
      3 printed the same way, and not "S 2 + S 2" as if numeral printing was
      3 printed the sames as
      3 printed term (the checked term is actually re-printed the
      3 printed only using projection notation r.(p), r.(@p) in fully explicit form *)
      3 printed in the two following tests in 8.3pl1 *)
      3 printed in the right environment at some time *)
      3 printed in the correct environment *)
      3 printed by the printer for Z than
      3 printed because of bug #3079.
      3 print; eauto. eapply leq_trans_lat; eauto.
      3 Print "done").
      3 Print div_aux.
      3 print_db.
      3 Print d2.
      3 Print d' ;;
      3 Print C. (* Should print test_rect without failing *)
      3 Print Cover.
      3 Print count.
      3 Print Coq.Init.Logic@{E}.
      3 print_context_decl Σ Γ' decl' ^ nl ^
      3 print_context_decl Σ Γ decl ^ nl ^
      3 print_constraint_type d :=
      3 print_constraint_set t :=
      3 printConstant "Top.Funtm"). *)
      3 printConstant "Top.demo.Funtp2"). *) (* TODOO *)
      3 printConstant "Top.demo.Funtp"). *)
      3 Print comparison.
      3 Print Coercion Paths nat Sortclass.
      3 Print Classes.
      3 Print cg.
      3 Print cb.
      3 print_cases_scope.
      3 print_case_label_scope.
      3 Print Canonical Projections.
      3 Print ca.
      3 print_ branch.
      3 print_box_type bt
      3 Print both_z.
      3 Print body) (fun _ => tmMkDefinition newName bd)) *)
      3 Print B.nat.
      3 Print B.mynat.
      3 Print blah_explicit.
      3 Print blah.
      3 Print bla.
      3 Print bla'.
      3 Print bind_univs.poly.
      3 Print bind_univs.mono.
      3 Print : Ast.term -> TM unit
      3 Print Ast.term.
      3 Print Assumption used to consider as axioms the modular fields
      3 Print Assumptions weqtoforallpaths. (* isweqtoforallpathsAxiom *) *)
      3 Print Assumptions weqfunextsec. (* isweqtoforallpathsAxiom *) *)
      3 Print Assumptions SetVars.t.
      3 Print Assumptions relatively to a bound module *)
      3 Print Assumptions P.bar. (* Should answer: foo *)
      3 Print Assumptions not entering implementation of submodules *)
      3 Print Assumptions N.foo.
      3 Print Assumptions M.bar. (* Should answer: foo *)
      3 Print Assumptions main.
      3 Print Assumptions M8416.f.
      3 Print Assumptions M7192.D.f.
      3 Print Assumptions lob.
      3 Print Assumptions left_adjoint_cocont. *)
      3 Print Assumptions InclWorkaround.p. (* Closed under the global context *)
      3 Print Assumptions InclSigOpaque.p. (* Closed *)
      3 Print Assumptions InclNonFunct.p. (* Closed *)
      3 Print Assumptions InclFunctOpa.p. (* Closed *)
      3 Print Assumptions funextsec.    (* isweqtoforallpathsAxiom *) *)
      3 Print Assumptions funextfun.    (* isweqtoforallpathsAxiom *) *)
      3 Print Assumptions did not enter implementation of submodules (#7192) *)
      3 Print Assumptions DepMap.constant.
      3 Print Assumptions comm_plus5.
      3 Print Assumptions Bar.t.
      3 Print Assumptions bad. *)
      3 Print Assumptions AddCommExt_Transparent.add_comm_ext.
      3 Print Assumptions AddCommExt_Opaque.add_comm_ext.
      3 Print Assumptions add_comm.
      3 Print Assumptions add1_comm_ext_transparent.
      3 Print Assumptions add1_comm_ext_opaque.
      3 Print Assumption and opaque modules :
      3 Print Assumption and Include *)
      3 Print Applied.infunct.
      3 Print app.
      3 Print apap.
      3 print_all_kns (t : Ast.term) : TM unit :=
      3 print_all_kns ls)
      3 print_all_kns b)
      3 print_all_kns a) (fun _ => tmBind (print_all_kns b) (fun _ => print_all_kns c))
      3 print_all_kns a) (fun _ => print_all_kns b)
      3 print_all_kns a) (fun _ => mconcat (List.map print_all_kns b))
      3 Print All Dependencies M.foo.
      3 Print All.
      3 Print a_eq_b.
      3 Print Adjunctions.φ_adj. *)
      3 Print Acc.
      3 Print A.B.nat. (* Notation A.B.nat := nat *)
      3 printable: z (resp c, n) occurs in P *)
      3 printable: y, z not allowed to occur in P *)
      3 printable: renaming z in n would hide the renaming of x into n *)
      3 printable: renaming x into n would bind the 2nd occurrence of n *)
      3 printability of {x|P} and variants *)
      3 printability of the hole of the context *)
      3 printability of irrefutable disjunctive patterns *)
      3 printability of a "if is then else" notation *)
      3 Print <% 1 + 1 : nat %>).
      3 Print_
      3 Print "~~~~~~~~~~~~~~~~~~" ;;
      3 inspect => y eq.
      3 inspect (unfold_one_proj (Γ ,,, stack_context π) p c _) := {
      3 inspect (unfold_one_fix Γ mfix' idx' π2 _) := {
      3 inspect (unfold_one_fix Γ mfix idx π1 _) := {
      3 inspect (reducible_head Γ t2 π2 h2) := {
      3 inspect (reducible_head Γ t1 π1 h1) := {
      3 inspect (RedFlags.beta flags) := {
      3 inspect (nth_error (Γ ,,, stack_context π) c) := {
      3 inspect more precisely *)
      3 inspect it"
      3 inspecting subterms of a
      3 inspect first the term to match (even though
      3 inspect (eqb_term t1 t2) := {
      3 inspect (eqb idx idx') := {
      3 inspect (decompose_stack ρ2) := {
      3 inspect (decompose_stack ρ1) := {
      3 inspect (decompose_stack_at π narg) := {
      3 inspect (decompose_stack_at π arg) := {
      3 inspect (decompose_app x) := {
      3 inspect d.(decl_body) := {
      3 Inspect 10.
      3 inspect => //.
      3 Dump Bytecode.
      3 Debug ΣE ;;
      3 Debug Verbosity 2. *)
      3 debug tt
      3 Debug "there";;
      3 debug_term ("tsl_rec1: " ++ case ++ " " ++ symbol ++ " not found") in
      3 Debug Tactic Unification. *)
      3 Debug t ;;
      3 Debug. Set Printing All.
      3 Debug RAKAM. *)
      3 Debug "plop7" ;;
      3 Debug "plop6" ;;
      3 Debug "plop5" ;;
      3 Debug "plop4" ;;
      3 Debug "plop" ;;
      3 debug output; see discussion in PR #868 *)
      3 debug_on := false.
      3 debug of romega on Test46 *)
      3 debug : ident := 59%positive.
      3 debug : ident := 48%positive.
      3 Debug "here";;
      3 Debug "here" ;;
      3 Debug gr;;
      3 Debug "go'";;
      3 Debug "go";;
      3 debugging.ml to do the actual reporting
      3 debugging feature: recursive elim + eq generation *)
      3 debugging but we could use try_reduce *)
      3 Debug Eauto "yes".
      3 debug eauto with test2. 
      3 Debug Eauto 1.
      3 Debug "doneu" ;;
      3 Debug "done'";;
      3 Debug "done";;
      3 Debug Debug On.
      3 Debug "Cbv".
      3 debug auto/eauto *)
      3 debug auto.
      3 debug 3.
      2 trace z z' t'.
      2 trace z z' t' /\
      2 trace (z z' : itree event unit) (t : @trace event unit) :=
      2 trace z z'' (app_trace t t').
      2 trace z' t' -> is_trace z (app_trace t t').
      2 trace z0 z t.
      2 trace ys ->
      2 trace (x :: y).
      2 trace (xs ++ ys).
      2 trace with (tr' := tr) in Hsafe'.
      2 trace with (tr := [::]).
      2 trace_with_test P (singleton_trace s ms).
      2 trace where these tests came from.
      2 trace_wf in Hadd; auto.
      2 trace_wf : forall h la h', add_items_trace h la h' ->
      2 trace_wf : forall h k v i s h' (Hwf : wf_hists h) (Htrace : add_item_trace h k v i s h'),
      2 trace_wf; eauto. }
      2 trace (we currently only do it partially).
      2 traceWD: trace_wd f trc; *)
      2 trace was put there by the serial device. *)
      2 trace) (v: val) (m': mem), *)
      2 trace Vundef m1''').
      2 trace Vundef m1''')
      2 trace * val * mem).
      2 trace_valid: forall tr f, AV.valid tr -> AV.valid (res_option oo (fixup_trace tr f)).
      2 trace_valid: forall retain
      2 trace_valid. destruct tr; simpl; auto.
      2 trace_valid; auto. destruct tr; simpl; auto.
      2 trace * val) :=
      2 trace (U'', snd (fst st) ++ tr, tp') m' tr' n) tp'),
      2 trace (U',(snd (fst st)) ++ tr,tp') m' tr'),
      2 trace_user : valid_trace_user st.(io_log);
      2 trace_user tr :=
      2 trace_user0 as (Hin & Hhd); eauto.
      2 trace_unique : valid_trace_unique st.(io_log);
      2 trace_unique (tr : ostrace) :=
      2 trace : Type.
      2 trace_tx_event : forall st ev,
      2 trace * t)%type.
      2 TraceT TraceT'}
      2 TraceT * TraceT') =>
      2 trace, tt)) by constructor
      2 Trace_T ((s, t) ^ (inc s tick, Inc t) ^ x)
      2 Trace_T ((s2, Inc t) ^ x) -> isTrace_T ((s1, t) ^ (s2, Inc t) ^ x)
      2 trace; try eassumption. eauto.
      2 trace; try eassumption. 
      2 trace tr ttr.
      2 trace tr ttr).
      2 trace tr ttr ->
      2 trace tr); try discriminate.
      2 trace tr tr' ->
      2 trace tr then the address is still a lock at the resulting
      2 trace tr f) with tr. auto.
      2 trace_trans H_star).
      2 trace tr and-rest R
      2 trace (trace_of_ostrace t1) (trace_of_ostrace (strip_common_prefix IOEvent_eq t1 t2)) = trace_of_ostrace t2.
      2 trace (trace: AV.address -> option (pshare * AV.kind))
      2 trace = trace';
      2 trace tr1 tr2 ->
      2 trace tr.
      2 trace tr)) => /=.
      2 trace (tp : thread_pool) (m : mem) (U : schedule)
      2 trace tp m U (tr' ++ tr'').
      2 trace tp' m' (schedSkip U) tr'' ->
      2 trace t mem res (*@semC Sem*)
      2 Trace := t; Memory := m'; Locals := (map.remove l arr_var); Functions := e }>
      2 Trace := t; Memory := m'; Locals := map.put l arr_var ax; Functions := e }>
      2 Trace := t; Memory := m; Locals := #{ … l; a_var => a }#;
      2 trace (t) is allowed by the old itree (z0). *)
      2 Trace_T ((inc s tick, Inc t) ^ x) ->
      2 TraceTick_T H5 H1) ].
      2 TraceTick_T :
      2 trace * ThreadPool.t * mem).
      2 trace(ThreadPool := OrdinalPool.OrdinalThreadPool)),
      2 trace, thread pool and memory, to use konig theorem. *)
      2 trace, the permissions at [(bu,
      2 trace, the permissions at [(b,
      2 trace that the new itree (z) allows, that trace prefixed with the
      2 TraceT)) =>
      2 TraceT)
      2 trace t).
      2 traces z s c m c' m',
      2 traces z q m s0 (Hvalid : valid_trace s0),
      2 traces z c m e args,
      2 traces z c m c' m',
      2 traces' & z' & c' & ? & ? & ? & ? & ? & ?).
      2 traces wouldn't match).
      2 traces, with relationship between syscall events and actual external reads/writes *)
      2 trace. subst.
      2 trace & ?); subst.
      2 trace s /\ t = trace_of_ostrace s.(io_log).
      2 traces' t'' /\ t1 = app_trace t' t'').
      2 traces' t'' /\ t1 = app_trace t' t'') ->
      2 traces (t, sf) -> valid_trace sf /\ t = trace_of_ostrace sf.(io_log).
      2 traces (t', sf) -> valid_trace sf /\ app_trace (trace_of_ostrace s0.(io_log)) t' = trace_of_ostrace sf.(io_log).
      2 traces' (t'', sf) -> traces (app_trace t' t'', sf))) ->
      2 traces' (t'', sf) /\ t1 = (app_trace t' t'', sf)); split.
      2 traces' (t'', sf) /\ t1 = (app_trace t' t'', sf)) ->
      2 traces (t, s) -> exists z', consume_trace main_itree z' t /\ t = trace_of_ostrace s.(io_log) /\
      2 traces (t, s) -> exists z', consume_trace initial_oracle z' t /\ t = trace_of_ostrace s.(io_log) /\
      2 trace_strong f' t t')
      2 trace_strip : forall t1 t2, common_prefix IOEvent_eq t1 t2 = t1 ->
      2 trace (stream_app tr1 tr2) ->
      2 trace (st : RData) := {
      2 traces : trace_set) z s0 c m e args,
      2 traces = traces'.
      2 trace_str).
      2 trace) st m U' tr' st' m' =>
      2 trace st m (tr ++ tr') (S n).
      2 trace st m (tr ++ tr') (S n)
      2 trace st m (tr ++ tr').
      2 trace st m nil n
      2 trace (st : MachState) (m : mem) : event_trace -> Prop :=
      2 trace)(st:machine_state) (m:mem): Prop:=
      2 trace) (st:machine_state) (m:mem): Prop:=
      2 trace (st : jmachine_state) (m : mem) : event_trace -> nat -> Prop :=
      2 trace (st {io_log : st.(io_log) ++ ev :: nil}).
      2 trace (st {io_log : io_log st ++ IOEvPutc l2 c :: nil}));
      2 traces' t'' -> In traces (app_trace t' t''))) ->
      2 trace step x z (l ++ l').
      2 trace step x y l.
      2 trace step x x'' (cs ++ cs').
      2 trace step x x []
      2 trace (step : step_relation) : step_relation :=
      2 trace step (s::A)
      2 Trace_Step : forall tp' m' U' tr tr'
      2 trace_step; eauto.
      2 trace_step :
      2 trace st); eauto. *)
      2 trace st); eauto.
      2 trace st') by eauto using uctx_set_errno_preserve_valid_trace.
      2 trace) (st1 : ThreadPool (Some hb)) 
      2 traces t',
      2 traces t' ->
      2 Traces.sutt_trace_incl; eauto; cbn.
      2 Traces.sutt_trace_incl; auto.
      2 traces; split; auto.
      2 traces, so the "matching" Asm execution must be
      2 TraceSpec IO) (itree IO).
      2 TraceSpec.
      2 traces, OS_safeN_trace prog n Traces.TEnd traces main_itree s0 q init_mem /\
      2 traces', OS_safeN_trace n t traces' z s0 q m /\ forall t, traces t <-> exists s, traces' (t, s).
      2 traces, OS_safeN_trace n TEnd traces initial_oracle s0 q m /\
      2 trace (S n) t traces z s c m
      2 trace (S n) t traces z s0 c m
      2 traces ?]; [|lia].
      2 traces, is the content of the 
      2 traces in the right way*)
      2 traces in Htrace; destruct Htrace; eauto 25.
      2 trace (singleton_trace s ms).
      2 trace_singleton_inv.
      2 traceSim: trace_sim f trc trf
      2 trace (_ :: _) |- _ ] => simpl in H
      2 trace; simpl in *.
      2 trace_sim_incr;
      2 trace_sim_incr:
      2 trace_sim f tr tr'),
      2 trace_sim f (tr ++ [:: ev]) (tr' ++ [:: ev']).
      2 trace_sim f' trc trf.
      2 trace_sim f trc trf),
      2 trace_sim (f:memren) : event_trace -> event_trace -> Prop :=
      2 traces Hsafen].
      2 traces, ext_safeN_trace n t traces z q m.
      2 traces, ext_safeN_trace n TEnd traces initial_oracle q m.
      2 traces, ext_safeN_trace n TEnd traces initial_oracle q m /\
      2 traces, ext_safeN_trace(J := OK_spec) prog IO_ext_sem IO_inj_mem OS_mem valid_trace n TEnd traces initial_oracle q m /\
      2 trace_set := @trace (@io_events.IO_event nat) unit * RData -> Prop.
      2 trace : set_item_trace h k v i h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),
      2 trace_serial : valid_trace_serial st.(io_log) st.(com1).(l1);
      2 trace_serial tr lrx :=
      2 trace_serial0 as (_ & Henv); eauto.
      2 trace := (seq.seq machine_event).
      2 TraceSemantics.yielded target d.
      2 TraceSemantics.yielded target d).
      2 TraceSemantics.yielded source c.
      2 TraceSemantics.yielded source c ->
      2 trace semantics source configuration <z,nil,c> is safe *)
      2 TraceSemantics. Section trace_semantics.
      2 TraceSemantics P (resources * model) Ac}
      2 TraceSemantics.nyielded_natext in n; eauto.
      2 TraceSemantics.halted source (z,tr0,c2) = None) as ->.
      2 TraceSemantics.halted; simpl; rewrite W; auto. }
      2 trace_semantics. End TraceSemantics.
      2 TraceSemantics.corestep_nyielded in TSTEP; auto].
      2 TraceSemantics.corestepN_splits_lt tgt_det TSTEPN' TSTEPN'' LT).
      2 TraceSemantics.corestepN_geq tgt_det TSTEPN' TSTEPN'' GEQ).
      2 TraceSemantics.corestepN_CORESTEPN; eauto).
      2 TraceSemantics.corestepN_CORESTEPN; auto].
      2 TraceSemantics.coopsem z_init target spec) geT x
      2 TraceSemantics.coopsem z_init target spec).
      2 TraceSemantics.coopsem z_init source spec) geS n (z', tr', c2) m2).
      2 TraceSemantics.coopsem z_init source spec) geS n (z, tr0, c) m) ->
      2 TraceSemantics.coopsem z_init source spec) geS n c2' m2').
      2 TraceSemantics.coopsem z_init source spec) geS n
      2 TraceSemantics.coopsem z_init source spec).
      2 trace_semantics.
      2 traces); eauto; try lia.
      2 traces ?]; eauto; exists traces; econstructor; eauto.
      2 traces' & ? & ?); eauto.
      2 traces_det in Hsafe'; eauto; subst; eauto.
      2 traces_det : forall n t traces traces' z z' s q m,
      2 trace - S (cTriplePi3 trace)) recs))))
      2 trace - S (cTriplePi3 trace)) recs))
      2 trace - S (cPairPi2 (cTriplePi3 trace))) recs)))
      2 trace - S (cPairPi1 rest)) recs *
      2 trace - S (cPairPi1 (cTriplePi3 trace))) recs)
      2 trace) (sch : schedule) (tp : ThreadPool.t) (PHI : rmap)
      2 trace * schedule * jstate ge))%type.
      2 traces associated with each internal
      2 traces are irrelevant*)
      2 traces and allo
      2 trace_same_order' : forall tr pre mid post logIdx strIdx c logIdx' strIdx' c',
      2 trace_same_order' : forall tr logIdx strIdx c logIdx' strIdx' c',
      2 trace_same_order'.
      2 trace_safe : forall n t z q m,
      2 trace_safe; eauto.
      2 Trace (s2 ^ x) -> isTrace (s1 ^ s2 ^ x).      
      2 Trace (s2 ^ x) -> isTrace (s1 ^ s2 ^ x).  
      2 trace s0) (Ht : t = trace_of_ostrace s0.(io_log)),
      2 Traces*)
      2 traces*)
      2 traces
      2 trace s.
      2 trace R (stream_app tr1 tr2) ->
      2 trace_rmap Vbd z) as [Mbd [? ?]].
      2 trace_rmap Vbc z) as [Mbc [? ?]].
      2 trace_rmap Vad z) as [Mad [? ?]].
      2 trace_rmap Vac z) as [Mac [? ?]].
      2 trace_rmap Rbd Vbd (join_fixup_trace_ok _ _ _ (join_comm Vb)) z) as [Mbd [? ?]].
      2 trace_rmap Rbc Vbc (join_fixup_trace_ok _ _ _ Vb) z) as [Mbc [? ?]].
      2 trace_rmap Rad Vad (join_fixup_trace_ok _ _ _ Vd) z) as [Mad [? ?]].
      2 trace_rmap  Rac Vac (join_fixup_trace_ok _ _ _ Va) z) as [Mac [? ?]].
      2 trace retain tr f) with tr. auto.
      2 trace retain tr f)).
      2 trace retain (proj1_sig tr) (resource_at f)}.
      2 trace (retain: AV.address -> Share.t)
      2 trace (repeat ([], []) (Z.to_nat size))
      2 trace_relations_work :
      2 TraceRelation `{State : Type} `{Event : Type} (step : step_relation State Event) :=
      2 TraceRelation}.
      2 trace; reflexivity | apply join_comm, core_unit]; subst; auto.
      2 trace_refine_vis_inv in H. auto.
      2 trace_refine_vis_add with (e := e) in H. apply H0 in H.
      2 trace_refine_ret_inv_r in H0.
      2 trace_refine_ret_inv_l in H0.
      2 trace_refine_ret.
      2 trace_refinement z z' c d d' m tm tm' tr0 ttr0 ttr cd j tn :
      2 trace_refinement in MATCH; eauto.
      2 Trace refinement: *)
      2 TRACE; red; intros beh AEXEC.
      2 trace recs : nat => trace - S (cTriplePi3 trace))
      2 trace recs : nat => trace - S (cPairPi2 (cTriplePi3 trace)))
      2 trace recs : nat => trace - S (cPairPi1 (cTriplePi3 trace)))
      2 trace recs : nat => codeNth (trace - S (cTriplePi3 trace)) recs).
      2 trace recs) (f2 trace recs)) (f3 trace recs))
      2 trace_readable (retain x) sh) k NoneP
      2 trace_readable (retain l) s)). {
      2 trace_readable:
      2 trace Rc c (resource_at z) l) (fixup_trace Rd d (resource_at z) l) (a @ l).
      2 trace r) by eauto using thread_serial_intr_disable_preserve_valid_trace.
      2 trace r2) by eauto using uctx_set_retval1_preserve_valid_trace.
      2 trace r1) by eauto using thread_serial_intr_enable_preserve_valid_trace.
      2 trace r0) by eauto using thread_cons_buf_read_preserve_valid_trace.
      2 trace_putc_trace : forall t t' c,
      2 trace_putc_trace; auto. Qed.
      2 trace (Ps : tracepred) tr tr' :
      2 trace -> Prop.
      2 trace (proj1_sig tr) (resource_at f)}.
      2 trace_preserved.
      2 trace_preserved :
      2 trace_prefix_tau_inv; eauto.
      2 trace_prefix_proper_r; eauto.
      2 trace_prefix_proper_l; eauto.
      2 trace_prefix_ind b1 b2 ->
      2 trace_prefix_ind b1 b2
      2 trace_prefixF (upaco2 trace_prefix_ r) (RetF s) (observe t) ).
      2 tracepred (Ps : tracepred) (tr : list Event.t) :=
      2 tracepred Ps' tr'
      2 tracepred Ps tr) ->
      2 tracepred Ps tr ->
      2 tracepred := list (Event.t -> Prop).
      2 tracepred_injclosed (Ps : tracepred) :=
      2 tracepred_injclosed Ps'
      2 trace)=> [p]; move: trace=> _; elim: p s1 s4 H1 H2.
      2 trace_perm in Hwrite as [(? & ? & Halloc) | ?].
      2 trace_perm : forall b ofs T, in_write_trace b ofs T = true ->
      2 trace)=> [p].
      2 trace_outputs_app.
      2 trace_outputs.
      2 trace (ot ot' : ostrace) : trace :=
      2 trace_ordered : valid_trace_ordered st.(io_log);
      2 trace_ordered (tr ++ tr') ->
      2 trace_ordered (tr ++ ev :: nil) ->
      2 trace_ordered tr :=
      2 trace_ordered tr ->
      2 trace_ordered_snoc valid_trace_ordered_app : core.
      2 trace_ordered_snoc : forall tr ev,
      2 trace_ordered (rev tr ++ ev :: nil) ->
      2 trace_ordered (rev tr) ->
      2 trace_ordered_app : forall tr' tr,
      2 trace_ordered.
      2 trace_ok (tr: AV.address -> option (rshare * AV.kind)) :=
      2 trace_ok : trace_itree_match z putc_z' st.(io_log) st'.(io_log);
      2 trace_ok : trace_itree_match z getc_z' st.(io_log) st'.(io_log);
      2 trace_ok : trace_itree_match z getcs_z' st.(io_log) st'.(io_log);
      2 trace_ok (proj1_sig v).
      2 trace_ok l).
      2 trace_ok: fixup_trace_ok tr)
      2 trace_ok: fixup_trace_ok (proj1_sig tr)) (f: rmap),
      2 trace_ok:
      2 trace_ok.
      2 trace of the workings of the search tactics. *)
      2 Trace of the fine-grained machine*)
      2 Trace of the coarse-grained machine*)
      2 trace_of_ostrace tr = TEnd.
      2 trace_of_ostrace (t : ostrace) : @trace IO_event unit :=
      2 trace_of_ostrace t')
      2 trace_of_ostrace t'
      2 trace_of_ostrace (strip_common_prefix IOEvent_eq s.(io_log) s'.(io_log)).
      2 trace_of_ostrace (strip_common_prefix IOEvent_eq ot ot').
      2 trace_of_ostrace (otr ++ otr') = app_trace tr tr'.
      2 trace_of_ostrace otr' in
      2 trace_of_ostrace otr in
      2 trace_of_ostrace ot_new in
      2 trace_of_ostrace nil.
      2 trace_of_ostrace (mkRecvEvents logIdx cs) = TEnd.
      2 trace_of_ostrace (IOEvPutc logIdx c :: nil))).
      2 trace_of_ostrace (IOEvGetc logIdx strIdx ret :: nil))).
      2 trace_of_ostrace_app, H; auto.
      2 trace_of_ostrace_app : forall otr otr',
      2 trace of newly added events *)
      2 trace_occ tr2).
      2 trace_occ tr) \/ 
      2 trace_occ mout = out ->
      2 trace_occ_inv _ (eq_sym H)
      2 trace_occ_in_inv _ (eq_sym H)
      2 trace_occ /=.
      2 trace n t traces z s q m -> OS_safeN_trace n t traces' z' s q m ->
      2 trace n t traces z s c' m' ->
      2 trace n t traces z s0 c m ->
      2 trace n t traces z q m ->
      2 trace n t traces z c' m' ->
      2 trace n t (Singleton TEnd) z c m.
      2 trace n t (fun x => x = (TEnd, s)) z s c m.
      2 trace n TEnd traces z s0 c m ->
      2 trace_n_stream s ms.
      2 Trace (notH L f0) (v, s)) with
      2 trace_not_dupfree_loop with (s:=s)(A:=A) as (s'&?).
      2 trace_not_atx; eauto.
      2 TraceNot at 1 in |- *.
      2 trace_non_empty_out tr)).
      2 trace_non_empty_out (filterMap pt_map_trace_occ tr) = filterMap trace_non_empty_out tr'.
      2 trace_non_empty_out (filterMap pt_map_trace_occ tr) = []).
      2 trace_non_empty_out.
      2 trace_non_empty_out : 
      2 trace NonDet unit -> Prop :=
      2 trace nil nil) by constructor.
      2 trace_nil : match_trace nil nil
      2 trace_nil : forall z, consume_trace z z TEnd.
      2 trace : nat => trace - S (cTriplePi3 trace)).
      2 trace : nat => trace - S (cPairPi2 (cTriplePi3 trace))).
      2 trace : nat => trace - S (cPairPi1 (cTriplePi3 trace))).
      2 trace : nat -> @trace io_events.IO_event unit ->
      2 trace : nat -> @trace event unit -> Ensemble (@trace event unit) -> OK_ty -> CC_core -> mem -> Prop :=
      2 trace : nat => S (cTriplePi3 trace)).
      2 trace : nat => S (cPairPi2 (cTriplePi3 trace))).
      2 trace : nat => S (cPairPi1 (cTriplePi3 trace))).
      2 trace : nat => pred (pred (g trace))).
      2 trace : nat => pred (g trace)).
      2 trace : nat => cTriplePi2 (cTriplePi3 trace)).
      2 trace : nat => cTriplePi2 (cPairPi2 (cTriplePi3 trace))).
      2 trace : nat => cTriplePi1 (cTriplePi3 trace)).
      2 trace : nat => cTriplePi1 (cPairPi2 (cTriplePi3 trace))).
      2 trace : nat => cTriplePi1 (cPairPi1 (cTriplePi3 trace))).
      2 trace : nat => cPairPi1 (cTriplePi3 (cTriplePi1 trace)))).
      2 trace : nat => 3)
      2 trace : nat => 0)
      2 trace) n,
      2 trace_mutual_exclusion (trace : list (name * (input + list output))) : Prop :=
      2 trace_mutual_exclusion tr /\
      2 trace_mutual_exclusion' (Some n) tr'
      2 trace_mutual_exclusion' None trace.
      2 trace_mutual_exclusion' None tr'
      2 trace_mutual_exclusion in *; simpl in *;
      2 trace_mutual_exclusion' h (tr ++ [(Server, inl i)]).
      2 trace_mutual_exclusion' h (tr ++ [(n, inr [])]).
      2 trace_mutual_exclusion' h (tr ++ [(Client n, inr [Locked])]).
      2 trace_mutual_exclusion' h (tr ++ [(Client c, inl Unlock)]).
      2 trace_mutual_exclusion' h (tr ++ [(Client c, inl i)]).
      2 trace_mutual_exclusion' (holder : option Client_index) (trace : list (name * (input + list output))) : Prop :=
      2 trace_mutual_exclusion'_extend_input_server. auto.
      2 trace_mutual_exclusion'_extend_input_server :
      2 trace_mutual_exclusion'_extend_input :
      2 trace_mutex'_unlock_extend; auto.
      2 trace_mutex'_unlock_extend. auto.
      2 trace_mutex'_unlock_extend :
      2 trace_mutex'_no_out_extend; auto.
      2 trace_mutex'_no_out_extend. auto.
      2 trace_mutex'_no_out_extend;
      2 trace_mutex'_no_out_extend.
      2 trace_mutex'_no_out_extend :
      2 trace_mutex'_locked_extend. auto.
      2 trace_mutex'_locked_extend :
      2 trace_monotone in Hexecj''.
      2 trace_monotone in Hexec';
      2 trace_monotone in H8.
      2 trace_monotone in H.
      2 trace_monotone Hstep0) as Htr0.
      2 trace_monotone Hexec_postw) as [tr_post_mk Heq_tr].
      2 trace_monotone Hexec_post_v) as Heq_trace.
      2 trace_monotone Hexec_post_u) as [tr_fl Heq].
      2 trace_monotone Hexec_post_u) as [tr''0 Heq].
      2 trace_monotone Hexec_post_spawn) as [tr''0 Heq].
      2 trace_monotone Hexec') as Heq.
      2 trace_mono : forall h la h', add_items_trace h la h' ->
      2 trace_mono : forall h k v i s h', add_item_trace h k v i s h' -> hists_mono h h'.
      2 trace_mono, Forall2_Znth with (i2 := i) in Hadd0; auto.
      2 trace) mf (xs : seq nat) (f fg: memren) (fp: fpool tpc) fuelF : Prop :=
      2 trace * mem) :=
      2 trace_match_state cd j (z,tr,c) m (z,ttr,d) tm.
      2 trace_match_state cd j (z, tr0, c) m (z, ttr0, d) tm ->
      2 trace_match_state cd j (z,tr0,c) m (z,ttr0,d) tm)
      2 trace_match_state cd' j' c' m' d' tm'.
      2 trace_match_state cd j c m d tm ->
      2 trace_match_state cd2 j2 (z,tr0,c2) m2 (z,ttr0,d) tm)
      2 trace_map : forall h k v i s h' (Hlenh : Zlength h = size)
      2 trace_map : forall h k v i h' l (Hwf : wf_hists h l) (Htrace : set_item_trace h k v i h')
      2 trace_map : forall h k v i h' l (Hwf : wf_hists h l) (Htrace : get_item_trace h k v i h')
      2 Trace, makeTraceImp, makeTraceNot, Formula_depth_rec2,
      2 trace machine_state mem res (*@semC Sem*).
      2 trace machine_state _ _ (*_*)
      2 trace) (m2 : mem)
      2 trace) : list (Z * Z * nat) :=
      2 trace := List.map tot_map_trace e.(evt_trace) |}.
      2 trace := list IOEvent.
      2 trace : list (hist * hist) -> list (Z * Z * Z * bool) -> list (hist * hist) -> Prop :=
      2 trace : list Event.t -> list Event.t -> Prop :=
      2 trace l'
      2 trace(J := OK_spec) prog IO_ext_sem IO_inj_mem OS_mem valid_trace n t traces z q m ->
      2 trace : Join (AV.address -> option (rshare * AV.kind)) :=
      2 trace : Join (AV.address -> option (pshare * AV.kind)) :=
      2 trace_itree_match (z0 z : IO_itree) (ot ot' : ostrace) :=
      2 Trace.ITraceBind
      2 trace itau1 of indices A from a stack P
      2 trace is unique. *)
      2 trace is irrelevant to further execution of the
      2 trace_irr with (tr'' := [::]) in H0.
      2 trace_irr with (tr := evS); eauto.
      2 trace_irr _ _ _ _ tr' _ _ _ _ H0) as (tr2' &STEP).
      2 trace_irr _ _ _ _ tr' _ _ _ _ H0) as (?&STEP). 
      2 trace_irr; eauto).
      2 trace_irr:
      2 Trace Invariants Preserved *)
      2 trace invariants hold. *)
      2 Trace Invariants *)
      2 trace; intros.
      2 trace in the parts of interest*)
      2 trace_inputs_app.
      2 trace_inputs.
      2 TraceInj: List.Forall2 (inject_mevent mu) tr1 tr2)
      2 trace_inj; auto.
      2 trace _ _ _ _ _ _ _ _ _ INIT_ok).
      2 trace in INIT_ok.
      2 trace in Hspec'; auto.
      2 trace in Hin.
      2 trace in H'. destruct H'; subst.
      2 trace in Hcall as [Hprefix]; auto; subst.
      2 trace in H as (b & q & ? & ? & Hsafe); eauto.
      2 traceinf_of_traceinf' (build_traceinf' (star_refl (step L) s0))).
      2 trace_inf_often_monot : paco.
      2 traceinf), forever step s T -> tstate.
      2 trace _ _ _ _ |- _ => induction H end;
      2 Trace (inc s tick ^ x) -> isTrace (s ^ inc s tick ^ x)
      2 traceInclusion (vc1 vc2 : valuation * cmd) :=
      2 traceInclusion; simplify.
      2 traceInclusion; eauto using simulation_skipping_fwd'.
      2 traceInclusion; eauto using simulation_skipping_bwd'.
      2 traceInclusion; eauto using simulation_multiple_fwd'.
      2 traceInclusion; eauto using simulation_fwd'.
      2 traceInclusion; eauto using simulation_bwd'.
      2 traceInclusion (at level 70).
      2 trace_incl (r <- read stdin;; k r) z.
      2 trace_incl instead of eutt. *)
      2 trace_incl {E : Type -> Type} {R : Type} :
      2 trace_incl; apply eutt_sutt; auto.
      2 TRACE in CEXEC. destruct IMPR as [EQ | [t' [A B]]].
      2 trace in *; break_exists; simpl in *; intuition
      2 trace in *;
      2 trace in
      2 Trace (impH L f0 f1) (v, s)) with
      2 TraceImp at 1 in |- *.
      2 trace /= /id /= {H_step}.
      2 trace /= /id /= {H_st}.
      2 trace _ _ Hvalid Hspec).
      2 trace, <- Htrace', <- app_trace_assoc, app_trace_strip; auto.
      2 trace (h : list (hist * hist)) k v i (success : bool) h' := Zlength h' = Zlength h /\
      2 trace h la h' -> Zlength h' = Zlength h.
      2 trace h la h') lr ->
      2 trace h la h' -> 0 <= j < Zlength la ->
      2 trace h la h')
      2 trace h' k v i true h) (Hk : k <> 0) (Hrep : repable_signed k)
      2 trace h' k v i s h''), add_items_trace h (la ++ [(k, v, i, s)]) h''.
      2 trace h' k v i false h) (Hk : k <> 0) (Hrep : repable_signed k)
      2 trace h k v i false h')
      2 trace h key value i success h')
      2 trace h [] h
      2 trace) & Hbuf). *)
      2 trace Hbuf]]]]]]].
      2 trace hasen't change, we add nil to match the type*)
      2 trace_halted: forall n z t c m i,
      2 trace_halted:
      2 trace H5 H1) ].
      2 trace h1 k v i s h2 /\ hists_mono h h1 /\ hists_mono h2 h'.
      2 trace : get_item_trace h k v i h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),
      2 trace_getc_trace : forall t t',
      2 trace_getc_trace; eauto using getc_trace_case_trans.
      2 trace_getc_trace; auto. Qed.
      2 trace f' t t' /\ injection_full f' m2.
      2 traceF_tau. apply Hincl; auto.
      2 trace (fst l) (snd l) T = true -> ~ in_free_list_trace (fst l) (snd l) T ->
      2 trace (fst l) (snd l) T /\ ((in_alloc_trace (fst l) (snd l) T = true /\
      2 trace (fst l) (snd l) T = false /\
      2 trace (fst l) (snd l) T = false ->
      2 trace (fst l) (snd l) T) eqn: Hwrite.
      2 trace (fst l) (snd l) T /\ access_at m' l k = None) \/
      2 trace (fst (fst st), snd (fst st) ++ tr, tp') m' tr' n) tp'),
      2 TraceForall v a (fun (b : fol.Formula L) _ => makeTrace b) (v0, s)).
      2 trace' : forall tr logIdx strIdx c,
      2 trace : forall tr logIdx strIdx c,
      2 Trace : forall (tp' : thread_pool) (m' : mem)
      2 trace : forall st v st',
      2 trace : forall st st' len addr read,
      2 trace : forall st e st',
      2 trace_forall_proper_aux; eauto.
      2 trace: forall n U tr tp m,
      2 trace : forall n st st' read addr read',
      2 trace : forall n st st',
      2 Trace : forall n : nat,
      2 trace : forall n mask st st',
      2 Trace (forallH L v a) (v0, s)) with
      2 trace : forall e args s s' ret t, valid_trace s -> IO_ext_sem e args s = Some (s', ret, t) ->
      2 TraceForall at 1 in |- *.
      2 trace; first by move=> s s' H1 H2 trace /= _ ->.
      2 trace := filterMap pt_map_trace_ev e.(evt_trace) |}.
      2 traceF; eauto.
      2 Trace f0 (v, s)) (makeTrace f1 (v, s))).
      2 Trace f0 (v, s)) (makeTrace f1 (v, s))))).
      2 Trace f0 (v, s)).
      2 trace_extern :
      2 trace_ev_outputs_eq H_out /=.
      2 trace_ev_outputs_eq H_o /=.
      2 trace event unit -> OS_state -> Prop.
      2 trace event unit).
      2 trace events? *)
      2 trace_event_rtype e) * (trace_event_rtype e)) :=
      2 trace_event_rtype (e : IOEvent) :=
      2 trace (ev1 :: tr1) (ev2 :: tr2).
      2 trace E S) (t : itree E R) (f : R -> itree E S) (k : unit -> itrace E R),
      2 trace E S) (t : itree E R) (f : R -> itree E S),
      2 trace E S),
      2 trace E R) (t : itree E S) (s : S),
      2 trace E R) (t : itree E S),
      2 trace E R) (t : itree E S)
      2 trace E R -> Prop) : itrace' E R -> Prop :=
      2 trace E R -> Prop :=
      2 trace E R) (k : A -> itree E R),
      2 trace E R -> itrace E S -> Prop)
      2 trace_erasure tr trsc -> trace_erasure tr' trsc').
      2 trace_erasure tr tr').
      2 trace_erasure tr tr'),
      2 TraceErasure.trace_erasure tr tr')).
      2 trace_erasure tr2 tr2' ->
      2 trace_erasure (tr1 ++ tr2) (tr1' ++ tr2').
      2 trace_erasure tr1 tr1' -> trace_erasure tr2 tr2').
      2 trace_erasure tr1 tr1' ->
      2 trace_erasure_spinlock_synchronized;
      2 trace_erasure_spinlock_synchronized:
      2 trace_erasure_spinlock_clean:
      2 Trace erasure preserves spinlock clean and well-synchronized*)
      2 trace_erasure_nth' in Hv; eauto.
      2 trace_erasure_nth:
      2 trace_erasure_nth':
      2 trace_erasure nil nil
      2 trace_erasure mem_erasure.
      2 trace_erasure (map [eta Events.internal tid] ev)
      2 trace_erasure_map:
      2 trace_erasure ltac:(by constructor)).
      2 trace_erasure : list Events.machine_event ->
      2 trace_erasure (ev :: tr) (ev' :: tr').
      2 TraceErasure event_semantics.
      2 trace_erasure event_erasure : trace_erasure.
      2 TraceErasure CoreErasure ThreadPoolErasure.
      2 trace_erasure_cat trace_erasure_map : trace_erasure.
      2 trace_erasure_cat:
      2 trace_erasure2]].
      2 trace_erasure2').
      2 trace_erasure0).
      2 trace_erasure]]]].
      2 trace_erasure.
      2 trace_erasure).
      2 trace_equiv_cons_inv.
      2 traceEquivalence (vc1 vc2 : valuation * cmd) :=
      2 traceEquivalence (at level 70).
      2 trace equivalence. *)
      2 trace_eq t1 t2.
      2 trace_entry with
      2 trace_entry : (name * (raft_input + list raft_output))) :=
      2 trace_end : forall t, app_trace (trace_of_ostrace t) TEnd = trace_of_ostrace t.
      2 TraceEmpty : trace_sim f [::] [::]
      2 trace empty_hists la h -> Zlength h = size.
      2 trace empty_hists la h) lr') as Hadd'.
      2 trace empty_hists la h') lr ->
      2 trace empty_hists (combine (combine (combine (sublist 0 i [1; 2; 3])
      2 trace empty_hists (combine (combine (combine [1; 2; 3] [1; 1; 1]) li) ls) h) &&
      2 trace empty_hists (combine (combine (combine
      2 trace; econstructor; try eassumption.
      2 trace']; eauto; try lia.
      2 trace); eauto; apply Htrace.
      2 trace; eauto;
      2 trace; eauto).
      2 trace'; eauto. }
      2 trace E A -> Prop) (pre : ev_list E -> Prop) : TraceSpec A :=
      2 trace dpm1; eauto. }
      2 trace do with a ghost? *)
      2 trace does not specify the number of steps required to produce the trace. *)
      2 traced monoidal category are good for.  We therefore
      2 Traced_monoidal_category
      2 TracedMonoidal.
      2 TracedIterativeFacts.
      2 TraceDisc_T H5 H6 H1) ].
      2 TraceDisc_T :
      2 trace: deriv s s') :
      2 trace: deriv s1 s4) :
      2 trace_dec client id tr);
      2 trace_dec client id ;
      2 trace_dec b ofs: forall es, {in_free_list_trace b ofs es} + {~in_free_list_trace b ofs es}.
      2 trace_dec b ofs ev) as [Hdead | Hlive].
      2 trace_dec b ofs ev).
      2 trace_dec b0 ofs' T) as [Hfree | HnotFree].
      2 trace)) (cTriplePi2 (cTriplePi1 trace))).
      2 trace_correct trace.
      2 trace_correct in Hsafen as [Hvalid]; eauto.
      2 trace_correct' in H as [? Htrace]; eauto.
      2 trace_correct' : forall n t traces z s0 c m
      2 trace_correct : forall n traces z s0 c m
      2 trace_correct; eauto.
      2 TraceCorrect :
      2 trace_correct:
      2 trace_console : valid_trace_console st.(io_log) st.(console).(cons_buf);
      2 trace_console tr cons := cons = compute_console tr.
      2 trace_console0, Zlength_app, Zlength_map in Hle.
      2 trace_console0, Zlength_app, Zlength_map in Hgt.
      2 trace_console0, Hcons; cbn; split; auto.
      2 trace_console0, Hcons; cbn; auto.
      2 trace_console0; cbn; auto.
      2 TraceCons : forall ev ev' tr tr'
      2 trace_cons :
      2 trace condition for putc *)
      2 trace_compose; eauto.
      2 trace client id (tr ++ o) ->
      2 trace client id o.
      2 trace client id o ->
      2 trace client id ;
      2 trace_case t t' ret :=
      2 trace_case t' t'' r ->
      2 trace_case t t' r ->
      2 trace_case t t' <-> putc_trace_case t t' c (-1).
      2 trace_case t t' <-> getc_trace_case t t' (-1).
      2 trace_case t t' c ret :=
      2 trace_case t' t'' c r ->
      2 trace_case t t' c r ->
      2 trace_case t t''.
      2 trace_case t t' :=
      2 trace_case_trans' : forall t t' t'' r,
      2 trace_case_trans : forall t t' t'' r,
      2 trace_case_trans' : forall t t' t'' c r,
      2 trace_case_trans : forall t t' t'' c r,
      2 trace_case_trans : forall t t' t'',
      2 trace_case_trans; [| eapply Hspec]; eauto.
      2 trace_case_trans; [eapply cons_intr_aux_trace_case |]; eauto.
      2 trace_case st.(io_log) st'.(io_log) (Int.unsigned c) (Int.signed ret).
      2 trace_case st.(io_log) st'.(io_log) (Int.signed ret).
      2 trace_case_refl : forall st, nil_trace_case st st.
      2 trace_case_refl : forall st, getc_trace_case st st (-1).
      2 trace_case_refl : forall st c, putc_trace_case st st c (-1).
      2 trace_case, putc_trace_case; intuition auto.
      2 trace_case; intros * Hspec; destruct_spec Hspec.
      2 trace_case in Htrace_case; eauto. *)
      2 trace_case in Hspec as []; eauto.
      2 trace_case in Hspec as []; auto.
      2 trace_case in Hspec'.
      2 trace_case in Hread as (_ & ?). *)
      2 trace_case in Hread as (_ & ?).
      2 trace_case in Hput.
      2 trace_case, getc_trace_case; intuition (auto; easy).
      2 trace_case : forall st v st',
      2 trace_case : forall st st' ret,
      2 trace_case : forall st st' c ret,
      2 trace_case : forall st e st',
      2 trace_case : forall n st st',
      2 trace_case : forall n mask st st',
      2 trace_case. *)
      2 trace b ofs ev),
      2 trace b ofs es <->
      2 trace A (x :: y) ->
      2 Trace a (v, var (newVar (v0 :: freeVarTerm L s ++ freeVarFormula L a))))
      2 trace: AV.address -> option (rshare * AV.kind)) (gtrace: AV.address -> option M)
      2 trace'; auto.
      2 trace as [tr''0 Heq_trace].
      2 trace_assoc : forall {E : Type -> Type} {R : Type} (t t' t'' : @trace E R),
      2 trace_assoc; auto.
      2 trace as [? [J1 Htrace]].
      2 trace as (Hlen & Hbounds & (Hi1 & Hr0) & Hi2 & Hrest).
      2 trace) as Hgx.
      2 trace as (h1 & h2 & IH); [omega | exists h1, h2].
      2 TraceArgument.
      2 trace (app_trace t t') t'' = app_trace t (app_trace t' t'').
      2 trace, app_trace_strip; auto. }
      2 trace. apply has_ext_noat in Htrace. auto.
      2 trace_app : forall z z' z'' t t', consume_trace z z' t -> consume_trace z' z'' t' ->
      2 trace_app; eauto.
      2 trace_app.
      2 trace /= /andP [H3] H4 Heq; move: Heq trace=> -> trace.
      2 TraceAndNormMorphism.
      2 TraceAndNormField.
      2 trace : add_item_trace h k v i s h') (Hk : k <> 0) (Hrepk : repable_signed k) (Hrepv : repable_signed v),
      2 trace_access_Error _ _ (ThreadLocal_ActionInterpret_resource _ Inv) _ _ _ H2)).
      2 trace1. Qed.
      2 trace1.ml" trace1.
      2 trace1 := map transpose [s1; s11; s12; s13; s14; s2].
      2 Trace_0 : jm_ctrace st m nil 0
      2 Trace_0: ftrace tp m U nil
      2 trace_0: forall z t c m, ext_safeN_trace O t (Singleton TEnd) z c m
      2 trace_0: forall t z s c m, OS_safeN_trace O t (fun x => x = (TEnd, s)) z s c m
      2 Trace_0: ctrace st m nil (* if a state has trace tr, it also has all prefixes of tr *)
      2 TRACE]]]]]]]]]]].
      2 TRACE.
      2 trace, _) |- _ ] =>
      2 trace))))))) 
      2 trace').
      2 trace _)).
      2 trace _ _ [] |- _ =>
      2 reify Σ Γ P with inspect (decompose_app P) := {
      2 reify Σ Γ P = Some φ /\ Msem φ can_val = P.
      2 reify (Σ : global_env_ext) (Γ : context) (P : term) : option form
      2 Reify x in
      2 reify x ::=
      2 reify_vst_typ) => tysum a b).
      2 reify_vst_typ) => (typtree a)).
      2 reify_vst_typ) => typrod a b).
      2 reify_vst_typ) => tyoption a).
      2 reify_vst_typ) => tylist a).
      2 reify_vst_typ) => tyArr a b).
      2 reify_vst_typ) => (fForall (func := expr typ func) a tympred)).
      2 reify_vst_typ) => (fExists (func := expr typ func) a tympred)).
      2 reify_vst_typ (@ExprCore.Abs typ func)) ::
      2 reify_vst_typ) (b: id nat)=>
      2 reify_vst_typ) (b: function reify_vst) (c: id nat)=>
      2 reify_vst_typ)
      2 reify_vst) (tts: id (list Ctypes.type)) (lr: function reify_vst) =>
      2 reify_vst trm:=
      2 reify_vst trm
      2 reify_vst term_table (SYMEXE_sound 1000) cbv_denote.
      2 reify_vst term_table (SYMEXE_sound 1000) admit.
      2 reify_vst (semax empty_tycontext p Sskip (normal_ret_assert p)).
      2 reify_vst) (e : id (list floyd.efield_lemmas.efield)) => App (@Inj typ func (inr (Smx (ftc_efield_b_norho e)))) a).
      2 reify_vst) (e : id Clight.expr) (lr : id efield_lemmas.LLRR) =>
      2 reify_vst eee :=
      2 reify_vst (data_at sh tint v1 v2).
      2 reify_vst (data_at_lemmas.data_at SeparationLogic.Tsh Clightdefs.tint).
      2 reify_vst) (b : id Ctypes.type)  =>
      2 reify_vst) => ((App (App (fImpl (func := expr typ func) typrop) a) b))).
      2 Reify (v : Q) : Type :=
      2 reify_var_type (t : constr) : constr
      2 reify_var_type (Binder.type b) in
      2 reify_var_for_in_is base_type_code x (Tbase t) not_x) =>
      2 reify (var : constr) (term : constr) :=
      2 reifyValue env Y in
      2 reifyValue env X in
      2 reifyValue env F in
      2 reify v2 in
      2 reify v1 in
      2 Reify v
      2 reify v :=
      2 reify_typ trm :=
      2 reify_type tR) in
      2 reify_type T) in
      2 reify_type t end in
      2 reify_TypeCode T in
      2 reify to which [var] binders,
      2 reifyToTelescope H := let t' := reifyToTelescope' H in curry_in_Quant t'.
      2 reifyToTelescope' H := let HT := type of H in let H' := uncurryT HT in
      2 reifyToTelescope H in apply (generalized_fg_equal t) in H; simpl in H.
      2 reify_to_poly (Qpower (inject_Z fx) gx) x
      2 reify_to_poly (Qminus fx 1) x in
      2 reify_to_poly (N.pow (N.of_nat fx) (N.of_nat gx)) x
      2 reify_to_poly gx x in
      2 reify_to_poly (f x) x in exact r)) with
      2 reify_to_poly fx x :=
      2 reify_to_poly (fx * / gx) x
      2 reify_to_poly (/ fx * / gx) x
      2 reify t := (ltac:(let rt := reify t in exact rt)) (only parsing).
      2 reify these sorts of terms, the trick is to pair [App] and
      2 reifyTerm xs X in
      2 reify_Term var z in
      2 reify term_table tac_sound reduce :=
      2 reify_terms_and_then
      2 Reify (term : constr) :=
      2 reify_tauto' P vars in
      2 reify_tauto' P vars :=
      2 reify t :=
      2 reify.statement_eq.
      2 reify (S_tag (S (nat_of x))) (@NatS nat x).
      2 reify_S `{rx : reify_of x}
      2 reify_spec' ty spec n
      2 reify_spec' ty spec (count_prod ty).
      2 reify_spec' (ty : constr) (spec : constr) (n : int) : constr
      2 reify_spec (spec : constr) : constr
      2 reify_spec (pretype x) in exact $v)) (only parsing, at level 10).
      2 reify_spec' body (mkApp spec [mkRel n]) (Int.sub n 1) in
      2 reify_sound := refl_equal
      2 reify_sound : D reify = v
      2 reify_sound.
      2 reify.solve_exprD.
      2 reify.simple_reify v in
      2 reify. simpl. apply inversion_Rel in t as [? [[? e] ?]].
      2 reify_sexpr ( Ex x, [| x = 1|]).  *)
      2 reify_semax_post' : my_lemma.
      2 reify_semax_post').
      2 reify_semax_post')
      2 Reify rv in
      2 Reify_rhs := Reify.Reify_rhs base_type (interp_base_type _) op (interp_op _).*)
      2 Reify_rhs := ReifyCommon.post_Reify_rhs.
      2 Reify_rhs; reflexivity.
      2 Reify_rhs_of Reify _ :=
      2 Reify_rhs_of_cps Reify_cps _ :=
      2 Reify_rhs _ := make_pre_Reify_rhs nat_of untag false false.
      2 Reify_rhs _ := make_do_Reify_rhs ltac:(fun _ => denote)
      2 Reify rhs in
      2 Reify_rhs_gen Reify prove_interp_compile_correct interp_op try_tac :=
      2 Reify_rhs_gen
      2 Reify_rhs base_type_code interp_base_type op make_const interp_op :=
      2 Reify_rhs base_type_code interp_base_type op interp_op :=
      2 Reify_rhs] *)
      2 Reify_rhs :=
      2 REIFY := ReifySepExpr.ReifySepExpr SEP.
      2 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify n @ GallinaReify.Reify idxs @ GallinaReify.Reify balance)
      2 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify n @ GallinaReify.Reify balance)
      2 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify n)
      2 REIFY.reify_hints unfoldTac pcT stateT isConst fwd types funcs preds ltac:(fun funcs preds fwd' =>
      2 Reify.Reify base_type interp_base_type op make_const e in
      2 Reify.Reify base_type (interp_base_type _) op e in
      2 Reify.Reify.
      2 reify_rec x3 in
      2 reify_rec fx in
      2 reify_prop_right: my_lemma.
      2 reify_prop_right).
      2 reify : polynomial.
      2 reify_poly f in exact v : typeclass_instances.
      2 reify_poly f :=
      2 Reify.PHOASUtil.
      2 Reify Pattern patterns_vst += (!!Zpower.two_power_nat) =>  (@Inj typ func (inr (Other ftwo_power_nat))).
      2 Reify Pattern patterns_vst += (!!Zdiv.Zmod) => (@Inj typ func (inr (Zop fZ_mod))).
      2 Reify Pattern patterns_vst += (!!veric.expr.tc_val) => (@Inj typ func (inr (Smx (ftc_val)))).
      2 Reify Pattern patterns_vst += (!!Values.Vundef) => (@Inj typ func (inr (Value fVundef))).
      2 Reify Pattern patterns_vst += (!!Values.Vptr) => (@Inj typ func (inr (Value fVptr))).
      2 Reify Pattern patterns_vst += (!!Values.Vlong) => (@Inj typ func (inr (Value fVlong))).
      2 Reify Pattern patterns_vst += (!!Values.Vint) => (@Inj typ func (inr (Value fVint))).
      2 Reify Pattern patterns_vst += (!!Values.Vfloat) => (@Inj typ func (inr (Value fVfloat))).
      2 Reify Pattern patterns_vst_typ += (!!Values.val) => tyval.
      2 Reify Pattern patterns_vst_typ += (!!unit) => tyunit.
      2 Reify Pattern patterns_vst_typ += (!!sum @ ?0 @ ?1) =>
      2 Reify Pattern patterns_vst_typ += (!!shares.share) => tyshare.
      2 Reify Pattern patterns_vst_typ += (!!shares.Share.t) => tyshare.
      2 Reify Pattern patterns_vst_typ += (!!seplog.ret_assert) => tyret_assert.
      2 Reify Pattern patterns_vst_typ += (!!SeparationLogic.ret_assert) => tyret_assert.
      2 Reify Pattern patterns_vst_typ += (@RImpl (?0) (?1)) =>
      2 Reify Pattern patterns_vst_typ += (!!Prop) => typrop.
      2 Reify Pattern patterns_vst_typ += (!!prod @ ?0 @ ?1) =>
      2 Reify Pattern patterns_vst_typ += (!!option @ ?0) =>
      2 Reify Pattern patterns_vst_typ += (!!Maps.PTree.t @ ?0) =>
      2 Reify Pattern patterns_vst_typ += (!!list_dt.listspec @ ?!0 @ ?!1 ) =>
      2 Reify Pattern patterns_vst_typ += (!!@list_dt.elemtype @ ?0 @ ?1 @ ?2) =>
      2 Reify Pattern patterns_vst_typ += (!!list @ ?0) =>
      2 Reify Pattern patterns_vst_typ += (!!(lift.lifted (expr.LiftEnviron Prop))) =>
      2 Reify Pattern patterns_vst_typ += (!!(lift.lifted (expr.LiftEnviron expr.mpred))) =>
      2 Reify Pattern patterns_vst_typ += (!!juicy_extspec.OracleKind) => tyOracleKind.
      2 Reify Pattern patterns_vst_typ += (!!Integers.Int.int) => tyint.
      2 Reify Pattern patterns_vst_typ += (!!Integers.int64) => tyint64.
      2 Reify Pattern patterns_vst_typ += (!!Integers.comparison) => tycomparison.
      2 Reify Pattern patterns_vst_typ += (!!floyd.type_id_env.type_id_env) => tytype_id_env.
      2 Reify Pattern patterns_vst_typ += (!!floyd.nested_field_lemmas.gfield) => tygfield.
      2 Reify Pattern patterns_vst_typ += (!!floyd.efield_lemmas.efield) => tyefield.
      2 Reify Pattern patterns_vst_typ += (!!floyd.data_at_lemmas.reptype @ ?0) =>
      2 Reify Pattern patterns_vst_typ += (!!Floats.float) => tyfloat.
      2 Reify Pattern patterns_vst_typ += (!!expr.tycontext) => tytycontext.
      2 Reify Pattern patterns_vst_typ += (!!expr.tc_assert) => tytc_assert.
      2 Reify Pattern patterns_vst_typ += (!!expr.mpred) => tympred.
      2 Reify Pattern patterns_vst_typ += (!!expr.funspec) => tyfunspec.
      2 Reify Pattern patterns_vst_typ += (!!expr.exitkind) => tyexitkind.
      2 Reify Pattern patterns_vst_typ += (!!expr.environ) => tyenviron.
      2 Reify Pattern patterns_vst_typ += (!!efield_lemmas.LLRR) => tyllrr.
      2 Reify Pattern patterns_vst_typ += (!!Datatypes.nat) => tynat.
      2 Reify Pattern patterns_vst_typ += (!!Ctypes.type) => tyc_type.
      2 Reify Pattern patterns_vst_typ += (!!Ctypes.typelist) => tytypelist.
      2 Reify Pattern patterns_vst_typ += (!!Ctypes.fieldlist) => tyfieldlist.
      2 Reify Pattern patterns_vst_typ += (!!Cop.unary_operation) => tyunary_operation.
      2 Reify Pattern patterns_vst_typ += (!!Cop.binary_operation) => tybinary_operation.
      2 Reify Pattern patterns_vst_typ += (!!Clight.statement) => tystatement.
      2 Reify Pattern patterns_vst_typ += (!!Clight.expr) => tyc_expr.
      2 Reify Pattern patterns_vst_typ += (!!bool) => tybool.
      2 Reify Pattern patterns_vst_typ += (!!BinNums.Z) => tyZ.
      2 Reify Pattern patterns_vst_typ += (!!BinNums.positive) => typositive.
      2 Reify Pattern patterns_vst_typ += (!!BinNums.N ) => tyN.
      2 Reify Pattern patterns_vst_typ += (!!AST.ident) => tyident.
      2 Reify Pattern patterns_vst += (!!tc_temp_id_b_norho @ ?0 @ ?1 ) =>
      2 Reify Pattern patterns_vst += (!!tc_LR_b_norho) => (@Inj typ func (inr (Smx (ftc_LR_b_norho)))).
      2 Reify Pattern patterns_vst += (!!tc_expr_b_norho) => (@Inj typ func (inr (Smx ftc_expr_b_norho))).
      2 Reify Pattern patterns_vst += (!!tc_efield_b_norho @ ?0 @ ?1) =>
      2 Reify Pattern patterns_vst += (!!@Some @ ?0) => (fun (a : function reify_vst_typ) =>
      2 Reify Pattern patterns_vst += (!!seplog.typed_true) => (@Inj typ func (inr (Other ftyped_true))).
      2 Reify Pattern patterns_vst += (!!seplog.TT) => (mkTrue (func := func) tympred).
      2 Reify Pattern patterns_vst += (!!seplog.prop) => (@Inj typ func (inr (Sep fprop))).
      2 Reify Pattern patterns_vst += (!!seplog.orp) => (fOr (func := expr typ func) tympred).
      2 Reify Pattern patterns_vst += (!!seplog.normal_ret_assert) => (@Inj typ func (inr (Smx fnormal_ret_assert))).
      2 Reify Pattern patterns_vst += (!!seplog.FF) => (mkFalse (func := func) tympred).
      2 Reify Pattern patterns_vst += (!!(@seplog.exp expr.mpred SeparationLogic.Nveric) @ ?0) =>
      2 Reify Pattern patterns_vst += (!!seplog.andp) => (fAnd (func := expr typ func) tympred).
      2 Reify Pattern patterns_vst += (!!(@seplog.allp expr.mpred SeparationLogic.Nveric) @ ?0) =>
      2 Reify Pattern patterns_vst += (!!SeparationLogic.writable_share) => (@Inj typ func (inr (Smx fwritable_share))).
      2 Reify Pattern patterns_vst += (!!SeparationLogic.typeof_temp) => (@Inj typ func (inr (Smx (ftypeof_temp)))).
      2 Reify Pattern patterns_vst += (!!SeparationLogic.Tsh) => (@Inj typ func (inr (Smx fTsh))).
      2 Reify Pattern patterns_vst += (!!SeparationLogic.tc_environ) => (@Inj typ func (inr (Smx (ftc_environ)))).
      2 Reify Pattern patterns_vst += (!!@SeparationLogicSoundness.SoundSeparationLogic.CSL.semax) => (@Inj typ func (inr (Smx fsemax))).
      2 Reify Pattern patterns_vst += (!!SeparationLogic.normal_ret_assert) => (@Inj typ func (inr (Smx fnormal_ret_assert))).
      2 Reify Pattern patterns_vst += (!!SeparationLogic.local) => (@Inj typ func (inr (Sep flocal))).
      2 Reify Pattern patterns_vst += (!!semax.semax) => (@Inj typ func (inr (Smx fsemax))).
      2 Reify Pattern patterns_vst += (!!sc_set_load_store.msubst_eval_LR @ ?0 @ ?1 @ ?2 @ ?3) =>
      2 Reify Pattern patterns_vst += (RPi (?0) (?1)) => (fun (x : function reify_vst_typ) (y : function reify_vst) =>
      2 Reify Pattern patterns_vst += (@RImpl (?0) (?1)) =>
      2 Reify Pattern patterns_vst += (!!@None @ ?0) => (fun (a : function reify_vst_typ) =>
      2 Reify Pattern patterns_vst += (!!nested_field_lemmas.UnionField) => (@Inj typ func (inr (Smx funion_field))).
      2 Reify Pattern patterns_vst += (!!nested_field_lemmas.StructField) => (@Inj typ func (inr (Smx fstruct_field))).
      2 Reify Pattern patterns_vst += (!!nested_field_lemmas.nested_field_type2) => (@Inj typ func (inr (Smx (fnested_field_type2)))).
      2 Reify Pattern patterns_vst += (!!nested_field_lemmas.legal_nested_field) => (@Inj typ func (inr (Smx (flegal_nested_field)))).
      2 Reify Pattern patterns_vst += (!!nested_field_lemmas.ArraySubsc) => (@Inj typ func (inr (Smx farray_subsc))).
      2 Reify Pattern patterns_vst += (!!msubst_eval_lvalue @ ?0 @ ?1 @ ?2) =>
      2 Reify Pattern patterns_vst += (!!msubst_eval_expr @ ?0 @ ?1 @ ?2) =>
      2 Reify Pattern patterns_vst += (!!(@msl.seplog.later veric.expr.mpred SeparationLogic.Nveric _)) => (@Inj typ func (inr (Smx (flater)))).
      2 Reify Pattern patterns_vst += (!!(@msl.seplog.later (veric.expr.environ-> veric.expr.mpred) (@SeparationLogic.LiftNatDed' expr.mpred SeparationLogic.Nveric) _)) => (@Inj typ func (inr (Smx (flater_lift)))).
      2 Reify Pattern patterns_vst += (!!locallistD) => (@Inj typ func (inr (Smx flocallistD))).*)
      2 Reify Pattern patterns_vst += (!!localD) => (@Inj typ func (inr (Smx (flocalD)))).
      2 Reify Pattern patterns_vst += (!!LocalD @ (?0) @ (?1) @ (?2)) =>
      2 Reify Pattern patterns_vst += (!!local2ptree.msubst_eval_LR) => (@Inj typ func (inr (Smx (fmsubst_eval_LR)))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.unsigned) => (@Inj typ func (inr (Intop fint_unsigned))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.sub) => (@Inj typ func (inr (Intop fint_sub))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.signed) => (@Inj typ func (inr (Intop fint_signed))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.neg) => (@Inj typ func (inr (Intop fint_neg))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.mul) => (@Inj typ func (inr (Intop fint_mul))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.max_unsigned) => (@Inj typ func (inr (Intop fint_max_unsigned))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.ltu) => (@Inj typ func (inr (Intop fint_ltu))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.lt) => (@Inj typ func (inr (Intop fint_lt))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.cmpu) => (@Inj typ func (inr (Intop fint_cmpu))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.cmp) => (@Inj typ func (inr (Intop fint_cmp))).
      2 Reify Pattern patterns_vst += (!!Integers.Int.add) => (@Inj typ func (inr (Intop fint_add))).
      2 Reify Pattern patterns_vst += (!!expr.is_neutral_cast @ ?0 @ ?1) =>
      2 Reify Pattern patterns_vst += (!!expr.force_ptr) =>  (@Inj typ func (inr (Other fforce_ptr))).
      2 Reify Pattern patterns_vst += (!!expr.eval_unop @ ?0 @ ?1) => (fun (a : id Cop.unary_operation) (b : id Ctypes.type) =>  (@Inj typ func (inr (Eval_f (feval_unop a b))))).
      2 Reify Pattern patterns_vst += (!!expr.eval_id @ ?0) => (fun (a : id AST.ident) => (@Inj typ func (inr (Eval_f (feval_id a))))).
      2 Reify Pattern patterns_vst += (!!expr.eval_field @ ?0 @ ?1) => (fun (a : id Ctypes.type) (b: id AST.ident) => (@Inj typ func (inr (Eval_f (feval_field a b))))).
      2 Reify Pattern patterns_vst += (!!expr.eval_cast @ ?0 @ ?1 ) =>
      2 Reify Pattern patterns_vst += (!!expr.eval_binop @ ?0 @ ?1 @ ?2) =>
      2 Reify Pattern patterns_vst += (!!expr.deref_noload @ ?0 @ ?1) => (fun (a : id Ctypes.type) => (@Inj typ func (inr (Eval_f (fderef_noload a))))).
      2 Reify Pattern patterns_vst += (!!@ex @ ?0) => (fun (a : Patterns.function reify_vst_typ) => (fExists (func := expr typ func) a typrop )).
      2 Reify Pattern patterns_vst += (!!efield_lemmas.nested_efield @ ?0 @ ?1 @ ?2) =>
      2 Reify Pattern patterns_vst += (!!efield_lemmas.legal_nested_efield @ ?0 @ ?1 @ ?2 @ ?3 @ ?4 @ ?5) =>
      2 Reify Pattern patterns_vst += (!!denote_tc_assert_b_norho) => (@Inj typ func (inr (Smx fdenote_tc_assert_b_norho))).
      2 Reify Pattern patterns_vst += (!!Coqlib.align) =>  (@Inj typ func (inr (Other falign))).
      2 Reify Pattern patterns_vst += (!!Clight.typeof) => (@Inj typ func (inr (Other ftypeof))).
      2 Reify Pattern patterns_vst += (!!client_lemmas.type_is_by_value) => (@Inj typ func (inr (Smx ftype_is_by_value))).
      2 Reify Pattern patterns_vst += (!!client_lemmas.SEPx) => (@Inj typ func (inr (Smx fSEPx))).*)
      2 Reify Pattern patterns_vst += (!!client_lemmas.PROPx) => (@Inj typ func (inr (Smx fPROPx))).
      2 Reify Pattern patterns_vst += (!!client_lemmas.LOCALx) => (@Inj typ func (inr (Smx fLOCALx))).
      2 Reify Pattern patterns_vst += (!!bool_funcs.type_is_int @ ?0) =>
      2 Reify Pattern patterns_vst += (!!BinInt.Z.sub) => (@Inj typ func (inr (Zop fZ_sub))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.opp) => (@Inj typ func (inr (Zop fZ_opp))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.mul) => (@Inj typ func (inr (Zop fZ_mul))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.max) => (@Inj typ func (inr (Zop fZ_max))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.lt) => (@Inj typ func (inr (Zop fZ_lt))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.le) => (@Inj typ func (inr (Zop fZ_le))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.gt) => (@Inj typ func (inr (Zop fZ_gt))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.ge) => (@Inj typ func (inr (Zop fZ_ge))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.div) => (@Inj typ func (inr (Zop fZ_div))).
      2 Reify Pattern patterns_vst += (!!BinInt.Z.add) => (@Inj typ func (inr (Zop fZ_add))).
      2 Reify Pattern patterns_vst += (!!assert_lemmas.Ews) => (@Inj typ func (inr (Smx fEws))).
      2 Reify Pattern patterns_vst += (!!assertD) => (@Inj typ func (inr (Smx (fassertD)))).
      2 Reify Pattern patterns_vst += (!!and) =>  (@Inj typ func (inr (Other fand))).
      2 Reify.Parametricity.
      2 reify : P
      2 reify (O_tag O) (@NatO nat).
      2 reify_op op op_head x
      2 reify_op op op_head in
      2 reify_op op op_head extra ::=
      2 reify_op op op_head expr in
      2 reify_op op op_head 4 (Cmovne TZ TZ TZ TZ TZ))
      2 reify_op op op_head 4 (Cmovle TZ TZ TZ TZ TZ))
      2 reify_op op op_head 3 OPsubc)
      2 reify_op op op_head 3 OPshrd)
      2 reify_op op op_head 3 OPselc)
      2 reify_op op op_head 3 OPor)
      2 reify_op op op_head 3 OPadc)
      2 reify_op op op_head 2 (Sub TZ TZ TZ))
      2 reify_op op op_head 2 (Shr TZ TZ TZ))
      2 reify_op op op_head 2 (Shl TZ TZ TZ))
      2 reify_op op op_head 2 OPshr)
      2 reify_op op op_head 2 OPshl)
      2 reify_op op op_head 2 OPmuldw)
      2 reify_op op op_head 2 (Mul TZ TZ TZ))
      2 reify_op op op_head 2 (Lor TZ TZ TZ))
      2 reify_op op op_head 2 (Land TZ TZ TZ))
      2 reify_op op op_head 2 (Add TZ TZ TZ))
      2 reify_op op op_head 1 OPldi)
      2 reify_op op op_head 1 (Neg TZ TZ int_width))
      2 reify_op op op_head ::=
      2 reify_op op op_head
      2 reify_op: head is neg but body is wrong:" extra
      2 reify_of (x * y) := (rx * ry)%expr.
      2 reify_of var x).
      2 reify_of (S x) := NatS rx.
      2 reify_of O := NatO.
      2 reifyObj cs y in
      2 reifyObj cs x in
      2 reify.nth_reif.
      2 reify_now_later : my_lemma.
      2 reify_now_later).
      2 reify := nil 
      2 reify { nat_of : tagged_nat ; reified_nat_of :> @expr nat }.
      2 reify_NatMul `{rx : reify_of x, ry : reify_of y}
      2 reifyMSHCOL dynwin_MSHCOL1
      2 reify me :=
      2 reifyMapTerm env M in
      2 Reify (map f) nil :=
      2 Reify (map f) (a :: b).
      2 Reify.Ltac2Common.
      2 reify_loc isConst l types funcs uvars vars ltac:(fun uvars funcs l =>
      2 reify.local2list.
      2 reify_list retv))
      2 reify_list _) (reify_list _) |- _ ] => apply expr.wf_reify_list in H
      2 reify_list _) (reify_list _) ] => apply expr.wf_reify_list
      2 reify_list _), H' : reflect_list ?e = None |- _ ]
      2 reify_list _) ?e, H' : reflect_list ?e = None |- _ ]
      2 reify.list_efield_eq.
      2 reify_list
      2 REIFY.lift_ssignatures_over_repr preds types_rV pcT stateT in
      2 REIFY.lift_signatures_over_repr funcs types_rV in
      2 REIFY.lift_lemmas_over_repr fwd' types_rV pcT stateT in
      2 REIFY.lift_lemmas_over_repr bwd' types_rV pcT stateT in
      2 reify_lemma reify_vst writable_share_top.
      2 reify_lemma reify_vst writable_Ews.
      2 reify_lemma reify_vst (semax_store_localD temp var ret gt t t_root e0 e1 e2 efs tts e lr n).
      2 reify_lemma reify_vst (semax_set_localD temp var ret gt id e ty).
      2 reify_lemma reify_vst (semax_seq_reif s1 s2).
      2 reify_lemma reify_vst (semax_load_localD temp var ret gt id t t_root e0 e1 efs tts e lr n).
      2 reify_lemma reify_vst msubst_efield_denote_nil.
      2 reify_lemma reify_vst (msubst_efield_denote_cons_union fld efs).
      2 reify_lemma reify_vst (msubst_efield_denote_cons_struct fld efs).
      2 reify_lemma reify_vst (msubst_efield_denote_cons_array ei efs).
      2 reify_lemma reify_vst mpred_semax_post'.
      2 reify_lemma reify_vst mpred_prop_right.
      2 reify_lemma reify_vst mpred_now_later.
      2 reify_lemma reify_vst mpred_derives_refl.
      2 reify_lemma reify_vst (hoist_later_in_pre_aux temp var ret gt s).
      2 reify_lemma reify_vst (fold_right_sepcon_later_derives).
      2 reify_lemma reify_vst
      2 reify_input_type T :=
      2 reify_input_type B in
      2 reify] in k.
      2 reifying to PHOAS. *)
      2 Reifying the Syntax of a Trivial Tautology Language *)
      2 reifying:")) in
      2 reify:")) in
      2 reify_hlip_ind : my_lemma.
      2 reify_hlip_ind).
      2 reify_hlip_base temp var ret gt s)).
      2 reify_hlip_base temp var ret gt s))
      2 reify_hlip_base (temp : PTree.t (type * bool)) (var : PTree.t type)
      2 reify_helper x ctx;
      2 reify_helper var x (@var_context.nil var).
      2 reify_helper var term ctx :=
      2 reify_goal :=
      2 reify (@FunY Δ)) r.
      2 Reify (fun y : (Z * Z)
      2 reify.func_eq.
      2 reify : forall {κ : kind} {Δ : Ctx} (_ : T Δ), Basics.flip nf κ Δ.
      2 reify: forall s1 m1 t s2,
      2 reify_flat_type tR) in
      2 reify_flat_type T) in
      2 reify_flat_type t end in
      2 reify_flat_type T :=
      2 reify.  Finally,
      2 reifyf: " case)) in
      2 reifyf: Attempting to reify:" e
      2 reify_faster_1arg ().
      2 reify_faster ();
      2 Reify f a) (Rb : ClassReify (map f) b) 
      2 reify" failed.
      2 ReifyExpr.VarType (T' * T) =>
      2 ReifyExpr.VarType (T * T') =>
      2 ReifyExpr.VarType ?T => @ST.star _ _ _ (@?L x) (@?R x) =>
      2 reify_expr_tac :=
      2 reify_exprs ltac:(isConst) es types funcs uvars vars ltac:(fun uvars funcs es =>
      2 reify_expr reify_vst_typ k [ True ] [ trm ].
      2 reify_expr reify_vst k [ True ] [ trm ]
      2 reify_expr reify k
      2 ReifyExpr.reify_exprs ltac:(isConst) pures typesV funcs uvars vars ltac:(fun uvars funcs pures =>
      2 ReifyExpr.reflectType types stateType in
      2 ReifyExpr.reflectType types pcType in
      2 ReifyExpr.props_types all_props in
      2 ReifyExpr.props_proof all_props in
      2 reify_expr (not (1 + 3 = 2 + 2)).  *)
      2 reify_expr ltac:(isConst) e types funcs uvars vars ltac:(fun uvars funcs e =>
      2 reify_expr isConst P types funcs uvars vars ltac:(fun uvars funcs P =>
      2 ReifyExpr.extend_all_types Ts types_ in
      2 ReifyExpr.extend_all_types rt types in
      2 ReifyExpr.collectTypes_exprs ltac:(isConst) pures Ts ltac:(fun Ts =>
      2 ReifyExpr.collect_props ltac:(ILTacCommon.reflectable shouldReflect) in
      2 ReifyExpr.collect_props ltac:(ILTacCommon.reflectable shouldReflect)
      2 Reify. (* export for the tactic redefinitions *)
      2 Reify' e := Reify.Reify' base_type (interp_base_type _) op e.
      2 Reify' e := Reflection.Reify.Reify' base_type interp_base_type op e.
      2 reify e :=
      2 Reify] does Ltac type inference to get the type *)
      2 reify_derives_refl)))) (@RTac.Minify.MINIFY typ (expr typ func) _).
      2 reify_derives_refl : my_lemma.
      2 reify_derives_refl).
      2 Reify Declare Typed Table term_table : BinNums.positive => reify_vst_typ.
      2 Reify Declare Syntax reify_vst_typ :=
      2 Reify Declare Syntax reify_vst :=
      2 Reify Declare Patterns patterns_vst_typ := typ.
      2 Reify Declare Patterns patterns_vst_hastype := (ExprCore.expr typ func).
      2 Reify Declare Patterns patterns_vst := (ExprCore.expr typ func).
      2 reify_correct :
      2 reify := cons (@reify _ _ _ _ Ra) (@reify _ _ _ _ Rb) |}.
      2 REIFY.collectTypes_sexpr ltac:(isConst) R types k)
      2 REIFY.collectTypes_sexpr ltac:(isConst) L types ltac:(fun types =>
      2 reify_cls (var : Type) (term : nat) := do_reify : @expr var.
      2 reify_cls ?var ?term ]
      2 reify_cls _ _)
      2 reify_base_type T := base_reify_type T.
      2 reify_base_type T :=
      2 Reify base_type_code interp_base_type op rhs in
      2 Reify base_type_code interp_base_type op make_const e :=
      2 Reify base_type_code interp_base_type op make_const)
      2 Reify base_type_code interp_base_type op e :=
      2 reify base.type.base base.base_interp ident ident.buildIdent (@ident.interp) ident.buildInterpIdentCorrect t v.
      2 reify base.type.base base.base_interp base.type.base_beq ident ident.buildIdent base.reflect_base_beq t v.
      2 reify_bare_spec ty in
      2 reify_bare_spec (ty : constr) : constr
      2 reify_aux reify term_table P namee;
      2 reify_aux reify term_table e n :=
      2 Reify_as base.type.base base.base_interp base.type.base_beq ident ident.buildIdent base.reflect_base_beq t v.
      2 reify_args_for_apply0 reify_Term var ret
      2 reify annotate_with_state is_let_bound t e b_in))) arg1
      2 reify_and_change;
      2 reify_and_change.
      2 reify_abs: Attempting to reify:" e
      2 reify (1 + 2) in
      2 reify (1 + 2 * 3) in
      2 reify ((1, 1), (1, (1, 1))) in pose e.
      2 reify"; *)
      2 reify _ {_}.
      2 reify (). *)
      2 profiler output *)
      2 profiler manipulation *)
      2 Profiler cannot yet handle backtracking into multi-success
      2 profile-invalid-stack-no-self".
      2 profile + idtac); fail);
      2 Profiled (fun l H => qs0 (exist _ l H)) Heq_l x));
      2 Profile CutOff 47.
      2 profile-backtracking,ltac] *)
      2 profile;
      2 Print X'
      2 Print writable_Tsh_lemma. *)
      2 Print writable_Ews_lemma. *)
      2 print_w p = (a,b,c,d) ->
      2 print_w in H6.
      2 print_well_typed_correct; try eapply print_well_typed_correct';
      2 print_well_typed_correct' pc le lp e :
      2 print_well_typed_correct pc le lp e :
      2 print_w : addr -> addr * addr * addr * addr.
      2 print_w.
      2 Print v;; tmReturn p
      2 Print void1.
      2 Print vcfloat.FPCore.type.
      2 Print varvar.
      2 Print Val.inject.
      2 Print val.
      2 Print v
      2 Print UseA. (* ANOMALY! Int.Map.get's assert false *)
      2 Print Universes Subgraph(i j).
      2 Print Universes Subgraph (Foo.i).
      2 print_universes_graph (G : universes_graph) :=
      2 print_universes_graph G ^ nl ^ *)
      2 print_universes_graph G
      2 print_unfold in e0.
      2 print_unfold :
      2 Print Uint63.mod.
      2 print u ;;
      2 print_type x:= let t:= get_type x in idtac t.
      2 Print type for and ident*)
      2 Print typecheck_lvalue.
      2 print Type. *)
      2 print {T : Type} {ST : Show T} (val : T) : PrinterMonad unit :=
      2 Print tt'.
      2 Print true_galore.
      2 Print True.
      2 Print trirecord.
      2 Print triple.
      2 Print "toto" ;;
      2 Print thing. (* forall x y : foo, bla x y *)
      2 Print thing. (* forall (x : foo@{thing.u0}) (y : foo@{thing.u1}), bla x y *)
      2 Print thing. (* BAD: forall x y : @foo@{thing.u0} True, @bla True True x y *)
      2 print the same term, where the variable has been correctly
      2 print the qualified fields *)
      2 Print the content of a file. *)
      2 print (Tfunction (Tcons (talignas 2%N (tptr tvoid)) Tnil)
      2 printTestCase (show x' ++ newline) (pf x'))).
      2 PrintTestCase_idSize in Hgen.
      2 PrintTestCase_idSize.
      2 printTestCase "" (f nat)
      2 Print test1.
      2 print_term Σ Γ t ^ nl ^ "and:" ^ nl ^ print_term Σ Γ u ^
      2 print_term Σ Γ t ++ "\nand:\n" ++ print_term Σ Γ u ++
      2 print_term Σ Γ (tFix mfix idx) ^
      2 print_term Σ Γ (tFix mfix idx) ++
      2 print_term Σ Γ (tCoFix mfix idx) ^
      2 print_term Σ Γ t :=
      2 print_term Σ Γ2 (tProd na' A2 B2) ^
      2 print_term Σ Γ2 (tLambda na' A2 t2) ^
      2 print_term Σ Γ2 t2 ^
      2 print_term Σ Γ2 t2 ++
      2 print_term Σ Γ1 (tProd na A1 B1) ^
      2 print_term Σ Γ1 (tLambda na A1 t1) ^
      2 print_term Σ Γ1 t1 ^
      2 print_term Σ Γ1 t1 ++
      2 print_term Σ [] t
      2 print_term Γ true t ++
      2 print_term Γ true false t ^
      2 print_term Γ true false dom ++ ", " ++ print_term (vass na' dom :: Γ) true false codom)
      2 print_term Γ true false dom ++
      2 print_term Γ true false def ^ " in " ^ nl ^
      2 print_term Γ true false c ^ ")"
      2 print_term Γ true false b ++
      2 print_term Γ true dom ++ ", " ++ print_term (vass na' dom :: Γ) true codom)
      2 print_term Γ true dom ++
      2 print_term Γ true def ++ " in " ++ nl ++
      2 print_term Γ true c ++ ":"  ++ print_term Γ true t)
      2 print_term Γ true b ++
      2 print_term Γ false true f ^ " " ^ print_term Γ false false l)
      2 print_term Γ false f ++ " " ++ print_list (print_term Γ false) " " l)
      2 print_term Γ false false c ^ ".(" ^ pdecl.(proj_name) ^ ")"
      2 print_term Γ false c ++ ".(" ++ na ++ ")"
      2 print_term (Γ : context) (top : bool) (t : term) {struct t} :=
      2 print_term (vdef na' def dom :: Γ) true false body)
      2 print_term (vdef na' def dom :: Γ) true body)
      2 print_term (vass na' dom :: Γ) true false body)
      2 print_term (vass na' dom :: Γ) true body)
      2 print_term (na' :: Γ) true body)
      2 print_term (AstUtils.empty_ext p.1) [] true p.2 ++
      2 print_term (Ast.empty_ext p.1) [] true p.2 ++
      2 print_template_program (p : Ast.Env.program)
      2 print_template_program_check {cf : checker_flags} (p : Ast.program)
      2 print_template_program aq) ;;
      2 print_template_program
      2 Print tc_comparable.
      2 Print t''.
      2 print t :=
      2 Print synthesize3.
      2 Print synthesize2.
      2 Print synthesize1.
      2 Print sumor.
      2 print_sumbool_hint Pre := 
      2 print_sumbool_hint_hyp := 
      2 print_sumbool_hint_hyp
      2 print_sumbool_hint (A |-- B)
      2 Print ("Sucessfully nfolded constant " ++ cname) ;;
      2 print* style, with no frame predicate baked in. *)
      2 printString (str : string) : PrinterMonad unit :=
      2 print_string(string_of_S a);
      2 print_string(string_of_ratio1 a);
      2 print_string(string_of_ratio1 a)
      2 print_string : ocaml_string -> IO unit.
      2 print_string(List.hd l);
      2 print_string(""^List.hd l);
      2 print_string "Hello";;
      2 print_string   => "fun s k -> k (Pervasives.print_string  s)".
      2 print_string("^");
      2 print_string (
      2 Print stray.
      2 Print store_lemma. *)
      2 print_stmt_for_scope with print_stmt_for.
      2 print_stmt_for s2%print_stmt_for) (only printing, s2 at level 26, right associativity, at level 26, format "s1 ,  s2") : print_stmt_for_scope.
      2 print_stmt_for) (only printing, s2 at level 26, s1 at level 26, right associativity, at level 26, format "'[v' 'for'  ( ;  '/' ;  '/' s2 )  {  '/  ' s1 '/' } ']'") : C_scope.
      2 print_stmt_for) (only printing, s2 at level 26, s1 at level 26, right associativity, at level 26, format "'[v' 'for'  ( ;  '/' e ;  '/' s2 )  {  '/  ' s1 '/' } ']'") : C_scope.
      2 print_stmt_for e%expr s3%C s2%print_stmt_for) (only printing, s2 at level 26, s1 at level 26, right associativity, at level 26, format "'[v' 'for'  (  '/' s1 ;  '/' e ;  '/' s2 )  {  '/  ' s3 '/' } ']'") : C_scope.
      2 print_stmt` and
      2 Print Step10.
      2 print_space();
      2 print _ = Some ?x, h2 : lhs_footprint lhs = Some ?y
      2 Print solution'_b. (* Look at the start of this term! *)
      2 Prints "OK", solves the goal *)
      2 prints of permissions moved  when applicable*)
      2 prints N.c (also does with unfiltered Import M) *)
      2 prints N.c *)
      2 prints from a [sync_event] *)
      2 Print seq_rect.
      2 Print SepExpr.SepExpr.
      2 Print Scope nat_scope.
      2 prints a+M.b since the notation isn't imported *)
      2 prints: a b c *)
      2 prints. *)
      2 prints
      2 Print rose_beq.
      2 print := rf ; default := rd |} =>
      2 Print Rewrite HintDb list. *)
      2 Print reify_semax_post'. *)
      2 Print reify_prop_right. *)
      2 Print reify_now_later. *)
      2 Print reify_hlip_ind. *)
      2 Print reify_hlip_base. *)
      2 Print reify_derives_refl. *)
      2 Print reflect.
      2 Print ref.
      2 print_recursivity_kind mib.(ind_finite) ^ " " ^
      2 Print real_plus.
      2 Print q.
      2 print_pures_list (rsort (rev_cmp compare_clause2)
      2 print_program (short : bool) (prefix : nat) (p : program) : string :=
      2 print :: _print_int :: _print_intx :: _copytree :: _maketree ::
      2 Print PRF_A.
      2 Print polynomial. *)
      2 printP_mon_m coef !name_var)
      2 Print Permutation. 
      2 Print perm_of_sh.
      2 Print perm_of_res_ind.*)
      2 Print perm_of_res_cases_ind. *)
      2 Print Peano. Quit.
      2 print_pattern in hf as hpl.
      2 print-path Path pp-gref.
      2 Print paren_expr_parser.
      2 Print OracleComp.
      2 Print Options.
      2 print on the base *)
      2 Print-only variants to work around the Coq pretty-printer K-term kink. *)
      2 print_one_ind (short : bool) Γ (mib : mutual_inductive_body) (oib : one_inductive_body) : t :=
      2 print_one_cstr Γ (mib : mutual_inductive_body) (c : constructor_body) : t :=
      2 print (of_string s).
      2 print (of_string "hi")).
      2 Print Notation "y $ x".
      2 Print Notation "x = y = z".
      2 Print Notation "x <= y <= z".
      2 Print Notation "x <= y < z".
      2 Print Notation "x < y <= z".
      2 Print Notation "x < y < z".
      2 Print Notation "( x , y , .. , z )".
      2 Print Notation "x = y  :>  T".
      2 Print Notation "x <> y  :>  T".
      2 Print Notation "x || y".
      2 Print Notation "x ^ y".
      2 Print Notation "x \/ y".
      2 Print Notation "x >= y".
      2 Print Notation "x > y".
      2 Print Notation "x = y".
      2 Print Notation "x <> y".
      2 Print Notation "x <= y".
      2 Print Notation "x <-> y".
      2 Print Notation "x < y".
      2 Print Notation "x /\ y".
      2 Print Notation "x / y".
      2 Print Notation "x -> y".
      2 Print Notation "x - y".
      2 Print Notation "x + y".
      2 Print Notation "x * y".
      2 Print Notation "x && y".
      2 Print Notation "{ x | P & Q }".
      2 Print Notation "{ x & P & Q }".
      2 Print Notation "{ x | P }".
      2 Print Notation "{ x & P }".
      2 Print Notation "x mod y".
      2 Print Notation "x ''mod'' y".
      2 Print Notation "{{ x }}" in custom Foo.
      2 Print Notation "[[ x ]]" in custom Foo.
      2 Print Notation "{{ x }}" in custom Bar.
      2 Print Notation "{ x : A | P & Q }".
      2 Print Notation "{ x : A & P & Q }".
      2 Print Notation "{ x : A | P }".
      2 Print Notation "{ x : A & P }".
      2 Print Notation "x$y".
      2 Print Notation "~ x".
      2 Print Notation "{ x }".
      2 Print Notation "/ x".
      2 Print Notation "- x".
      2 Print Notation "{ ' pat | P & Q }".
      2 Print Notation "{ ' pat & P & Q }".
      2 Print Notation "{ ' pat | P }".
      2 Print Notation "{ ' pat & P }".
      2 Print Notation "{ ' pat : A | P & Q }".
      2 Print Notation "{ ' pat : A & P & Q }".
      2 Print Notation "{ ' pat : A | P }".
      2 Print Notation "{ ' pat : A & P }".
      2 Print Notation "_ 'mod' _". (* FIXME I expected this to work *)
      2 Print Notation "_ mod _".
      2 Print Notation "_ 'mod' _".
      2 Print Notation "_ ''mod'' _".
      2 Print Notation "{{ _ }}" in custom Foo.
      2 Print Notation "[[ _ ]]" in custom Foo.
      2 Print Notation "{{ _ }}" in custom Bar.
      2 Print Notation "if _ is _ then _ else _".
      2 Print Notation "'if' c 'is' p 'then' u 'else' v".
      2 Print Notation "exists x .. y , p".
      2 Print Notation "'exists' x .. y , p".
      2 Print Notation "exists _ _ , _".
      2 Print Notation "exists _ .. _ , _".
      2 Print Notation "exists _ , _".
      2 Print Notation "A  +  { B }".
      2 Print Notation "{ A }  +  { B }".
      2 Print Notation "$ x".
      2 Print Notation "_ $ x".
      2 Print Notation "_$_".
      2 Print Notation "_ $".
      2 Print Notation "_ $ _".
      2 Print Notation "~ _".
      2 Print Notation "{ _ }".
      2 Print Notation "{ _ }  +  { _ }".
      2 Print Notation "{ _ | _ }".
      2 Print Notation "{ _ | _ & _ }".
      2 Print Notation "{ _ : _ | _ }".
      2 Print Notation "{ _ : _ | _ & _ }".
      2 Print Notation "{ _ : _ & _ }".
      2 Print Notation "{ _ : _ & _ & _ }".
      2 Print Notation "{ _ & _ }".
      2 Print Notation "{ _ & _ & _ }".
      2 Print Notation "{ ' _ | _ }".
      2 Print Notation "{ ' _ | _ & _ }".
      2 Print Notation "{ ' _ : _ | _ }".
      2 Print Notation "{ ' _ : _ | _ & _ }".
      2 Print Notation "{ ' _ : _ & _ }".
      2 Print Notation "{ ' _ : _ & _ & _ }".
      2 Print Notation "{ ' _ & _ }".
      2 Print Notation "{ ' _ & _ & _ }".
      2 Print Notation "_ || _".
      2 Print Notation "_ ^ _".
      2 Print Notation "_ \/ _".
      2 Print Notation "_ >= _".
      2 Print Notation "_ > _".
      2 Print Notation "_ = _".
      2 Print Notation "_ = _ = _".
      2 Print Notation "_ = _  :> _".
      2 Print Notation "_ <> _".
      2 Print Notation "_ <> _  :> _".
      2 Print Notation "_ <= _".
      2 Print Notation "_ <= _ <= _".
      2 Print Notation "_ <= _ < _".
      2 Print Notation "_ <-> _".
      2 Print Notation "_ < _".
      2 Print Notation "_ < _ <= _".
      2 Print Notation "_ < _ < _".
      2 Print Notation "_ /\ _".
      2 Print Notation "_ / _".
      2 Print Notation "_ -> _".
      2 Print Notation "_ - _".
      2 Print Notation "_ + _".
      2 Print Notation "_ * _".
      2 Print Notation "_ && _".
      2 Print Notation "_  +  { _ }".
      2 Print Notation "/ _".
      2 Print Notation "- _".
      2 Print Notation "( _ , _ , .. , _ )".
      2 Print Notatation doesn't work with custom notations *)
      2 Print nota.
      2 Print "'nonexistent'".
      2 print := nil
      2 print_nf ("toto5 " ++ id) ;;
      2 print_nf ("toto4 " ++ id) ;;
      2 print_nf ("toto2 " ++ id) ;;
      2 print_nf ("toto1" ++ id) ;;
      2 print_nf (string_of_kername kn ^ " was already translated") ;; ret ΣE
      2 print_nf (string_of_kername kn ++ " was already translated") ;; ret ΣE
      2 print_nf (kn ++ " was already translated") ;; ret ΣE
      2 print_nf (id ++ "is an axiom, not a definition") ;;
      2 print_nf).
      2 print_newline : IO unit.
      2 print_newline  => "fun   k -> k (Pervasives.print_newline ())".
      2 print_newline;;
      2 print_newline
      2 print_nat n;; print_newline;;
      2 print_nat : nat -> IO unit :=
      2 Print Nat.ltb.
      2 Print Nat.leb.  (* The computation to compare natural numbers. *)
      2 print_nat j;; print_newline;;
      2 print_nat i;; print_newline;;
      2 Print Nans.
      2 Print nans.
      2 print_name x.(dname) ++ " { " ++ "struct " ++ nat_to_string x.(rarg) ++ "} " ++
      2 print_name nm : string :=
      2 print_name na) ++ "," ++ print_extracted_term t (na :: names) true ++ ")"
      2 print_name na) ++ ":=" ++ print_extracted_term b names true ++ " in " ++ newline ++
      2 print_name (na : name) : string :=
      2 Print name and type for all evars*)
      2 Print MutualR1.
      2 Print MutualR1'.
      2 Print MutualI2'.
      2 Print MutualI1.
      2 PrintMults.
      2 Print mult_n_Sm.
      2 Print mt4.
      2 Print mt4'.
      2 Print mt3.
      2 Print mt2.
      2 Print mt1.
      2 Print msubst_efield_denote_nil_lemma. *)
      2 Print msubst_efield_denote_cons_array_lemma. *)
      2 Print MonadStateLaws.
      2 Print Module Type F.
      2 Print Module SeparationLogicSoundness.VericSound.
      2 Print microban_2.
      2 Print microban_1_solution.
      2 Print M.g.
      2 print (Message.of_string "Yay"); fail
      2 print (Message.of_string msg)
      2 print (Message.of_string "I won't be printed")
      2 print (Message.of_string "hi") in 42.
      2 print (Message.of_string "hello ");
      2 print (Message.of_string "foo")).
      2 print (Message.of_string "failed")).
      2 print (Message.of_string "Err")
      2 print (Message.of_string "C " ++ Message.of_constr c)
      2 print (Message.of_string "B " ++ msg_of_bool b)
      2 print (Message.of_string "A")
      2 print (Message.of_int (k Not_found))
      2 print (Message.of_ident @UU).
      2 print (Message.of_ident @T).
      2 print (Message.of_ident @H).
      2 print (Message.of_ident @f).
      2 print (Message.of_exn e)).
      2 print (Message.of_constr t).
      2 print (Message.of_constr (qux3 ident:(x)))).
      2 print (Message.of_constr (goal ()))).
      2 print (Message.of_constr c); b.(contents) := false; fail
      2 print (Message.of_constr c). (* 9 secs *) *)
      2 print (Message.of_constr c). (* 6 secs *)
      2 print (Message.of_constr c). (* 32 secs *) *)
      2 print (Message.of_constr c). (* 22 secs *) *)
      2 print (Message.of_constr c). (* <1 secs *) *)
      2 print (Message.of_constr c). (* 1.6 secs *) *)
      2 print (Message.of_constr c)
      2 print (Message.of_constr b) end.
      2 print (Message.concat (Message.of_string "Test Error: ") msg)
      2 print (Message.concat (Message.of_string "bar") (literal s "%s")).
      2 print (Message.concat (Message.of_int n) (Message.of_string ": "));
      2 print_match_lhs in hl as ft. 2: auto.
      2 Print m.
      2 Print Ltac t4.
      2 Print Ltac t3.
      2 Print Ltac t2.
      2 Print Ltac t1.
      2 Print Ltac prog_swap_r. *)
      2 Print Ltac k5.
      2 Print Ltac k4.
      2 Print Ltac k3.
      2 Print Ltac k2.
      2 Print Ltac k1.
      2 Print Ltac FE.withstrategy.
      2 Print Ltac2 Type thing.
      2 Print Ltac2 Type option.
      2 Print Ltac2 Type bool.
      2 Print Ltac2 tuple0.
      2 Print Ltac2 Triple.
      2 Print Ltac2 test3.
      2 Print Ltac2 test1.
      2 Print Ltac2 test0.
      2 Print Ltac2 Some.
      2 Print Ltac2 Signatures.
      2 Print Ltac2 refine.
      2 Print Ltac2 qux3.
      2 Print Ltac2 qux2.
      2 Print Ltac2 qux1.
      2 Print Ltac2 qux0.
      2 Print Ltac2 qux.
      2 Print Ltac2 Out_of_bounds.
      2 Print Ltac2 numgoals.
      2 Print Ltac2 Not_found.
      2 Print Ltac2 None.
      2 Print Ltac2 message_of_nat.
      2 Print Ltac2 list_length.
      2 Print Ltac2 Inr.
      2 Print Ltac2 Inl.
      2 Print Ltac2 ifb.
      2 Print Ltac2 get_hyp_by_name.
      2 Print Ltac2 foo0.
      2 Print Ltac2 foo.
      2 Print Ltac2 foo'.
      2 Print Ltac2 exact.
      2 Print Ltac2 do.
      2 Print Ltac2 bar.
      2 Print Ltac2 bang.
      2 Print Ltac *)
      2 print_lset levels)));;
      2 print_lset levels ^
      2 print_lset levels ++
      2 print_list_with_lines l lines :=
      2 print_list_with_lines ((1,1)::(2,3)::(4,5)::nil) (3::nil).
      2 print_list string_of_level " " u ++ "}"
      2 print_list (print_one_cstr Γpars mib) nl oib.(ind_ctors).
      2 print_list (print_def (print_term Γ true) (print_term (ctx' ++ Γ)%list true)) (nl ++ " with ") defs.
      2 print_list (print_def (print_term Γ true false) (print_term (ctx' ++ Γ)%list true false)) (nl ++ " with ") defs.
      2 print_list (print_def (print_term (ctx' ++ Γ)%list true false)) (nl ++ " with ") defs.
      2 Print List_pop.
      2 printlist (map fst l))                                  
      2 printlist (l:list ident):string := List.fold_right (fun p s => String (Coq.Strings.Ascii.ascii_of_pos p) s) EmptyString l.
      2 print [list (atom * typ)] as [env], and we can use [env] as a
      2 print_list ((1,1)::(2,3)::(4,5)::nil).
      2 print_linear in hf as hll.
      2 print := lf ; default := ld |} ,
      2 Print length_is_2.
      2 Print length_and_sum.
      2 Print length_and_sum'.
      2 Print length_and_sum''.
      2 Print length_1_2.
      2 Print leb.
      2 Print lc_abs. *)
      2 Print ("lambda " ++ n)  ;;
      2 print (l ++ [ a ]) =
      2 print k (rev rs1)) (pprint k rs2) -> 
      2 Print Keywords.
      2 Print join_hom_comparable.
      2 Print JMeq_J.*)
      2 Print J.
      2 print it easily *)
      2 Print it.
      2 Print isUnOpResultType.
      2 Print isBinOpResultType.
      2 print_intx, Gfun(Internal f_print_intx)) ::
      2 print_intx := {|
      2 print_int (Tfunction (Tcons tuint Tnil) tvoid cc_default))
      2 print_int (Tfunction
      2 print_intr_spec; print_int_spec; getchar_blocking_spec; putchar_blocking_spec; main_spec]).
      2 print_intr : ident := 47%positive.
      2 print_intr : ident := 45%positive.
      2 print_int :: _print_intr :: _putchars :: _getchars :: _malloc ::
      2 print_int :: _print_intr :: _putchar_blocking ::
      2 print_int_list a :=
      2 print_int (int_of_nat n).
      2 print_int : int -> IO unit.
      2 print_int int_constant;; print_newline;;
      2 print_int int_constant;;
      2 print_int : ident := 48%positive.
      2 print_int : ident := 46%positive.
      2 print_int      => "fun n k -> k (Pervasives.print_int     n)".
      2 print_int_array a :=
      2 Print_instances Eqb.
      2 Print Instances A.
      2 Print insec2.
      2 print input bounds; they're not relevant *) e
      2 printing width so that arguments are printed on 1 line.
      2 Printing Width 999999.
      2 Printing Width 80.
      2 Printing Width 60.
      2 Printing Width 500.
      2 Printing Width 300.
      2 Printing warnings ***)
      2 Printing user inputs ***)
      2 Printing Universes. *)
      2 Printing Universes. 
      2 printing, ty at level 12, a1 at level 12, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 12, format "'[hv  ' ( ty )  a1 ']'") : expr_scope.
      2 printing, ty at level 11, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' 'sizeof(' ty ) ']'") : expr_scope.
      2 printing, ty at level 11, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' '__alignof__(' ty ) ']'") : expr_scope.
      2 Printing terms in exceptions for debugging purposes **)
      2 Printing terms ***)
      2 Printing Sort Qualities.
      2 printing, s2 at level 27, right associativity, at level 27, format "s1  '//' s2") : C_scope.
      2 printing, s2 at level 26, right associativity, at level 26, format "'[v' 'if'  (!  e_val )  {  '/  ' s2 '/' } ']'") : C_scope.
      2 printing, s1 at level 26, s2 at level 26, right associativity, at level 26, format "'[v' 'if'  ( e_val )  {  '/  ' s1 '/' }  'else'  {  '/  ' s2 '/' } ']'") : C_scope.
      2 printing, s1 at level 26, right associativity, at level 26, format "'[v' 'if'  ( e_val )  {  '/  ' s1 '/' } ']'") : C_scope.
      2 printing, s1 at level 26, right associativity, at level 26, format "'[v' 'for'  ( ; ; )  {  '/  ' s1 '/' } ']'") : C_scope.
      2 printing, s1 at level 26, left associativity, at level 26, format "'[v' 'while'  ( e_val )  {  '/  ' s1 '/' } ']'") : C_scope.
      2 printing, right associativity, at level 3, format "a b").
      2 printing, right associativity, at level 3, format "").
      2 printing, right associativity, at level 26, s_val at level 27, format "({  s_val  })") : print_stmt_for_scope.
      2 printing, right associativity, at level 26, format "'return'  e_val ;") : C_scope.
      2 Printing Raw Literals.
      2 printing purposes *)
      2 printing paths for applied terms *)
      2 printing, only printing).
      2 printing of type *)
      2 printing of the assembly
      2 printing of results. *)
      2 printing of if-then-else statements (though we
      2 printing notation *)
      2 printing, no associativity, at level 10, format "'[hv  ' n_val 'U' ']'") : expr_scope.
      2 printing, no associativity, at level 10, format "'[hv  ' n_val 'LLU' ']'") : expr_scope.
      2 printing, no associativity, at level 10, format "'[hv  ' n_val 'LL' ']'") : expr_scope.
      2 printing, no associativity, at level 10, format "'[hv  ' f_val 'f' ']'") : expr_scope.
      2 Printing messages ***)
      2 printing match, not just about Match All Subterms *)
      2 Printing Match All Subterms.
      2 printing, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 10, format "'[hv  ' a1 . f_val ']'") : expr_scope.
      2 printing, left associativity, at level 26, format "p_val [ i_val ]") : expr_scope.
      2 printing, left associativity, at level 26, format "") : print_cases_scope.
      2 printing, lbl at level 26, right associativity, at level 26, format "'goto'  lbl ;") : C_scope.
      2 printing, lbl at level 26, left associativity, at level 26, format "'case'  lbl") : print_case_label_scope.
      2 printing is easy though, relying on pattern-matching compaction *)
      2 printing functions are mostly for debugging below test cases *)
      2 printing, format "/*skip*/;", at level 10) : C_scope.
      2 printing, format "s2", at level 10) : C_scope.
      2 printing, format "s1", at level 10) : C_scope.
      2 printing, format "return;", at level 10) : C_scope.
      2 printing, format "/*nothing*/", at level 10) : print_stmt_for_scope.
      2 printing, format "id  =  e2", at level 70) : print_stmt_for_scope.
      2 printing, format "'[hv  ' n_val ']'", at level 10) : expr_scope.
      2 printing, format "'[hv  ' f_val ']'", at level 10) : expr_scope.
      2 printing, format "'[hv  ' ~ a1 ']'", at level 75, right associativity) : expr_scope.
      2 printing, format "'[hv  ' - a1 ']'", at level 35, right associativity) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' >=  a2 ']'", at level 70) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' >  a2 ']'", at level 70) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' <=  a2 ']'", at level 70) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' <  a2 ']'", at level 70) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' -  a2 ']'", at level 50, left associativity) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' +  a2 ']'", at level 50, left associativity) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' /  a2 ']'", at level 40, left associativity) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' *  a2 ']'", at level 40, left associativity) : expr_scope.
      2 printing, format "'[hv  ' a1  '/' ^  a2 ']'", at level 30, right associativity) : expr_scope.
      2 printing, format "e1  =  e2", at level 70) : print_stmt_for_scope.
      2 printing, format "'default'", at level 10) : print_case_label_scope.
      2 printing, format "continue;", at level 10) : C_scope.
      2 printing, format "break;", at level 10) : C_scope.
      2 PrintingFixedWithoutContinuations.
      2 PrintingFixed.
      2 printing" EPretty.print_program p'.
      2 printing, e2 at level 26, right associativity, at level 26, format "'[hv  ' id  =  '/' e2 ; ']'") : C_scope.
      2 printing, e2 at level 26, right associativity, at level 26, format "'[hv  ' e1  =  '/' e2 ; ']'") : C_scope.
      2 printing). (* double quote *)
      2 Printing Depth 500.
      2 Printing Depth 200. *)
      2 Printing Depth 200.
      2 Printing Depth 20.
      2 Printing Depth 100000000.
      2 Printing Depth 10000000.
      2 printing check in passing *)
      2 printing boxes that print the type of a long definition on a
      2 printing because no rule to print "a:nat" and "b:nat" *)
      2 printing, at level 26, x at level 24, y at level 24) : print_expr_list_true_scope.
      2 printing, at level 10) : int_repr_scope.
      2 printing, at level 10) : int64_repr_scope.
      2 printing, at level 10, format "'Ox' a").
      2 printing, at level 10). *)
      2 printing an inductive from a bound module in an error from the
      2 Printing All. Set Printing Universes. *)
      2 Printing All. intros. rewrite sepcon_emp in H; auto.
      2 printing, a2 at level 19, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 20, format "'[hv  ' a1  '/' |  a2 ']'") : expr_scope.
      2 printing, a2 at level 17, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 18, format "'[hv  ' a1  '/' &  a2 ']'") : expr_scope.
      2 printing, a2 at level 16, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 17, format "'[hv  ' a1  '/' ==  a2 ']'") : expr_scope.
      2 printing, a2 at level 16, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 17, format "'[hv  ' a1  '/' !=  a2 ']'") : expr_scope.
      2 printing, a2 at level 14, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 15, format "'[hv  ' a1  '/' >>  a2 ']'") : expr_scope.
      2 printing, a2 at level 14, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 15, format "'[hv  ' a1  '/' <<  a2 ']'") : expr_scope.
      2 printing, a2 at level 12, left associativity (* XXX Is LtoR the same as left associativity in Coq? *), at level 13, format "'[hv  ' a1  '/' %  a2 ']'") : expr_scope.
      2 printing, a1 at level 24, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' '__builtin_fabs(' a1 ) ']'") : expr_scope.
      2 printing, a1 at level 11, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' '__builtin_fabs' a1 ']'") : expr_scope.
      2 printing, a1 at level 11, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' * a1 ']'") : expr_scope.
      2 printing, a1 at level 11, right associativity (* XXX Is RtoL the same as right associativity in Coq? *), at level 11, format "'[hv  ' & a1 ']'") : expr_scope.
      2 printing.
      2 printing).  *)
      2 PrintInfos") *)
      2 Print Info.normalized and make sure it has the value 'true'"
      2 print_inferred_list (filter not_taut (map (simplify l)
      2 printInductive (q : qualid): TemplateMonad unit :=
      2 print_inductive i ++ ":" ++ (nat_to_string n) ++ ") "
      2 print_inductive (i:inductive) : string :=
      2 print [i < j], not [l < k] (and not prelude universes) *)
      2 print_if true "hello %s" "friend")).
      2 print_if true "%a" (fun _ => Control.throw Assertion_failure) ().
      2 print_if false "hello %s" "friend")).
      2 print_if false "%a" (fun _ => Control.throw Assertion_failure) ().
      2 print_if" b(tactic(0)) fmt(format) := print_if b fmt.
      2 print_if b fmt :=
      2 print_ids ids; *)
      2 print_identity:
      2 print.iacr.org/2015/677.pdf>
      2 print.iacr.org/2008/522.pdf>). *)
      2 print.iacr.org/2008/013.pdf>
      2 Print hmac256drbgstate. cancel. simpl.
      2 print_hint_semax D Pre c Post :=
      2 print_hint_semax D Pre c Post
      2 print_hint_locals D L
      2 print_hint_locals Delta LR
      2 print_hint_locals Delta L :=
      2 print_hint_local Delta L1; 
      2 print_hint_local Delta L :=
      2 print_hint_forward c1
      2 print_hint_forward c;
      2 print_hint_forward c :=
      2 Print HintDb seclocaldb.
      2 print hex value, no cast *) HexString.of_Z v
      2 Print "Here we can get the term"
      2 print_grid rs
      2 Print Graph`) we have `[pointed_type] : pType ↣ Sortclass (reversible)`
      2 Print Grammar fix_decls.
      2 Print Grammar constr univ_annot.
      2 print_goal:= match goal with [|- ?G] => idtac G end.
      2 PrintGoal
      2 print_goal;
      2 print, Gfun(Internal f_print)) :: (_main, Gfun(Internal f_main)) :: nil).
      2 Print genv.
      2 printf "Unrecognized under case %t (from %t from %t)" f branch tag))
      2 printf "Unrecognized kind under case %t (from %t)" branch tag))
      2 printf "Unhandled type %t" t))
      2 printf "Unhandled result %t (on %t : %t with %s)" result spec specTy red))
      2 printf "Unhandled base spec %t" ty) k)
      2 printf "Unhandled base spec app %t" ty))
      2 printf tt (write_list stdout (string2bytes "This is line 2.
      2 printf "%t" term;
      2 printf (Tfunction (Tcons (tptr tschar) Tnil)
      2 printf "%t" "foo".
      2 printf "%t" '(1 + 1 = 0)).
      2 printf_spec_sub:
      2 printf_specs prog) ++ [ main_spec ])(*)*).
      2 printf_specs' defs'
      2 printf "%s=%i" s i) m in
      2 printf "%s failed to fully reduce, leaving over %t (expected: %t), in %t %t" red x y spec specTy)
      2 printf "%s failed to fully reduce, leaving over %t (expected something equivalent to: %t), in %t %t" red lhs rhs spec specTy)
      2 printf "%s failed!%sGot: %t%sExpected: %t%sIn %t %t" red (lf ()) x (lf ()) y (lf ()) spec specTy)
      2 printf "%s failed!%sGot: %t%sExpected something equivalent to: %t%s(both sides %s unify)%sIn %t %t" red (lf ()) lhs (lf ()) rhs (lf ()) descr (lf ()) spec specTy)
      2 printf "%s" "abc").
      2 printf "%s" 0.
      2 printf "Results must be a literal list, not %t" results))
      2 print (fprintf "%I foo%a bar %s" @ok dummy 18 "yes").
      2 printf outp ((Ers, string2bytes "line", gv ___stringlit_2), (Int.repr 2, tt)) (stdout, Ret tt : @IO_itree (@IO_event file_id)).
      2 Print four_plus_three.
      2 Print four_plus_three'.
      2 Print Forall_cons.
      2 Print Forall.
      2 Print Foo.x.
      2 Print foo@{u u IMPORTANT}.
      2 Print foo_obligation_1.
      2 Print foo. (* must not print Type@{i} -> Type@{i} *)
      2 Print Fold.
      2 printf Message.to_string (Message.of_string "") fmt.
      2 printf Message.to_string fmt
      2 print_first_match in e0 as hf. 2: auto.
      2 printf "Invalid result format %t" v))
      2 printFin.
      2 printf "Impossible! Result branch mismatch %t" result))
      2 printf "%I foo%a bar %s" @ok dummy 18 "yes").
      2 printf "%I" @Foo).
      2 printf "%I" "foo".
      2 printf "%i" "foo".
      2 printf : ident := 154%positive.
      2 printf : ident := 153%positive.
      2 printf : ident := 113%positive.
      2 printf "%i" 42).
      2 printf :: _fprintf :: ___getreent :: ___builtin_debug ::
      2 printf" fmt(format) := Message.Format.kfprintf (fun m => Message.to_string m) fmt.
      2 printf doesn't run the closure *)
      2 print := f ; default := d |} =>
      2 printf debugging"
      2 Print F. (* Cannot mask the absolute name "M3.t"! *)
      2 printf.c".
      2 Print False.
      2 printf "%a" (fun _ i => Message.of_int i) "foo".
      2 printf "%a" (fun _ _ => ()).
      2 printf "%a" dummy 18).
      2 printf "%%").
      2 print_extracted_term x.(dbody) names true
      2 print_extracted_term (t:term) (names : list name) (inapp : bool) : string :=
      2 print_extracted_term t (na :: names) true ++ ")"
      2 print_extracted_term (snd x) names true ++ newline ++ aux xs
      2 print_extracted_term mch names true) ++ " in " ++ print_inductive (fst n) ++ "," ++ (nat_to_string (snd n)) ++ " with " ++ newline ++
      2 print_extracted_term fn names true) ++ " " ++ print_extracted_term arg names false ++ ") "
      2 print_extracted_term fn names true ++ " " ++ print_extracted_term arg names false
      2 print_extracted_term c names false ++ ".(" ++ nat_to_string n ++ ")"
      2 print_extracted_term b nil true
      2 print_expr_list_true_scope with print_expr_list_true.
      2 print_expr_list_true) (only printing, el at level 26, right associativity, at level 26, format "'[hv  ' e1 '/' ( el ) ']'") : print_stmt_for_scope.
      2 print_expr_list_true) (only printing, el at level 26, right associativity, at level 26, format "'[hv  ' e1 '/' ( el ); ']'") : C_scope.
      2 print_expr_list_true) (only printing, ef at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' id  =  '/' 'builtin'  ef '/' ( el ) ']'") : print_stmt_for_scope.
      2 print_expr_list_true) (only printing, ef at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' id  =  '/' 'builtin'  ef '/' ( el ); ']'") : C_scope.
      2 print_expr_list_true) (only printing, ef at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' 'builtin'  ef '/' ( el ) ']'") : print_stmt_for_scope.
      2 print_expr_list_true) (only printing, ef at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' 'builtin'  ef '/' ( el ); ']'") : C_scope.
      2 print_expr_list_true) (only printing, e1 at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' id  =  '/' e1 '/' ( el ) ']'") : print_stmt_for_scope.
      2 print_expr_list_true) (only printing, e1 at level 26, el at level 26, right associativity, at level 26, format "'[hv  ' id  =  '/' e1 '/' ( el ); ']'") : C_scope.
      2 Print expr.
      2 Print eval_expr.
      2 Print ev_4.
      2 printer (x : float_wrapper) : Number.uint :=
      2 Printer {T : Type} (c : PrinterMonad T) : T * string :=
      2 Printers.Nat.
      2 Print Err.
      2 printer not called on list nat *)
      2 PrinterMonad : Type -> Type :=
      2 Printer (Monad.bind (printString "hello "%string) (fun _ => print 2)).
      2 Printer (Monad.bind (print "hello "%string) (fun _ => print 2)).
      2 Printer (Monad.bind (print 1) (fun _ => print 2)).
      2 PrinterHelpers.
      2 printer doesn't anomaly *)
      2 printer called, but type incorrect *)
      2 printer2 (x : nunit 2) : Number.uint :=
      2 printer2 : nat_scope.
      2 Print eqT_rect.
      2 print eqn:e4.
      2 print_eq in hf as fe.
      2 Print environ.
      2 print_env_aux short n Σ'.1
      2 print_env)).
      2 print_endline " world!";;
      2 print_endline (Pervasives.string_of_bool b))".
      2 print_endline : ocaml_string -> IO unit.
      2 print_endline "Hello";;
      2 print_endline  => "fun s k -> k (Pervasives.print_endline s)".
      2 Print empty.
      2 Print elpi_subproof.
      2 printed with -vos since without "Proof." there's no Proof
      2 printed with -vos because there's no annotation (either [Set
      2 printed with Bitvec from #8890 in 8.10 and 8.11, regression due to #11172 in 8.12 *)
      2 printed vertically (see
      2 printed using a sid *)
      2 printed the same from #8890, in 8.10 *)
      2 printed the same from #11172, in 8.12 *)
      2 printed the same except in 8.10 *)
      2 printed the same *)
      2 print_edge '(l1, n, l2)
      2 print_edge edges.
      2 printed "a !", without making explicit the "0", which is
      2 printed ASM assembly code, this allocation is:
      2 printed. *)
      2 printed")))
      2 print; eauto.
      2 Print DRBG_functions.DRBG_state_handle. destruct J as [[[[VAL KEY] RCC] SecStr] PRflag]. subst h; simpl.
      2 Print dotprodR.
      2 Print D.iter'.
      2 print_disjoint : forall p a b c d,
      2 Print denote_tc_assert.
      2 print_defs (print_term : context -> bool -> term -> string) Γ (defs : mfixpoint term) :=
      2 print_def (extract : option E.program) c :=
      2 print_def extract_fix "Coq.Init.Wf.Fix_F".
      2 print_def extract_copy "Coq.Init.Logic.and_rect".
      2 print_def extract_admitcopy "Top.unprovedCopy_terminate".
      2 print_def {A : Set} (f : A -> string) (def : def A) :=
      2 print_def {A} (f : A -> t) (g : A -> t) (def : def A) :=
      2 print_def {A} (f : A -> string) (g : A -> string) (def : def A) :=
      2 Print Datatypes.length.
      2 print_cut();
      2 Print Custom Grammar myconstr.
      2 Print Custom Grammar foo2.
      2 Print Custom Grammar expr.
      2 Print ctx;;
      2 print csafe for more info)*)
      2 Print CoveringSpace.
      2 Print counterexample.
      2 print_context Σ [] Γ
      2 print_context Γpars oib.(ind_indices) in
      2 print_context Γ mib.(ind_params) in
      2 print_context Γ c.(cstr_args) in
      2 PrintContext
      2 print_constraint_type d ++ " " ++ string_of_level l2)
      2 print_constraint_set (constraints_of_udecl udecl))));;
      2 print_constraints, coq.say "Currently Y =" Y,
      2 printConstant "six" true).
      2 printConstant "six" false).
      2 printConstant (q : qualid) b : TemplateMonad unit :=
      2 printConstant "nat" false).
      2 printConstant' (name  : qualid): TemplateMonad unit :=
      2 printConstant' "Coq.Arith.PeanoNat.Nat.add").
      2 printConstant "add" false).
      2 print_closedn_eq _) as hc.
      2 print_closedn_eq :
      2 PrintClight.ml` and `cfrontend/PrintCsyntax.ml`, and 
      2 Print ChoosableFromInterval. 
      2 print_char     => "fun c k -> k (Pervasives.print_char    c)".
      2 print_char (char_of_ascii "a");; print_newline;;
      2 print_char : char -> IO unit.
      2 Print chain.
      2 print_cases_scope with print_cases.
      2 print_cases) (only printing, cases at level 26, right associativity, at level 26, format "'[v' 'switch'  ( e_val )  {  '/  ' cases '/' } ']'") : C_scope.
      2 print_cases`, but it can be made to handle others) to Coq notations. 
      2 print_case_label s_val%C rem%print_cases) (only printing, rem at level 26, right associativity, at level 26, format "'[v  ' lbl :  '/' s_val ']'  '/' rem") : print_cases_scope.
      2 print_case_label_scope with print_case_label.
      2 Print Canonical Projections sum.
      2 Print Canonical Projections sort_TYPE bool.
      2 Print Canonical Projections sort_TYPE.
      2 Print Canonical Projections sort_eq.
      2 Print Canonical Projections prod.
      2 Print Canonical Projections nat.
      2 Print Canonical Projections bool_eqType.
      2 Print Canonical Projections bool.
      2 Print c;;
      2 print_bytes    => "fun b k -> k (Pervasives.print_bytes   b)".
      2 print_bytes : bytes -> IO unit.
      2 Print byte_rect.
      2 Print byte_rec.
      2 Print byte_ind.
      2 print) brs).
      2 print_branch (vass na' :: Γ) n B
      2 print_bool true ;;
      2 print_bool false;;
      2 print_bool : bool -> IO unit.
      2 print_bool_array a :=
      2 print_bool =>
      2 Print bobmorane.
      2 Print binary_float.
      2 Print Binary.binary_float.
      2 Print bd
      2 Print baz_obligation_1.
      2 print_base_systems b ++ " integer")%string)
      2 Print (baseName : String.string) : TM unit :=
      2 Print bar_obligation_1.
      2 print a term that contains an existential variable. *)
      2 print_atend_eq in e0.
      2 Print Ast.mfixpoint.
      2 Print Ast.def.
      2 PrintAssumptionsVOK Require file1.
      2 Print Assumptions used empty instances on polymorphic inductives *)
      2 Print Assumptions UIP.
      2 Print Assumptions Traversal_is_finite_container.
      2 Print Assumptions the_loop. *)
      2 Print Assumptions sUnit.
      2 Print Assumptions squashed_eq.
      2 Print Assumptions seq_rect.
      2 Print Assumptions really_bad. TODO *)
      2 Print Assumptions prov_equiv_models.
      2 Print Assumptions provedCopy.
      2 Print Assumptions pred1_diamond. *)
      2 Print Assumptions minimal_parse_nonterminal__of__parse.
      2 Print Assumptions M.f.
      2 Print Assumptions main. (* this fails *)
      2 Print Assumptions loop. *)
      2 Print Assumptions lem4.
      2 Print Assumptions it.
      2 Print Assumptions infer.
      2 Print Assumptions HMAC_PRF.
      2 Print Assumptions HMAC256_isPRF'.
      2 Print Assumptions foo.
      2 Print Assumptions f.
      2 Print Assumptions erases_erase.
      2 Print Assumptions Cut_elimination.
      2 Print Assumptions corollary.  *)
      2 Print Assumptions Cor.
      2 Print Assumptions Box.
      2 Print Assumptions body_aes_encrypt.
      2 Print Assumptions blo.
      2 Print Assumptions bla.
      2 Print Assumptions bind_law.
      2 Print Assumptions BarebonesSound.check_entailment_sound.*)
      2 Print Assumptions bar.
      2 Print Assumptions bad.
      2 Print Assumptions att_T.
      2 Print Assumptions att_f'.
      2 Print Assumptions att_Cor.
      2 Print Assumptions addition_totally_correct.
      2 PrintAsm.ml]
      2 Print as metacoq.templatemonad.type.tmPrint.
      2 Print as metacoq.templatemonad.prop.tmPrint.
      2 print as 2, because (S O + S O) is not syntactically equal
      2 print, and anyway doesn't care about throwing away
      2 Print all_tokens_residual_error_m1_concrete.
      2 print_all_ages.
      2 Print ADT. *)
      2 Print add_syntax.
      2 Print Abs.
      2 print 5 and then return 6. This would be
      2 print3 (of_int i) (of_string "=") (of_bool x)) a.
      2 print3 m1 m2 m3 := print2 m1 (Message.concat m2 m3).
      2 print2 m1 m2 := print (Message.concat m1 m2).
      2 print0. auto.
      2 Print "<>".
      2 print('')
      2 print := {|
      2 print :=
      2 inspect (unfold_one_case (Γ ,,, stack_context π) ind par p c brs _) := {
      2 Inspect this proof goal.  If you think it is solvable WITHOUT
      2 inspect their proof terms.  In other words, [cofix]
      2 inspect their proofs and thus fails.  This is a
      2 inspect (@reduce_to_prod _ Σ HΣ Γ T _) => {
      2 inspect (@reduce_to_prod' Γ T _) => {
      2 inspect (reduce_to_prod _ _ _)) eqn:hi'.
      2 inspect (reduce_to_ind Γ (infer Γ wfΓ c _) _) :=
      2 inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π2) c' _) := {
      2 inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π1) c _) := {
      2 inspect (reduce_term RedFlags.default _ X (Γ ,,, stack_context π2) c' _) := {
      2 inspect (reduce_term RedFlags.default _ X (Γ ,,, stack_context π1) c _) := {
      2 inspect (reduce_stack RedFlags.nodelta _ X (Γ ,,, stack_context θ') fn (appstack l' []) _) := {
      2 inspect (reduce_stack RedFlags.nodelta _ X
      2 inspect (reduce_stack RedFlags.default Σ hΣ (Γ ,,, stack_context θ) c ε _) := {
      2 inspect (reduce_stack RedFlags.default _ X Γ c [] _) := {
      2 inspect (reduce_stack nodelta_flags Σ hΣ (Γ ,,, stack_context ρ2) rt2 (appstack l2 ε) _) := {
      2 inspect (reduce_stack nodelta_flags Σ hΣ (Γ ,,, stack_context ρ1) rt1 (appstack l1 ε) _) := {
      2 inspect (reduce_stack nodelta_flags Σ hΣ (Γ ,,, stack_context π2) t2 (appstack args2 ε) _) := {
      2 inspect (reduce_stack nodelta_flags Σ hΣ (Γ ,,, stack_context π1) t1 (appstack args1 ε) _) := {
      2 inspect (reduce c (Proj (i, pars, narg) π) _) := {
      2 inspect (reduce c (Fix mfix idx args ρ) _) := {
      2 inspect (reduce c (Case (ind, par) p brs π) _) := {
      2 inspect (nth_error mfix n) := {
      2 inspect (nth_error mfix n) :=
      2 inspect (lookup_ind_decl _ X' ind)).
      2 inspect (lookup_ind_decl ind) :=
      2 inspect (lookup_env Σ c') := {
      2 inspect (lookup_env (fst Σ) c) := {
      2 inspect leq := {
      2 inspect it; and in general, avoid 'simpl in *'"
      2 inspection. We will use QuickChick to find out what is wrong.
      2 inspect; intros opt e''.
      2 inspecting [teq two zwei] and extracting [teq one
      2 inspect (hnf Γ t h) :=
      2 inspect (eqb u.(rarg) v.(rarg)) := {
      2 inspect (eqb_universe_instance u u') := {
      2 inspect (eqb_term (tFix mfix idx) (tFix mfix' idx')) := {
      2 inspect (eqb_term (tCoFix mfix idx) (tCoFix mfix' idx')) := {
      2 inspect (eqb_term (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs')) := {
      2 inspect (eqb_term cred c && eqb_term cred' c') := {
      2 inspect (eqb_term cred' c') := {
      2 inspect (eqb_term cred c) := {
      2 inspect (eqb p p') := {
      2 inspect (decompose_app (tApp t2 t3)) :=
      2 inspect _). clearbody arg'.
      2 inspect_cases; try solve [ intros; elimtype False; omega ]; intros.
      2 inspect_cases :=
      2 inspect {A} (x : A) : { y : A | y = x } := exist _ x eq_refl.
      2 inspect {A} (x : A) : { y : A | x = y } := exist x eq_refl.
      2 inspect as [[arg'|] eqarg'] => //; simp rho.
      2 inspect and recurse over values of type [tree A].  This is achieved
      2 inspect (abstract_primitive_constant X p.π1) :=
      2 Debug x ;; tmMkInductive' x) decls ;;
      2 debug with
      2 Debug "vernacinterp".
      2 debug_vars:
      2 Debugvar.
      2 DEBUG_UNFOLD. rewrite (@listd_sort_inter _ state).
      2 Debug "ThisFlagDoesNotExist".
      2 debug then tmPrint (quotation_of t) else ret tt);; tmFail "No typeclass instance"
      2 debug then tmPrint (quotation_of t) else ret tt);; ret (@my_None _)
      2 debug then tmPrint (qt, inductive_quotation_of ind) else ret tt);; ret None
      2 debug then tmPrint qt else ret tt);; tmFail "bound argument is not ground")
      2 debug then tmPrint (inductive_quotation_of indv) else ret tt);; ret None
      2 debug_term ("tsl_rec1: " ^ case ^ " " ^ symbol ^ " not found") in
      2 debug_term msg:= tVar ("debug: " ^ msg).
      2 debug "tCase" (match ik.(ci_ind) with mkInd s _ => string_of_kername s end)
      2 debug "tCase" (match (fst ik) with mkInd s _ => string_of_kername s end)
      2 Debug tA' ;;
      2 DebugSkipGR r
      2 DebugSkipGR '(mp, name) :=
      2 DebugSkipGR cr
      2 Debug s a) (Finished m vm hm tt)
      2 debug_reifyf_case "snd" in
      2 debug_reifyf_case "pair" in
      2 debug_reifyf_case "matchpair" in
      2 debug_reifyf_case "let in" in
      2 debug_reifyf_case_idtac case :=
      2 debug_reifyf_case "generic" in
      2 debug_reifyf_case "fun" in
      2 debug_reifyf_case "fst" in
      2 debug_reifyf_case "dlet in" in
      2 debug_reifyf_case case := debug3 ltac:(fun _ => debug_reifyf_case_idtac case).
      2 Debug RAKAM.
      2 DebugPrint {T : Type@{_T}} (v : T)
      2 DebugPrint tmTyv;;
      2 DebugPrint tmn;;
      2 DebugPrint tmEx;;
      2 DebugPrint tmcv;;
      2 DebugPrint tmcty;;
      2 DebugPrint (split_common_prefix base mp);;
      2 DebugPrint
      2 debug := preProcess; doTac_debug.
      2 debug_params:
      2 debug_opt := true.
      2 DebugMsg "tmMakeQuotationOfConstants_gen: tmQuoteToGlobalReference";;
      2 DebugMsg ("tmMakeQuotationOfConstants_gen: skipping excluded constant " ++ name);;
      2 DebugMsg "tmMakeQuotationOfConstants_gen: looking up module constants";;
      2 DebugMsg "tmMakeQuotationOfConstants_gen: handling";;
      2 DebugMsg "skipping irrelevant constant";;
      2 DebugMsg s := (if debug
      2 debug_leave_reify_success_idtac funname e :=
      2 debug_leave_reifyf_success e in
      2 debug_leave_reifyf_success e := debug_leave_reify3_success "reifyf" e.
      2 debug_leave_reify3_success funname e := debug3 ltac:(fun _ => debug_leave_reify_success_idtac funname e).
      2 debuginfo) (c: code) : code :=
      2 debug : ident := 49%positive.
      2 debug : ident := 151%positive.
      2 debugging_typedefs.
      2 debugging_typedef_bounds.
      2 debugging_sat_solinas_25519_expanded_straightforward.
      2 debugging_sat_solinas_25519_expanded.
      2 debugging_sat_solinas_25519.
      2 debugging_rewriting.
      2 debugging_remove_mul_split_to_C_uint1_carry.
      2 debugging_remove_mul_split2.
      2 debugging_remove_mul_split.
      2 debugging_p448.
      2 debugging_p256_uint1.
      2 debugging_p256_mul_bedrock2.
      2 debugging_no_asm.
      2 debugging.ml
      2 debugging information. *)
      2 debugging_go_output.
      2 debugging_go_build0.
      2 debugging_go_build.
      2 debugging_go_bits_add.
      2 DebuggingExamples
      2 debugging_25519_to_bytes_java.
      2 debugging_25519_to_bytes_bedrock2.
      2 debugging_21271_from_bytes.
      2 DEBUGGING *)
      2 debugging: *)(*
      2 debugging *)
      2 Debug : forall m vm hm s a,
      2 debug := false.
      2 debug_enter_reify_type e := debug_enter_reify3 "reify_type" e.
      2 debug_enter_reify_idtac funname e :=
      2 debug_enter_reify_flat_type T in
      2 debug_enter_reify_flat_type e := debug_enter_reify3 "reify_flat_type" e.
      2 debug_enter_reifyf e := debug_enter_reify2 "reifyf" e.
      2 debug_enter_reifyf e :=
      2 debug_enter_reify_abs e := debug_enter_reify2 "reify_abs" e.
      2 debug_enter_reify_abs e :=
      2 debug_enter_reify3 funname e := debug2 ltac:(fun _ => debug_enter_reify_idtac funname e).
      2 debug_enter_reify2 funname e := debug2 ltac:(fun _ => debug_enter_reify_idtac funname e).
      2 DebugE +' FailureE).
      2 debug eauto with typeclass_instances.
      2 debug eauto 3.
      2 debug:debug_opt} (work_around_coq_bug_17303 : bool) (include_submodule : list ident -> bool) (include_supermodule : list ident -> list ident -> bool) (existing_instance : option hint_locality) (base : modpath) (cs : list global_reference) (tmDoWithDefinition : ident -> forall A : Type@{d}, A -> TemplateMonad@{t u} A) : TemplateMonad@{t u} unit
      2 debug : debug_opt} {T} (t : T) : TemplateMonad term
      2 debug : debug_opt} {T} (t : T) : TemplateMonad (quotation_of t).
      2 debug : debug_opt} (qt : term) : TemplateMonad (option inductive).
      2 debug:debug_opt} (include_submodule : submodule_inclusion) (m : qualid) : TemplateMonad _
      2 debug:debug_opt} (include_submodule : list ident -> bool) (include_supermodule : list ident -> list ident -> bool) (base : modpath) (cs : list global_reference) : TemplateMonad unit
      2 debug : debug_opt} (do_top_inference : bool) (qt : term) : TemplateMonad term.
      2 debug : debug_opt | 1000 := false.
      2 debug code in case something is stuck *)
      2 Debug: Calling typeclass resolution with flags: depth = ∞,unique = false,do_split = true,fail = false
      2 debug auto].
      2 debug_args env arg arg' e = Some e' ->
      2 Debug {A} : A -> TemplateMonad unit
      2 debug3 tac :=
      2 debug2 tac :=
      2 debug1 tac :=
      2 Debug: 1: looking for (Foo true ?y) with backtracking
      2 debug_1 a
      2 Debug: 1.1: simple apply foo on (Foo true ?y), 2 subgoal(s)
      2 Debug: 1.1-2: no match for (Bax true), 0 possibilities
      2 Debug: 1.1-2: looking for (Bax true) without backtracking
      2 Debug: 1.1-2: looking for (Bax false) without backtracking
      2 Debug: 1.1-2 : (Bax true)
      2 Debug: 1.1-2 : (Bax false)
      2 Debug: 1.1-2.1: exact bax_1 on (Bax false), 0 subgoal(s)
      2 Debug: 1.1-1: looking for (Bar true ?y) with backtracking
      2 Debug: 1.1-1 : (Bar true ?y)
      2 Debug: 1.1-1.2: exact bar_1 on (Bar true ?y), 0 subgoal(s)
      2 Debug: 1.1-1.1: exact bar_2 on (Bar true ?y), 0 subgoal(s)
      2 Debug: 10237:proofworker:0:0 STM: sending back a fat state
      2 Debug ;;
      2 debug] *)
      2 debug.*)
      2 debug).
      2 debug :=
      1 traceZ scalemx1.
      1 traceZ mulrCA mulrA mulrC -mxtraceZ scalemx1.
      1 traceZ a A : \tr (a *: A) = a * \tr A. Proof. exact: scalarZ. Qed.
      1 traceZ.
      1 trace y ->
      1 trace {x y u} : x ⨂ u ~> y ⨂ u → x ~> y;
      1 trace w t w' -> invert_expr_prop r m.
      1 trace w t w' -> Csem.step ge S t S' -> exists rule, In (TR rule t S') (do_step w S).
      1 trace w t w')) as [[w' A] | A].
      1 trace_with_test {state: Type} {state_R: Relation state} (P: state -> Prop) : traces state :=
      1 trace_with_test P).
      1 trace_with_test P)
      1 trace_with_test: forall {state: Type} {state_R: Relation state} (P: state -> Prop), traces state.
      1 trace_with_test
      1 trace_, which we facilitate by
      1 trace_wf; eapply H0.
      1 trace_wf:
      1 trace_well_formed :
      1 trace we computed was already used. *)
      1 trace w E0 w) by constructor.
      1 trace was generated by a previous call to [inster], or we might get stuck in an infinite loop!  (We store previous [inster] terms in second positions of tuples used as arguments to [done] in hypotheses.  Proofs instantiated by [inster] merely use [tt] in such positions.) *)
      1 trace) (vres : val) 
      1 TraceVisEnd : forall X (e : E X) k,
      1 TraceVisContinue : forall X (e : E X) (x : X) k tr,
      1 Trace U V a := \sum_(x in 'Gal(V / U)) (x a).
      1 trace using good_trace_ind; intros; try solve [simpl in *; intuition].
      1 trace using good_trace_ind; intros; simpl in *; intuition (auto; try congruence).
      1 traceUn s : trace [s]
      1 trace (unit_right⁻¹ ∘ f ∘ unit_right) ≈ f;
      1 trace. unfold correct_entry in *.
      1 trace type of Omega [t_omega] *)
      1 TraceT * unit) =>
      1 TraceT : Type}
      1 TraceT TraceT' : Type} :
      1 TraceT TraceT' : Type}
      1 trace tr tr2)
      1 trace tr) ++ queue (nwState net Primary).
      1 Trace := tr; Memory := m; Locals := l; Functions := functions }>
      1 Trace := tr; Memory := m'; Locals := l; Functions := functions }>
      1 trace (tr : list (name * ((@input PB_base_params) + list (@output PB_base_params)))) :
      1 trace tr /\ exists s, begin_state tr s /\ P s.
      1 TraceT -> ReturnT)
      1 trace_tr A : \tr A^T = \tr A.
      1 trace_trans : forall step (a b c : A) (os os' : list trace),
      1 trace_trans; eauto.
      1 trace_trans.
      1 trace -> trace
      1 trace tr2.
      1 trace (tr1 ++ tr2) = revert_trace tr1 ++ revert_trace tr2.
      1 trace tr1 tr2 /\
      1 trace tr1.
      1 trace tr)).
      1 trace tr'
      1 trace tr ->
      1 TraceT qs R (bod b)) =
      1 TraceT qs R bod =
      1 trace tp t.
      1 TraceT_map_valid (r, t0)); eauto.
      1 TraceT'_map_valid (r, t0)); eauto.
      1 TraceT'_map_valid : forall el, Q el -> P (fst el, TraceT'_map (snd el))
      1 TraceT_map_valid : forall el, P el -> Q (fst el, TraceT_map (snd el));
      1 TraceT_map_valid (_, _)); eassumption.
      1 TraceT'_map_valid (_, _)).
      1 TraceT_map : TraceT -> TraceT';
      1 TraceT'_map : TraceT' -> TraceT;
      1 TraceT'_map (snd el))) x); intuition.
      1 TraceT'_map_inv t) in H4; eauto.
      1 TraceT_map_inv t0).
      1 TraceT'_map_inv t0).
      1 TraceT_map_inv : forall trace, TraceT'_map (TraceT_map trace) = trace;
      1 TraceT'_map_inv : forall trace, TraceT_map (TraceT'_map trace) = trace;
      1 TraceT_map_inv b); eapply in_map_iff; eexists (_, _); split;
      1 TraceT_map_inv b).
      1 TraceT_map_inj : forall trace trace', TraceT_map trace = TraceT_map trace'
      1 TraceT'_map_inj : forall trace trace', TraceT'_map trace = TraceT'_map trace'
      1 TraceT'_map_inj; destruct a; destruct x0; simpl in *; subst; eauto.
      1 TraceT_map_inj.
      1 TraceT'_map_inj.
      1 TraceT_map := fun el => (fst (snd el), (fst el, snd (snd el))))
      1 TraceT'_map := fun el => (fst (snd el), (fst el, snd (snd el))));
      1 TraceT_map (Equivalent_Trace_Ensembles := H (fst el)))
      1 TraceT'_map (Equivalent_Trace_Ensembles := H (fst el)))
      1 TraceT_map :=
      1 TraceT'_map :=
      1 trace, T_implies_R.
      1 trace the dataflow into that variable, so the checker does
      1 TraceT heading}
      1 trace, tgt_tp) tgt_m' n).
      1 trace (tensor_assoc⁻¹ ∘ id[c] ⨂ f ∘ tensor_assoc)
      1 TraceT -> Ensemble (ReturnT * TraceT'))
      1 TraceT B} :
      1 TraceTau : forall t tr,
      1 trace tau2 of a stack A 
      1 trace tau1 of a stack A 
      1 trace [t] as initial trace,
      1 trace t1 tr -> is_trace t2 tr.
      1 TraceT} :
      1 TraceT)),
      1 TraceT')) :=
      1 TraceT'))
      1 TraceT' =>
      1 TraceT =>
      1 trace t,
      1 traces... until now... they are empty:*)
      1 trace := sum the_diagonal.
      1 trace_submod1 U (modU : mG U) :
      1 trace_submod1 (Socle_module sG) soc1) // mxtrace_Socle //.
      1 trace_sub_fact_mod x :
      1 trace_sub_fact_mod modV') addrC; congr (_ + _).
      1 trace (str tt ++ nl) 0)).
      1 trace_strong_trans; eauto.
      1 trace_strong_trans ; eauto.
      1 trace_strong_trans; eassumption.
      1 trace_strong_trans:
      1 trace_strong mu:= list_map_rel (inject_event_strong mu).
      1 trace_strong j12 v1 v2 /\ inject_trace j23 v2 v3.
      1 trace_strong j12 l1 l2 ->
      1 trace_strong_interpolation Htrace) as (t2&Htrace12&Htrace23).
      1 trace_strong_interpolation:
      1 trace_strong f' t t';
      1 trace_strong f' t t'.
      1 trace_strong f' t t') /\
      1 trace_strong f23 t2 t3 ->
      1 trace_strong f12 t1 t2 ->
      1 trace_strong f12).
      1 trace_strong_determ; eassumption).
      1 trace_strong_determ:
      1 trace_strong (compose_meminj f12 f23) t1 t3.
      1 trace_strong_compose; eauto.
      1 trace_strong_compose:
      1 trace_strong*)
      1 trace (str ++ nl) 0)).
      1 trace_stream: trace >-> stream.
      1 trace_str. clear H3; inv H1. 
      1 traces := trace -> Prop
      1 trace s t k m:
      1 traces. The :stdlib:`std.do!` predicate
      1 traces that the simple
      1 traces that end in violation of the
      1 trace step y z l' ->
      1 trace step x y l -> P x y l.
      1 trace step x x'' (tr1 ++ tr2) ->
      1 trace step x x' tr1 ->
      1 trace step x' x'' cs' ->
      1 trace step x x' cs ->
      1 trace step_s.
      1 trace_step_output_correct, step_failure_star_raft_intermediate_reachable.
      1 trace_step_output_correct :
      1 trace step_ordered_failure.
      1 trace step_ordered_dynamic_failure.
      1 trace step_ordered_dynamic.
      1 trace step_ordered.
      1 trace step init (evt_a e) (evt_trace e).
      1 trace step init a' (tr' ++ tr).
      1 trace step init a tr' ->
      1 trace step init a out.
      1 trace step_failure step_failure_init s tr ->
      1 trace, step_failure_star_raft_intermediate_reachable.
      1 trace step_failure_disk_ops.
      1 trace step_failure.
      1 trace step_dup.
      1 trace step_drop.
      1 trace step ctr;
      1 trace step b c os' ->
      1 trace step_async.
      1 trace step a c (os ++ os').
      1 trace step a b os ->
      1 trace step) a a' os ->
      1 trace step_1.
      1 trace (state: Type): Type := stream (state * MetaState state).
      1 trace {state: Type} (tr: trace state) : Prop :=
      1 trace {state: Type} {state_R: Relation state}: traces state :=
      1 trace {state: Type} s ms: trace state :=
      1 trace {state: Type} (R: state -> MetaState state -> Prop) (tr: trace state) : Prop :=
      1 trace state) (s: state): Prop :=
      1 trace state): Prop :=
      1 trace state) (ms: MetaState state): Prop :=
      1 trace state -> MetaState state -> Prop :=
      1 trace_state_correct trace st st'.
      1 trace_state_correct trace st st' ->
      1 trace_state_correct (trace : list (input * output)) (st : data) (st' : data) :=
      1 trace_state_correct_trace_correct; eauto.
      1 trace_state_correct_trace_correct :
      1 trace_state_correct in *. intros.
      1 trace_state_correct in *;
      1 trace_state_correct; auto.
      1 trace_state_correct. auto.
      1 trace_state_correct :
      1 trace "Stack" *) false
      1 trace) (st1 : ThreadPool.t) 
      1 traces (state: Type): Type := Ensemble (trace state).
      1 trace) (S': state).
      1 Traces_Sresource (P: ProgrammingLanguage) (Ac: Action) (Res: Resource) {Acr: Action_resource Ac Res} {CPR: ConcurrentProgrammingLanguage_Sresource P Res} (c2t: Command2Traces P Ac): Type := {
      1 Traces_Sresource P Ac Res c2t}
      1 Traces_Sparallel_resource (P: ProgrammingLanguage) (state: Type) (Ac: Action) (Res: Resource) {AcP: Action_Parallel Ac} {Acr: Action_resource Ac Res} {CPP: ConcurrentProgrammingLanguage_Sparallel P} (c2t: Command2Traces P Ac): Type := {
      1 Traces_Sparallel_resource P model Ac Res c2t}
      1 traces, singleton_trace in H0, H4.
      1 trace (s ++ (ShowFunctions.string_concat (
      1 trace - S rest) recs))))
      1 trace - S rest) recs))
      1 trace, src_tp) src_m' n) ->
      1 traces_pstar {state: Type} (d: traces state): traces state :=
      1 traces_pstar_mono {state: Type}: forall (d1 d2: traces state),
      1 traces_pstar d1) (traces_pstar d2).
      1 traces): Prop :=
      1 Traces (P: ProgrammingLanguage) (Ac: Action): Type := {
      1 traces_power {state: Type} (d: traces state) (n: nat): traces state :=
      1 traces_power_mono {state: Type}: forall (d1 d2: traces state) (n: nat),
      1 traces_power_mono; auto.
      1 traces_power d n tr.
      1 traces_power d1 n) (traces_power d2 n).
      1 traces_pomega {state: Type} (d: traces state): traces state :=
      1 traces_pomega_mono {state: Type}: forall (d1 d2: traces state),
      1 traces_pomega d1) (traces_pomega d2).
      1 TraceSpec TraceSpecObs A.
      1 TraceSpec, the type family of Specification Monads for uninterpretted ITrees. Also contains the effect observation from ITrees into TraceSpec and the proof that it is a monad morphism *)
      1 TraceSpec R).
      1 TraceSpecOrder : OrderM TraceSpec :=
      1 TraceSpecOrderLaws : OrderedMonad TraceSpec.
      1 TraceSpecOrderLaws {E}.
      1 TraceSpecOrder {E}.
      1 TraceSpecObs : EffectObs (itree E) TraceSpec := obs_trace.
      1 TraceSpecObs {E}.
      1 TraceSpecObs. cbn. split; intros.
      1 TraceSpecMorph : MonadMorphism (itree E) TraceSpec TraceSpecObs.
      1 TraceSpecMorph {E}.
      1 TraceSpecMonad : Monad TraceSpec :=
      1 TraceSpecMonadLaws : MonadLawsE TraceSpec.
      1 TraceSpecMonadLaws {E}.
      1 TraceSpecMonad {E}.
      1 TraceSpecInput B) (b : itrace E B)
      1 TraceSpecInput (A : Type) := {p : itrace E A -> Prop | resp_eutt p}.
      1 TraceSpecInput A} : Proper (@eutt _ A A eq ==> iff) (proj1_sig p).
      1 TraceSpecInput A), (forall b, b ∈ p -> b ∈ p') -> w p -> w p'  }.
      1 TraceSpec in *; intros; try apply H0; try apply H; auto.
      1 TraceSpec : Eq1 TraceSpec := fun _ w1 w2 => forall log p, w1 log ∋ p <-> w2 log ∋ p.
      1 TraceSpec (A : Type) := ev_list E -> {w : TraceSpecInput A -> Prop |
      1 TraceSpec A) (log : ev_list E) (p p' : TraceSpecInput A),
      1 TraceSpec A -> itree E A -> Prop :=
      1 TraceSpec A) (g : A -> TraceSpec B) : TraceSpec B :=
      1 TraceSpec A) (g : A -> TraceSpec B) :=
      1 TraceSpec A := fun log p => p ( Ret a).
      1 TraceSpec A := fun log p => p (↑log ++ Ret a).
      1 Traces P Ac): Type := {
      1 Traces P Ac;
      1 traces, one is a prefix of the other.  The same wouldn't necessarily hold if
      1 traces off:
      1 Traces of all lengths exist,
      1 traces of actions that a process could
      1 trace_Socle : let modS := Socle_module sG in
      1 trace_snoc_key.
      1 trace_snoc_key :
      1 trace (s (* ++ nl*)) 0)) p.
      1 trace s ms) ms.
      1 trace s ms) ms' ->
      1 trace s ms).
      1 traces monad *)
      1 trace s k m:
      1 TracesIT
      1 traces_interleave_intro: forall (Tr1 Tr2: traces) tr1 tr2 tr, Tr1 tr1 -> Tr2 tr2 -> trace_interleave (fun _ => False) (fun _ => False) tr1 tr2 tr -> traces_interleave Tr1 Tr2 tr.
      1 traces_interleave (cmd_denote c1) (cmd_denote c2)
      1 traces_interleave {Ac: Action} {Res: Resource} {AcP: Action_Parallel Ac} {Acr: Action_resource Ac Res}: traces -> traces -> traces :=
      1 Traces inject. *)
      1 traces in H; normal; subst; eauto.
      1 trace_singleton_inv :
      1 trace) (s : infseq event),
      1 traces, ignoring the end of the first trace. *)
      1 trace shows that [eq_trans] was used in just the position where it
      1 traces (E : Type -> Type) (R : Type) : Type :=
      1 traces {E : Type -> Type} {R : Type} :
      1 traces {E : Type -> Type} {R S : Type}
      1 trace_set_complete : forall E R (t1 t2 : itree E R), (forall b, b ⊑ t1 <-> b ⊑ t2) <-> t1 ≈ t2.
      1 trace_set -> 
      1 trace_set ->
      1 traces E R) (kts : R -> traces E S) : traces E S :=
      1 traces E R :=
      1 traces_equiv.
      1 traces_equiv
      1 TraceSemantics P (resources * state) Ac) (Inv: resource * (state -> Prop) -> Prop): BigStepSemantics P state :=
      1 TraceSemantics P (resources * state) Ac): BigStepSemantics P state :=
      1 TraceSemantics (P: ProgrammingLanguage) (state: Type) (Ac: Action): Type := {
      1 TraceSemantics _ _ _ c2t (ThreadLocal_ActionInterpret_resource ac_sem Inv)).
      1 traces; eapply Asm.semantics_determinate.
      1 traces. eapply Asm.semantics_determinate.
      1 trace - S (cTriplePi3 trace)) recs).
      1 trace - S (cTriplePi3 trace)) recs)).
      1 trace - S (cTriplePi3 trace)) recs)))
      1 trace - S (cTriplePi3 trace)) recs)
      1 traces (Cstrategy.semantics p)).
      1 trace - S (cPairPi2 rest)) recs)))
      1 trace - S (cPairPi2 rest)) recs))
      1 trace_scalar. Qed.
      1 trace_scalar mulrnAr mulrnAl mulr_natl.
      1 trace_scalar a : \tr a%:M = a *+ n.
      1 traces being prefixes of other traces *)
      1 traces_app (traces_power d n) d
      1 traces_app {state: Type} (d1 d2: traces state): traces state :=
      1 traces_app (singleton_traces (singleton_trace (Aacquire_res r))) (traces_app (cmd_denote c) (singleton_traces (singleton_trace (Arelease_res r))))
      1 traces_app_mono {state: Type}: forall (d1 d2 d3 d4: traces state),
      1 traces_app_mono; auto.
      1 traces_app_intro: forall tr1 tr2 (Tr1 Tr2: traces), Tr1 tr1 -> Tr2 tr2 -> traces_app Tr1 Tr2 (trace_app tr1 tr2).
      1 traces_app d1 d2) (traces_app d3 d4).
      1 traces_app {Ac: Action}: traces -> traces -> traces :=
      1 traces and streams, get associativity for free from bind_bind*)
      1 traces_ a command might generate.  Note that, for us, a
      1 traces_access _ _ (ThreadLocal_ActionInterpret_resource _ Inv) (cmd_denote c) (fun _ => False, s_pre) (lift_function (pair A_post) ms_post) -> match ms_post with | Error => False | NonTerminating => True | Terminating s_post => KRIPKE: s_post |= Post end).
      1 traces_access {state: Type} {Ac: Action} {ac_sem: ActionInterpret state Ac}: traces -> state -> MetaState state -> Prop :=
      1 traces_access_intro tr _ _ _ H1 HH)).
      1 traces_access_intro tr); auto.
      1 traces_access_intro tr2 _ _ _ H3 HH)).
      1 traces_access_intro tr1 _ _ _ H0 HH)).
      1 traces_access_intro: forall tr (Tr: traces) s ms, Tr tr -> trace_access tr s ms -> traces_access Tr s ms.
      1 traces_access (cmd_denote c) (fun _ => False, s) (lift_function (pair ( fun _ => False)) ms)).
      1 traces {Ac: Action} (tr: trace): traces := eq tr.
      1 trace s1' m1''' args
      1 trace R tr2.
      1 trace R tr1.
      1 Tracer`` tab.
      1 trace, RT1n_step.
      1 trace_rsim simU) // (mxtrace_rsim simV) //.
      1 trace_rsim (rsim_submod1 modU defU). Qed.
      1 trace_rsim n1 n2 (rG1 : reprG n1) (rG2 : reprG n2) :
      1 trace_rsim (mx_rsim_factmod modU' modV' addUV' dxUV')).
      1 trace_rsim Gx; apply/mx_rsim_iso; apply: isoW.
      1 trace R (s::A) -> (~dupfree (s::A)) -> exists s' k, star R s s' /\ pow R (S k) s' s'.
      1 tracer.png
      1 Tracer panel.
      1 trace, R_implies_T.
      1 trace_rev: forall {state: Type} (s s': state) ms ms',
      1 trace_ret tr1 = Some r /\
      1 trace_ret tr
      1 TraceRet : forall r, is_traceF (RetF r) (TRet r)
      1 trace_ret {E R} (tr : @trace E R) : option R :=
      1 trace : rel_trace2 = Events.Event_acq_rel lev2 dpm2 lev2' :: nil)
      1 trace rel_trace2.
      1 trace_relations_work _ _ step_failure (ITR client id (eInput e)) (failed, net) tr.
      1 Trace (reindex_inj (mulgI x)).
      1 Trace (reindex_acts 'R _ galEx) ?astabsR //=.
      1 trace_regular sG) //=.
      1 trace_regular :
      1 trace; reflexivity             
      1 trace_refine_vis_l in Hrefb as Hvis. destruct Hvis as [X [e' [k' Hvis ] ] ].
      1 trace_refine_vis_l in Href as Hbt. destruct Hbt as [A [e0 [k0 Hvis] ]  ].
      1 trace_refine_vis_l in H2 as Ht.
      1 trace_refine_vis_l in H1 as Ht0.
      1 trace_refine_vis_l : forall (E : Type -> Type) (R A: Type) (t : itree E R)
      1 trace_refine_vis_inv : forall (E : Type -> Type) (R A: Type) (e : E A) (a : A)
      1 trace_refine_vis in Href as Hbhd. basic_solve.
      1 trace_refine_vis in Hbt2 as Hb.
      1 trace_refine_vis in Hbt1 as Hb.
      1 trace_refine_vis in H0 as Hvis.
      1 trace_refine_vis : forall (E : Type -> Type) (R A : Type) (b : itrace E R)
      1 trace_refine (Vis e k) (Vis (evans A e a) (fun _ => b))  -> trace_refine (k a) b .
      1 trace_refine_vis_add with (e := e) (k := k) (a := a) as Hbrv.
      1 trace_refine_vis_add with (e := e) in Hbk.
      1 trace_refine_vis_add : forall (E : Type -> Type) (R A: Type) (e : E A) (a : A)
      1 trace_refine_vis_add. auto.
      1 trace_refine t b) (at level 70).
      1 trace_refine_ret_inv_r in Hrutt. constructor.
      1 trace_refine_ret_inv_r in Hrefb. rewrite Hrefb in Hrefbind.
      1 trace_refine_ret_inv_r : forall (E : Type -> Type) (R : Type) (r : R)
      1 trace_refine_ret_inv_l in H2.
      1 trace_refine_ret_inv_l : forall (E : Type -> Type) (R : Type) (r : R)
      1 trace_refine_ret : forall (E : Type -> Type) (R : Type) (r : R),
      1 trace_refine] relation in [ITree.ITrace.ITraceDefinition]. *)
      1 trace_refine_proper_right' : forall (E : Type -> Type) (R : Type) (b : itrace E R)
      1 trace_refine_proper_right'; [eauto | eapply trace_refine_proper_left'; eauto]);
      1 trace_refine_proper_left' : forall (E : Type -> Type) (R : Type) (b1 b2 : itrace E R)
      1 trace_refine_proper {E R} : Proper (@eutt E R R eq ==> eutt eq ==> iff) trace_refine.
      1 trace_refine_may_converge : forall (E : Type -> Type) (R : Type)
      1 trace_refine_may_converge_ex : forall (E : Type -> Type) (R : Type)
      1 trace_refine {E R}  (t : itree E R) (b : itrace E R)  :=
      1 trace_refine E R (Ret r) (Ret r).
      1 trace_refine_diverge_bind : forall (E : Type -> Type) (R S : Type)
      1 trace_refine_diverge_bind; auto.
      1 trace_refine_converge_bind with (r := r); auto.
      1 trace_refine_converge_bind : forall (E : Type -> Type) (R S : Type)
      1 trace_refine_bind in H0 as Hbind.
      1 trace_refine_bind : forall (E : Type -> Type) (R S : Type)
      1 trace_refine_bind_cont_inv with (r:= r) in Hbind; auto.
      1 trace_refine_bind_cont_inv : forall (E : Type -> Type) (R S : Type)
      1 trace_refine_bind_cont_inv
      1 trace_refine_all_infinite : forall (E : Type -> Type) (R : Type)
      1 trace recs : nat => pred (pred (pred (g trace))))
      1 trace recs : nat => pred (pred (g trace)))
      1 trace recs : nat => pred (g trace))
      1 trace recs : nat => g trace)
      1 trace recs)) (f5 trace recs))).
      1 trace recs)) (f4 trace recs))
      1 trace recs) (f2 trace recs)) 
      1 trace recs) (f2 trace recs))
      1 trace R1 tr /\ sound_trace R2 tr.
      1 trace P y ys
      1 trace P // x → x1 → x2 → ... → xn *)
      1 trace P x L -> length L <= k.
      1 trace p t ->
      1 trace'' property:
      1 trace -> Prop),
      1 Trace (ProgramState.Total).
      1 Trace (ProgramState.Partial).
      1 trace_prod. Qed.
      1 trace_prod m n (A :'M[F]_(m)) (B :'M[F]_(n)) :
      1 trace [(Primary, @inr A _ out)].
      1 trace [(Primary, inl (Request (Put "james" "awesome")))].
      1 trace preserves that property. *)
      1 trace_prefix_vis_evempty: forall (E : Type -> Type) (R S : Type)
      1 trace_prefix_vis_evempty; eauto.
      1 trace_prefix_vis_evans: forall (E : Type -> Type) (R S : Type) (r : itrace E S -> itrace E R -> Prop)
      1 trace_prefix_vis_evans; eauto with itree.
      1 trace_prefix (Vis (evans _ e ans) k ) t -> exists k', (t ≈ Vis (evans _ e ans) k' )%itree.
      1 trace_prefix_tau_ret; eauto.
      1 trace_prefix_tau_ret:
      1 trace_prefix_tau_inv. auto.
      1 trace_prefix_tau_inv:
      1 trace_prefix_ret : forall E R S F (ob : itrace' E S) (r : R), trace_prefixF F (RetF r) ob.
      1 trace_prefix_proper_r : forall E R S (b : itrace E R) (b1 b2 : itrace E S),
      1 trace_prefix_proper_l : forall E R S (b1 b2 : itrace E R) (b : itrace E S),
      1 trace_prefix_proper {E R S} : Proper (eutt eq ==> eutt eq ==> iff) (@trace_prefix E R S).
      1 trace_prefix_proper_aux_vis: forall (E : Type -> Type) (S R : Type)
      1 trace_prefix_proper_aux_vis; eauto.
      1 trace_prefix_peel_ret_vis:  forall (E : Type -> Type) (R S : Type)
      1 trace_prefix_peel_ret_vis_empty: forall (E : Type -> Type) (R S : Type)
      1 trace_prefix_peel_ret_vis_empty; eauto.
      1 trace_prefix_peel_ret_vis; eauto.
      1 trace_prefix_peel : forall (E : Type -> Type) (S R : Type) (b : itrace E R) (t : itree E S)
      1 trace_prefix_peel; eauto.
      1 trace_prefix (peel b t) b /\ (peel b t ⊑ t).
      1 trace_prefix (peel b t) b.
      1 trace_prefix_monot : paco.
      1 trace_prefix_monot {E R S} : monotone2 (@trace_prefix_ E R S).
      1 trace_prefix m1 t.
      1 trace_prefix_ : itree.
      1 trace_prefix in Hconv; eauto.
      1 trace_prefix_ind (k1 tt) (k2 tt) ->
      1 trace_prefix_ind {E R S} : itrace E R -> itrace E S -> Prop :=
      1 trace_prefix_ind_comb in H. destruct H as [b3 Hb3].
      1 trace_prefix_ind_comb : forall E R S (b1 : itrace E R) (b2 : itrace E S),
      1 trace_prefix_ind_bind : forall E R S (b1 : itrace E R) (b2 : itrace E S),
      1 trace_prefix_ind_bind. auto.
      1 trace_prefixF_vis_l; eauto.
      1 trace_prefixF_vis_l:
      1 trace_prefixF (upaco2 trace_prefix_ r) (TauF (peel_ (RetF r0) (observe t0))) (RetF r0).
      1 trace_prefixF_tau_inv_r; eauto.
      1 trace_prefixF_tau_inv_r:
      1 trace_prefix : forall E R S (b1 : itrace E R) (b2 : itrace E S) (r : R),
      1 trace_prefixF : itree.
      1 trace_prefixF F (VisF (evempty A H e) kr) (VisF (evempty A H e) ks )
      1 trace_prefixF F (VisF (evans A e ans) kr ) (VisF (evans A e ans) ks)
      1 trace_prefixF {E : Type -> Type} {R S : Type} (F : itrace E R -> itrace E S -> Prop) : itrace' E R -> itrace' E S ->  Prop :=
      1 trace_prefixF; auto. rewrite <- x in REL.
      1 trace_prefix {E R S} : itrace E R -> itrace E S -> Prop := paco2 trace_prefix_ bot2.
      1 trace_prefix_ {E R S} F (br : itrace E R) (bs : itrace E S) := trace_prefixF F (observe br) (observe bs).
      1 trace_prefix_div in H0 as Heuttdiv; eauto.
      1 trace_prefix_div : forall E R S (b1 : itrace E R) (b2 : itrace E S),
      1 trace_prefix_bind : forall E R S (b1 : itrace E R) (b2 : itrace E S),
      1 trace_prefix_bind. eapply trace_prefix_peel; eauto.
      1 trace_prefix b b1 -> trace_prefix b b2.
      1 trace_prefix b b1 -> r b b2 ) ->
      1 trace_prefix b1 b -> trace_prefix b2 b.
      1 trace_prefix b1 b -> r b2 b) ->
      1 trace_prefix b1 b2 -> may_converge r b1 -> trace_prefix_ind b1 b2.
      1 trace_prefix b1 b2 -> exists g, (ITree.bind b1 g ≈ b2).
      1 trace_prefix b1 b2 -> euttNoRet b1 b2.
      1 trace_poly_type n = trace_poly_type (n+0) by congr trace_poly_type; lia.
      1 trace_poly_type n s).
      1 trace_poly_type n s *)
      1 trace_poly_type (n+e) s))
      1 trace_poly_type (length ns) s) t -> 
      1 trace_poly_type e t)) (trace_poly_type e s)
      1 trace_poly_typeE {s ns Gamma t n}: 
      1 trace_poly_type (e: nat) (t: poly_type) : pure_term :=
      1 trace_poly_typeE (n := 0)).
      1 trace (P : list mm2_instr) (x : mm2_state) (xs : list mm2_state) : Prop :=
      1 trace picking heuristics
      1 trace (p: Csyntax.program) (t: trace): Prop :=
      1 trace "PC" *) false
      1 trace (p: Asm.program) (t: trace): Prop :=
      1 trace Partial.forward_trace.
      1 trace_outputs tr <= trace_inputs tr.
      1 trace_outputs (tr : list (name * (input + list output))) : nat :=
      1 trace_outputs (tr1 ++ tr2) = trace_outputs tr1 + trace_outputs tr2.
      1 trace_outputs [((pDst p), inr o)] +
      1 trace_outputs_input.
      1 trace_outputs_input :
      1 trace_outputs [(h, inr o)] +
      1 trace_outputs [(h, inl i)] = 0.
      1 trace_outputs_backup in *. unfold send_packets in *.
      1 trace_outputs [(backup, e)] = 0.
      1 trace_outputs_backup :
      1 trace_outputs_app :
      1 trace_or_app. right.
      1 trace_or_app :
      1 trace operator here is [loop].
      1 Trace operator (generalization of [KTree.loop]). *)
      1 trace one needs to execute the
      1 trace of x/y, A is equal to the lower trace of x/y,A. *)
      1 Trace Off.
      1 trace of every proof step that is attempted.  The rule [eq_trans] applies
      1 trace of bind t f into a head that refines t and a tail
      1 trace of a square matrix A.                          *)
      1 trace of A is equal to the lower trace of A. *)
      1 Trace "of".
      1 trace_occ tr = [(n, inr ol)] -> 
      1 trace_occ tr = [(h, inl inp); (h, inr out)] -> 
      1 trace_occ tr)) => /=.
      1 trace_occ_inv : 
      1 trace_occ_in_inv : 
      1 trace_occ (e : @name _ multi_fst * (@input base_fst + list (@output base_fst))) :=
      1 trace_occ (e : @name _ multi_fst * (@input base_fst + list (@output base_fst))) :
      1 trace_occ _ |- _ =>
      1 trace_O :
      1 trace_n_stream {state: Type}: forall (s: state) ms,
      1 trace_n_stream.
      1 trace_not_nil :
      1 TraceNotNice :
      1 TraceNot makeTraceForall.
      1 TraceNot in |- *.
      1 TraceNot (f : fol.Formula L) (frec : nat * fol.Term L -> nat)
      1 TraceNot f2 z1 q = makeTraceNot f2 z2 q.
      1 trace_not_dupfree_loop (X : eqType) (R: X -> X -> Prop) s (A:list X) :
      1 trace_not_atx:
      1 trace_no_step in H; [|solve [auto]]; subst
      1 trace_no_step :
      1 trace_non_empty_out tr) ->
      1 trace_non_empty_out tr = []).
      1 trace_non_empty_out_input_correct.
      1 trace_non_empty_out_input_correct :
      1 trace_non_empty_out (filterMap pt_map_trace_occ tr) = [].
      1 trace_non_empty_out (e : name * (input + list output)) :=
      1 trace_non_empty_out; auto.
      1 trace_NoDup : NoDup trace. *)
      1 trace_nil:
      1 trace newline 0)) nil ++
      1 trace_natural_in_y {x y y' u} {f : x ⨂ u ~> y ⨂ u} {g : y ~> y'} :
      1 trace_natural_in_x {x x' y u} {f : x ⨂ u ~> y ⨂ u} {g : x' ~> x} :
      1 trace_natural_in_u {x y u u'} {f : x ⨂ u ~> y ⨂ u'} {g : u' ~> u} :
      1 trace : nat => pred (pred (pred (g trace)))).
      1 trace : nat => pred (pred (pred (g trace))))).
      1 trace : nat => pred (pred (g trace)))).
      1 trace : nat => pred (g trace))).
      1 Trace : nat -> nat :=
      1 trace : nat => cTriplePi3 (cTriplePi1 trace))).
      1 trace : nat => cTriplePi3 (cTriplePi1 trace))
      1 trace : nat => cTriplePi2 (cTriplePi1 trace))).
      1 trace : nat => cTriplePi2 (cPairPi1 (cTriplePi3 trace))).
      1 trace : nat => cTriplePi2 (cPairPi1 (cTriplePi3 trace)))
      1 trace : nat => cTriplePi1 (cTriplePi1 trace))).
      1 trace : nat => cPairPi2 (cTriplePi3 (cTriplePi1 trace)))
      1 trace : nat => cPairPi1 (cTriplePi3 (cTriplePi1 trace))).
      1 trace : nat => cPairPi1 (cTriplePi3 (cTriplePi1 trace)))
      1 trace : nat => cPair 2 (cTriplePi2 (cTriplePi3 trace))).
      1 trace : nat => codeFreeVarTerm (cTriplePi2 (cTriplePi1 trace))).
      1 trace : nat => codeFreeVarTerm (cTriplePi2 (cTriplePi1 trace)))
      1 trace : nat => 2)
      1 trace : nat => 1)
      1 trace_n1_ind; simpl; intros.
      1 trace_n1_ind; intro H_init.
      1 trace_n1_ind => /= H_init; first by rewrite H_init.
      1 trace_n1_ind => H_init.
      1 trace_n1_ind => /= H_init.
      1 trace_n1_ind.
      1 trace_n1_ind :
      1 trace : n > 0 -> char_poly`_n.-1 = - \tr A.
      1 trace_mx11 mxE Gx det1.
      1 trace_mx11 mxE Gx.
      1 trace_mx11 !mxE eqxx !mulrb.
      1 trace_mx11 mxE.
      1 trace_mx11 -mx11_scalar.
      1 trace_mx11 (A : 'M_1) : \tr A = A 0 0.
      1 trace_mx11 !{1}mxE det_ublock; congr (_ * _).
      1 trace_mx11 .
      1 trace mu:= list_map_rel (inject_event mu). 
      1 trace_mulC -val_submodE addrC.
      1 trace_mulC -val_factmodE addrC.
      1 trace_mulC repr_mxK.
      1 trace_mulC mulmxA fK mul1mx.
      1 trace_mulC mulmxA B'B mul1mx.
      1 trace_mulC mulKVmx // mxtrace_diag.
      1 trace_mulC mulKVmx //.
      1 trace_mulC -[_ *m _](repr_mxK rG Gx) rGx.
      1 trace_mulC m n (A : 'M[R]_(m, n)) B :
      1 trace_mulC; congr (\tr(_ *m _)).
      1 trace msg (n1', n2 + 1)
      1 trace) (m' : mem),
      1 trace := (MM2.mm2_trace M).
      1 trace "Memory" *) false
      1 trace: meminj -> trace -> trace -> Prop :=
      1 trace -> map.rep _ _ mem -> list (word.rep (word:=BasicC32Semantics.word)) -> Prop :=
      1 trace_map_mx. Qed.
      1 trace_map_mx map_diag_mx; set d' := diag_mx _.
      1 trace_map_mx (A : 'M_n) : \tr A^f = f (\tr A).
      1 trace (map2fst to (map inr out)) =
      1 Trace (makeTrace f (v, s)) = 1.
      1 trace m1 m1'''
      1 trace ltac:(fun _ => idtac))
      1 trace ltac:(fun H =>
      1 trace l) -> P (IRI k :: IRU k' :: l) (k = k' /\ good_trace l)) ->
      1 trace l) -> P (IRI k :: IRO k' :: l) (k = k' /\ good_trace l)) ->
      1 trace _ (log_to_IR env_o log).
      1 trace (l : list IR) : Prop :=
      1 trace: list X -> Prop :=
      1 trace : list trace }.
      1 trace : list op) :=
      1 trace := List.map tot_map_trace_occ e.(evt_trace) |}.
      1 trace : list (input * output)) (k : key) : list input :=
      1 trace := list action;
      1 trace_linear := Linear mxtrace_is_scalar.
      1 trace l).
      1 trace k)) (Map.find k st)) = Map.find k st'.
      1 trace, key_eq_dec.
      1 Trace K E (x a) = galTrace K E a.
      1 Trace K E a == \sum_(f in 'Gal(E / K)) (f a).                    *)
      1 Trace K E a \in fixedField 'Gal(E / K).
      1 Trace K E a : galois K E -> a \in E -> galTrace K E a \in K.
      1 trace j23 l2 l3 ->
      1 Trace.ITracePrefix
      1 Trace.ITracePreds.
      1 Trace.ITracePreds
      1 trace_is_scalar : scalar mxtrace.
      1 TraceIsPR : isPR 1 checkSubFormulaTrace.
      1 TraceIsPR.
      1 trace is not accepted by the external world. *)
      1 trace is nonempty, ensuring that [inster] fails if no progress can be made. *)
      1 trace is left
      1 trace] is an accumulator recording which instantiations we choose. *)
      1 trace is a list of output values and/or termination markers.  We drop silent
      1 Trace_is_additive : additive (galTrace U V).
      1 trace ir) -> P (IRI k :: IRU k' :: ir) (k = k' /\ good_trace ir)) ->
      1 trace ir) -> P (IRI k :: IRO k' :: ir) (k = k' /\ good_trace ir)) ->
      1 trace_IRI_in; auto.
      1 trace_IRI_in :
      1 trace ir).
      1 trace ir /\
      1 trace IO R) := state_machine (wnm_ev n) bot4 (writes_n 0) bot1 tr.
      1 trace IO R:=
      1 trace IO R :=
      1 trace IO (env * A) -> Prop.
      1 trace_inv in Heqt0; destruct Heqt0 as [<- <-].
      1 trace_inv {E R} (t1 t2 : @trace E R) (H : t1 = t2)
      1 trace_invariant_invariant :
      1 trace. intuition subst;cbn in *. rewrite <- lem. eauto using starR.
      1 trace. intuition subst;cbn in *. lia.
      1 trace in the context!  Abort to backtrack to try another trace. *)
      1 trace in text format (if VSCode is not an option,
      1 trace_interleave s0' s1' s2 s' A'); auto.
      1 trace_interleave s0' s1 s2' s' A'); auto.
      1 trace_interleave_right: forall (A1 A2 A2': resources) tr1 a2 tr2 tr, res_enable a2 A2 A2' A1 -> trace_interleave A1 A2' tr1 tr2 tr -> trace_interleave A1 A2 tr1 (cons a2 tr2) (cons a2 tr).
      1 trace_interleave_race: forall (A1 A2: resources) a1 tr1 a2 tr2, race_actions a1 a2 -> trace_interleave A1 A2 (cons a1 tr1) (cons a2 tr2) (cons race nil)
      1 trace_interleave_nil_nil: forall (A1 A2: resources), trace_interleave A1 A2 nil nil nil
      1 trace_interleave_left: forall (A1 A1' A2: resources) a1 tr1 tr2 tr, res_enable a1 A1 A1' A2 -> trace_interleave A1' A2 tr1 tr2 tr -> trace_interleave A1 A2 (cons a1 tr1) tr2 (cons a1 tr)
      1 trace_interleave {Ac: Action} {Res: Resource} {AcP: Action_Parallel Ac} {Acr: Action_resource Ac Res}: resources -> resources -> trace -> trace -> trace -> Prop :=
      1 trace_inputs tr = trace_outputs tr +
      1 trace_inputs (tr : list (name * (input + list output))) : nat :=
      1 trace_inputs (tr1 ++ tr2) = trace_inputs tr1 + trace_inputs tr2.
      1 trace_inputs_output in *. simpl in  *. omega.
      1 trace_inputs_output.
      1 trace_inputs_output :
      1 trace_inputs [(h, inr os)] = 0.
      1 trace_inputs [(h, inl i)] =
      1 trace_inputs_app :
      1 trace, input_correct.
      1 trace_inp_inv.
      1 trace_inp_inv :
      1 trace_inj & external_step)
      1 trace, init_tp_source).*)
      1 trace, init_tp).
      1 trace) (init : A) (e : event) :=
      1 trace) (init : A) :=
      1 trace in H; auto
      1 trace in H7; eauto.
      1 trace in H2; eauto.
      1 trace in H
      1 traceinf_prefix t T).
      1 trace_inf_often_vis_pos (e : EvAns E unit) (k : unit -> itrace E R) :
      1 trace_inf_often_vis_neg (e : EvAns E unit) (k : unit -> itrace E R) :
      1 trace_inf_often_tau (b : itrace E R) : trace_inf_oftenF PE F (observe b) ->
      1 trace_inf_often_monot {E R} PE : monotone1 (@trace_inf_often_ E R PE).
      1 trace_inf_oftenF PE F (VisF e k)
      1 trace_inf_oftenF PE F (TauF b)
      1 trace_inf_oftenF PE F (observe (k tt)) -> trace_inf_oftenF PE F (VisF e k)
      1 trace_inf_oftenF PE F (observe b).
      1 trace_inf_oftenF : itree.
      1 trace_inf_oftenF {E : Type -> Type} {R : Type} (PE : forall A, EvAns E A -> Prop)
      1 trace_inf_often {E R} PE := paco1 (@trace_inf_often_ E R PE) bot1.
      1 trace_inf_often_ {E R} PE F (b : itrace E R) :=
      1 trace_ind; eauto.
      1 trace_ind'
      1 trace_ind :
      1 trace inclusion to capture the notion of
      1 trace inclusion. *)
      1 trace inclusion*. *)
      1 trace_incl t1 t2 /\ trace_incl t2 t1.
      1 trace_incl t1 t2 -> sutt eq t1 t2.
      1 trace_incl_sutt in H0. clear H.
      1 trace_incl_sutt : forall {E R} (t1 t2 : itree E R),
      1 trace_incl_sutt; auto.
      1 trace_incl_sutt.
      1 trace_incl in *. unfold is_trace in *.
      1 trace_incl_iff_sutt in *; unfold trace_incl in *; auto.
      1 trace_incl_iff_sutt : forall {E R} (t1 t2 : itree E R),
      1 trace_incl : forall {E R} (t1 t2 : itree E R),
      1 trace_incl.
      1 trace in *. break_exists; simpl in *; intuition.
      1 trace in *;break_exists_exists; intuition].
      1 trace in *. break_exists_exists.
      1 trace in *. break_exists.
      1 trace in *. 
      1 TraceImpNice :
      1 TraceImp in |- *.
      1 TraceImp f2 z1 g z3 q = makeTraceImp f2 z2 g z4 q.
      1 TraceImp (f1 : fol.Formula L)
      1 TraceImp
      1 trace_I_in_import.
      1 trace_I_in_import :
      1 trace, if it exists. *)
      1 trace (id ⨂ g ∘ f) ≈ trace (f ∘ id ⨂ g);
      1 trace, i)) by constructor)
      1 trace, i)) by constructor
      1 trace_I :
      1 trace H H0 then
      1 trace H H0 :=
      1 trace, H) H
      1 trace Hchs_peek Hresume.
      1 Trace has form
      1 trace, H2)
      1 trace H1 H2 :=
      1 trace, H1) H1 H2)
      1 trace H1 :=
      1 trace, H0)
      1 trace H);
      1 trace H :=
      1 trace (gtrace, G)) || (right; yelles0 defs k rtrace (gtrace, G))
      1 trace (gtrace, G) ]
      1 trace gtrace) || fail 1
      1 trace gtrace :=
      1 trace (g ⨂ id ∘ f) ≈ g ∘ trace f;
      1 trace_get_input.
      1 trace_get_input :
      1 Trace_gal a x :
      1 traceF with (t1:=t); auto.
      1 Trace f (v, s)))) with (makeTrace f (v, s)).
      1 Trace f (v, s))) = true).
      1 Trace f (v, s))) = false).
      1 Trace f (v, s)) = cTriple v (codeTerm s) (codeFormula f).
      1 Trace f (v, s))) (cPairPi2 (makeTrace f (v, s)))).
      1 Trace f (v, s)) = codeFormula (substituteFormula L f v s).
      1 Trace f (v, s)))).
      1 Trace f (v, s)))
      1 Trace f (v, s) <=
      1 traceF (VisF e k) tr -> is_traceF (observe t) tr).
      1 traceF (VisF e k) (TEventResponse e x tr)) by (constructor; auto).
      1 traceF (VisF e k) (TEventResponse e x tr)
      1 traceF (VisF e k) (TEventEnd e)) by constructor.
      1 traceF (VisF e k) (TEventEnd e)
      1 traceF (VisF e0 k) (TEventResponse e0 x tr)) by (constructor; auto).
      1 trace (fun s ms => R1 s ms /\ R2 s ms) tr <->
      1 trace f t t' -> t' = t.
      1 trace f' t t').
      1 trace f' t t' ->
      1 trace f t t' ->
      1 trace ?f ?t ?t' |- _  ] =>
      1 trace f ≈ trace (trace (tensor_assoc⁻¹ ∘ f ∘ tensor_assoc));
      1 traceF (TauF t) tr.
      1 traceF (TauF t) tr
      1 traceF_tau : forall {E R} (t : itree E R) tr,
      1 traceF (RetF r0 : itreeF E R (itree E R)) (TRet r0)) by constructor.
      1 trace_forward_test {state: Type} {state_R: Relation state}: forall (P: _ -> Prop) s ms,
      1 trace_forward_test: forall {state: Type} {state_R: Relation state} (P: _ -> Prop) s ms,
      1 trace_forward {state: Type} {state_R: Relation state}: forall s ms,
      1 trace_forward: forall {state: Type} {state_R: Relation state} s ms,
      1 trace_forward; auto |].
      1 trace for this
      1 trace_forall_vis {A : Type} (e : EvAns E A) (k : A -> itrace E R) :
      1 TraceForall v0 a z1 q = makeTraceForall v0 a z2 q.
      1 trace_forall_tau (b : itrace E R) : F b -> trace_forallF F PE PR (TauF b)
      1 trace: forall {state: Type} {state_R: Relation state}, traces state.
      1 trace: forall {state: Type} (s: state) ms,
      1 trace_forall_ret (r : R) : PR r -> trace_forallF F PE PR (RetF r)
      1 trace_forall_proper_eutt {E R PE PR} : Proper (eutt eq ==> iff) (@trace_forall E R PE PR).
      1 trace_forall_proper_aux: forall (E : Type -> Type) (R : Type) (PE : forall A : Type, EvAns E A -> Prop)
      1 trace_forall PE PR (@ITree.spin (EvAns E) R).
      1 trace_forall PE PR b1 -> trace_forall PE PR b2.
      1 TraceForall (n : nat) (f : fol.Formula L)
      1 TraceForallNice :
      1 trace_forall_monot : paco.
      1 trace_forall_monot {E R} PE PR : monotone1 (@trace_forall_ E R PE PR).
      1 trace : forall k c n,
      1 trace_forall_ (is_bool true) (fun _ => True) ) r b).
      1 trace_forall (is_bool true) (fun _ => True) b) /\
      1 trace : forall i h l c1 c2 h' l' c',
      1 trace_forallF : itree.
      1 trace_forallF F PE PR (VisF e k)
      1 trace_forallF F PE PR (observe b).
      1 trace_forallF {E : Type -> Type} {R : Type} (F : itrace E R -> Prop)
      1 trace : forall (E : Type -> Type) (R : Type) (b : itrace E R),
      1 trace : forall (E : Type -> Type) (R : Type)
      1 trace_forall {E R} PE PR := paco1 (@trace_forall_ E R PE PR) bot1.
      1 trace_forall_ {E R} PE PR F (b : itrace E R) :=
      1 trace: forall {cmd state: Type} (ctr: trace (cmd * state)) cs mcs,
      1 Trace : fol.Formula L -> nat * fol.Term L -> nat :=
      1 traceF (observe t) tr <->
      1 traceF (observe t) tr ->
      1 traceF (observe t).
      1 traceF (observe (k x)) tr ->
      1 trace f nil nil
      1 Trace_fixedField. Qed.
      1 Trace_fixedField a :
      1 trace file is generated in ``/tmp/traced.tmp.json``. 
      1 trace ("Fighting " ++ show (List.length mutants) ++ " mutants")
      1 trace (f ∘ g ⨂ id) ≈ trace f ∘ g;
      1 Trace (F: FORWARD) <: FORWARD_TRACE with Module F := F.
      1 traceF {E : Type -> Type} {R : Type} :
      1 trace f (cons e t) (cons e' t').
      1 traceF; auto with itree.
      1 traceF; auto.
      1 Trace Fails... *)
      1 Trace f1 (v, s)).
      1 Trace f0 (v, s)))).
      1 trace f;
      1 trace f :=
      1 trace = [] \/ exists t i o, trace = t ++ [(i, o)]).
      1 trace_execution_lb_step_failure_tot_map_net_infseq : forall s,
      1 trace_execution_lb_step_failure_tot_map_net_infseq.
      1 trace_ev_outputs_eq _ _ _ _ _ name_map out to).
      1 trace_ev_outputs_eq _ _ _ _ _ name_map out h).
      1 trace_ev_outputs_eq /= H_out /=.
      1 trace_ev_outputs_eq Heqo H_o /=.
      1 trace_ev_outputs_eq :
      1 trace_ev (map2fst to (map inr out)) =
      1 trace_ev_list : forall (E : Type -> Type) (R : Type)
      1 trace_ev_list. auto.
      1 trace_ev /= /id /=.
      1 trace: event_trace:= nil. 
      1 trace: Events.inject_trace j2' rel_trace rel_trace2).
      1 trace_ev (e : @name _ multi_fst * (@input base_fst + (@output base_fst))) :
      1 trace | ev_elim m trace m'}.
      1 trace E unit) (b : itrace E R) :=
      1 trace E unit.
      1 trace {E : Type -> Type} {R : Type} : Type :=
      1 trace {E : Type -> Type} {R : Type} (t : itree E R) :=
      1 trace' (E : Type -> Type) (R : Type) := itree' (EvAns E) R.
      1 trace (E : Type -> Type) (R : Type) := itree (EvAns E) R.
      1 trace E S) : trace_prefixF F (RetF r) (observe b)
      1 trace E S) (t : itree E R) r, t ≅ Ret r -> (peel b t ≅ Ret r).
      1 trace E S) (t : itree E R) (f : R -> itree E S) (r : R)
      1 trace E S) (t : itree E R) (f : R -> itree E S)
      1 trace E S) (t : itree E R),
      1 trace E S) (k2 : A -> itree E R) (t : itrace E S),
      1 trace E S) (k2 : A -> itree E R) (k3 : unit -> itrace E R),
      1 trace E R with end) as ke.
      1 trace E R with end) ).
      1 trace E R) (t t': itree E S) (s : S),
      1 trace E R) (t t': itree E S),
      1 trace E R) (t : itree E S) : S -> itrace E R :=
      1 trace E R) (t : itree E S) : itrace E S :=
      1 trace E R) (t : itree E S) (f : S -> itree E R) (r0 : R),
      1 trace E R) (t : itree E S) (f : S -> itree E R),
      1 trace E R) (t : itree E R) (f : R -> itrace E S) (g : R -> itree E S) (r : R),
      1 trace E R) (t : itree E R) (f : R -> itrace E S) (g : R -> itree E S),
      1 trace E R) (t : itrace E S),
      1 trace {E R S} (tr1 : @trace E R) (tr2 : @trace E S) : @trace E S :=
      1 trace E R) (r : R),
      1 trace E R) (r1 r2 : R),
      1 trace E R) :  Prop := paco3 (state_machine_) bot3 PEv PRet tr.
      1 trace' E R -> Prop :=
      1 trace E R -> Prop.
      1 trace' E R) (ot : itree' E S) : itrace E S :=
      1 trace' E R) (ot : itree' E S) : itrace E R :=
      1 trace E R) (obs : itrace' E S) : trace_prefixF F (observe br) obs -> trace_prefixF F (TauF br) obs
      1 trace E R) (m : itree E R) (g : R -> itrace E S)
      1 trace E R) (ks : void -> itrace E S) :
      1 trace E R) (ks : unit -> itrace E S) :
      1 trace E R) (k2 : unit -> itrace E S) b1 b2 b
      1 trace E R) (k2 : unit -> itrace E S) b1 b2 :
      1 trace' E R -> itree' E S -> itrace E S) : itrace E S.
      1 trace' E R -> itree' E S -> itrace E R) : itrace E R.
      1 trace E R -> itrace E S -> itrace E S -> Prop :=
      1 trace E R := determinize_ (observe t).
      1 trace E R), b ≈ Vis (evans A e a) k' /\ k' tt ⊑ k a.
      1 trace E R, b ⊑ t1 <-> b ⊑ t2) -> r t1 t2)
      1 trace E R, b ⊑ t1 <-> b ⊑ t2)
      1 trace E R, b ⊑ t.
      1 trace' E R) (bs : itrace E S) : trace_prefixF F (obr) (observe bs) -> trace_prefixF F (obr) (TauF bs)
      1 trace E R) (bs : itrace E S) : F br bs -> trace_prefixF F (TauF br) (TauF bs)
      1 trace E R) (b : itree (EvAns E) R ) :
      1 trace E R) (b2 : itrace E S) (b : itrace E S),
      1 trace E R.
      1 trace E R) :=
      1 trace E R) :
      1 trace {E} {R}.
      1 trace_equiv σnc σnc'.
      1 trace_equiv σn0 σn0'.
      1 trace_equiv σn0 σn0').
      1 trace_equiv (x :: l) (x' :: l') ->
      1 trace_equiv () () RF_NHE trivial_RF_CHE))
      1 trace_equiv_proper :
      1 trace_equiv_proper
      1 trace_equiv nil nil)
      1 trace_equiv l l'.
      1 trace_equiv l2 l2'.
      1 trace_equiv (l1 ++ l2) (l1' ++ l2') ->
      1 trace_equiv l1 l1'
      1 trace_equiv_inv
      1 trace_equiv in *.
      1 trace_equiv fσn fσn').
      1 trace_equiv_cons_inv in NTR_EQUIV;
      1 trace_equiv_cons_inv
      1 trace_equiv bσn0 bσn0').
      1 trace_equiv_app_inv in TE;
      1 trace_equiv_app_inv in ES;
      1 trace_equiv_app_inv.
      1 trace_equiv_app_inv
      1 trace equivalence is one of the other
      1 Trace equivalence is an appropriate notion of correctness, to relate the
      1 trace equivalence hyp *)
      1 trace equivalence for this kind of
      1 trace equivalence captures _having the same behaviors_. *)
      1 trace equivalence! *)
      1 trace_equiv] *)
      1 trace_eq t1 t2 -> t1 ≈ t2.
      1 traceEq. rewrite Kseqlist_app.
      1 trace_eq_iff_eutt : forall {E R} (t1 t2 : itree E R),
      1 trace_eq : forall {E R} (t1 t2 : itree E R),
      1 trace_eq_eutt : forall {E R} (t1 t2 : itree E R),
      1 trace_eq_eutt.
      1 trace_eq {E : Type -> Type} {R : Type} :
      1 trace_eq {E} : Eq1 (itrace E) := ITreeMonad.Eq1_ITree.
      1 trace_eq :
      1 Trace_Ensembles ReturnT TraceT TraceT' bod bod' ->
      1 Trace_Ensembles (bod tup) (bod' tup))
      1 trace (e : @name _ multi_fst * (@input base_fst + (@output base_fst))) :=
      1 TraceEmpty : forall t, is_traceF t TEnd
      1 trace_eg :
      1 trace e' = evt_trace e ++ tr ->
      1 trace; econstructor; eauto using refl_trans_1n_n1_trace].
      1 trace; econstructor; eauto using refl_trans_1n_n1_trace.
      1 trace (eClient e) (eId e) (eInput e) tr ->
      1 trace; eauto. }
      1 trace E A)
      1 trace_dsum_mod modW _ (eqmx_refl _) (Socle_direct sG)) //.
      1 trace_dsum_mod (I : finType) (P : pred I) U W
      1 trace_dsum_mod (fun i => mxsimple_module (simW i)) modV defV) //.
      1 Traced monoidal category *)
      1 TracedMonoidal := {
      1 traced_is_symmetric : TracedMonoidal >-> SymmetricMonoidal.
      1 traced_is_symmetric : @SymmetricMonoidal C;
      1 traced_is_symmetric.
      1 trace_diag D : \tr (diag_mx D) = \sum_j D 0 j.
      1 trace_diag.
      1 trace determinant cofactor adjugate.
      1 Trace (* "derive.eqbcorrect.*" "derive.param1.functor.*" "correct-lemma-for" *) "param1-functor-for". *)
      1 trace ("Deprecated function: " ++ old ++ ". Use " ++ new ++ " instead.") a.
      1 trace_dec (client : clientId) (id : nat) :
      1 trace_dec ;
      1 trace_dec :
      1 traced categories but
      1 traceD add_sub_fact_mod.
      1 trace_dadd_mod U V W (modU : mG U) (modV : mG V) (modW : mG W) :
      1 trace_dadd_mod.
      1 traceD A B : \tr (A + B) = \tr A + \tr B. Proof. exact: raddfD. Qed.
      1 trace :D *)
      1 traced. *)
      1 trace)) (cTriplePi2 (cTriplePi1 trace)))
      1 Trace (cTriple (cTriple v (codeTerm s) (codeFormula f)) n m) <>
      1 trace ctr;
      1 trace c_program t ->
      1 Trace (cPair (cPairPi1 p) x))).
      1 Trace (cPair (cPairPi1 p) x))
      1 trace_correct'_trace_correct.
      1 trace_correct'_trace_correct :
      1 trace_correct (t ++ [(i, Response (input_key i) v o)]).
      1 trace_correct t ->
      1 trace_correct' st (trace ++ t).
      1 trace_correct' st trace.
      1 trace_correct' st trace ->
      1 trace_correct' st (t ++ [(i, Response (input_key i) v o)]).
      1 trace_correct' st t ->
      1 trace_correct' st []
      1 trace_correct (revert_trace (base_params := vard_base_params) tr).
      1 trace_correct [(Put "james" "awesome", Response "james" (Some "awesome") None)].
      1 trace_correct : list (input * output) -> Prop :=
      1 trace_correct' init trace ->
      1 trace_correct_eg0 :
      1 trace_correct' : data -> list (input * output) -> Prop :=
      1 TraceCorrect.
      1 TraceCorrect
      1 trace_correct.
      1 trace_correct'.
      1 trace_correct' :
      1 trace_correct []
      1 trace_correct :
      1 traceCons s s' A : R s s' -> trace (s'::A) -> trace (s::s'::A).
      1 trace (compose_meminj j12 j23) v1 v3 ->
      1 trace (compose_meminj j12 j23) l1 l3.
      1 trace_component U (simU : mxsimple rG U) :
      1 trace_component (socle_simple W)).
      1 trace_commute in H; eauto.
      1 trace_commute : forall i h l c1 c2 h' l' c',
      1 trace coming from the decision procedure Omega.
      1 trace (cmd * state) -> trace state := 
      1 trace (cmd * state);
      1 trace client id tr} + {~ key_in_output_trace client id tr}.
      1 trace client id tr.
      1 trace client id out (tr ++ o) ->
      1 trace client id out tr} + {~ in_output_trace client id out tr}.
      1 trace client id out tr.
      1 trace client id out os ->
      1 trace client id out o.
      1 trace client id out [(h, inr l)] ->
      1 trace client id out ((h, inl i) :: tr) ->
      1 trace client id out [] -> False.
      1 trace client id out ;
      1 trace client id o tr.
      1 trace client' id' i (tr ++ tr').
      1 trace client id i tr.
      1 trace client id i tr ->
      1 trace client id i [(h, inl inp); o].
      1 trace client id i
      1 trace client id (eInput e) tr.
      1 trace client id (eInput e) tr
      1 trace (client : clientId) (id : nat) (o : output)
      1 trace (client : clientId) (id : nat) (i : input)
      1 trace (client : clientId) (id : nat)
      1 trace c id i (tr1 ++ tr2).
      1 trace c id i tr1 \/ in_input_trace c id i tr2 ->
      1 trace can be limited to a range of steps. Look at the
      1 trace can be limited to a (list of) predicates as follows:
      1 trace) (c1 : state) 
      1 trace_C;
      1 trace_C:
      1 trace browser displays, on the left column, a list of cards corresponding
      1 Trace Browser.`` command and then run any Elpi code.
      1 Trace Browser. *)
      1 Trace browser
      1 trace braid ≈ id[x];
      1 trace_block _ _ _ (ulsubmx A1)).
      1 trace_block. Qed.
      1 trace_block n1 n2 (Aul : 'M_n1) Aur Adl (Adr : 'M_n2) :
      1 trace_block IH.
      1 trace ("Beginnning conjoin" ++ nl) ( *)
      1 trace b); basic_solve.
      1 trace b'); basic_solve.
      1 trace b).
      1 trace A y ->
      1 trace A xs ->
      1 Trace a (v0, s)).
      1 Trace a (v0, s))
      1 trace; auto; [idtac].
      1 trace (A : Type) (t : itree E A) : TraceSpec A :=
      1 trace {A : Type} (s : string) (a : A) : A := a.
      1 trace at the beginning of its execution.  This is a typical
      1 trace {A} tr := (forall x, In x tr -> @no_output_at_backup A x).
      1 trace asm_program t.
      1 trace as (A&tr&leq&_&allSmall). 1,2:eassumption.
      1 trace as (A&tr&leq&?). 1,2:eassumption.
      1 trace arround. this should follow from 
      1 trace_app_sound2 {state: Type}: forall R (tr1 tr2: trace state),
      1 trace_app_sound1 {state: Type}: forall R (tr1 tr2: trace state),
      1 trace_app_sequential2 {state: Type}: forall (tr1 tr2: trace state),
      1 trace_app_sequential1 {state: Type}: forall (tr1 tr2: trace state),
      1 trace | apply H2; exact H1 ]
      1 trace_app in tr. eauto using star. 
      1 trace_app in H2; simpl app in H2; inversion H2; subst; clear H2.
      1 trace_app {Ac: Action}: trace -> trace -> trace := @app _.
      1 trace_app a1 a2 A1 A2 :
      1 trace_app :
      1 trace and support for block *)
      1 trace_and {state: Type}: forall R1 R2 (tr: trace state),
      1 trace (A : 'M[R]_n) := \sum_i A i i.
      1 trace A [(h, inr [ReadResponse d])].
      1 trace A [(h, inr [])].
      1 trace A [(h, inl r)].
      1 trace_additive := Additive mxtrace_is_scalar.
      1 Trace_additive := Additive galTrace_is_additive.
      1 trace accumulator for induction *)
      1 trace_acc_spec {state: Type} {Ac: Action} {Res: Resource} {J: Join state} {state_R: Relation state} {Acr: Action_resource Ac Res} {nAcr: NormalAction_resource Ac Res} {ac_sem: ActionInterpret (resources * state) Ac} {AIr: ActionInterpret_resource state Ac Res ac_sem}: forall (Inv: resource * (state -> Prop) -> Prop) (tr: trace) A1 A2 s1 s2,
      1 trace_acc_spec in H3; [subst; auto |].
      1 TRACE_ACC; induction H4; intros.
      1 TRACE_ACC, H7 into Inv_r.
      1 TRACE_ACC H5 A_post.
      1 trace_access tr s' ms).
      1 trace_access _ _ (ThreadLocal_ActionInterpret_resource _ Inv) tr (A1, s1) (Terminating (A2, s2)) ->
      1 trace_access_Terminating_inv {state: Type} {Ac: Action} {ac_sem: ActionInterpret state Ac}:
      1 trace_access_Terminating: forall a tr s s' ms, state_enable a s (Terminating s') -> trace_access tr s' ms -> trace_access (cons a tr) s ms.
      1 trace_access {state: Type} {Ac: Action} {ac_sem: ActionInterpret state Ac}: trace -> state -> MetaState state -> Prop :=
      1 trace_access_NonTerminating: forall a tr s, state_enable a s NonTerminating -> trace_access (cons a tr) s NonTerminating
      1 trace_access_nil _)); simpl in RIGHT_ASSU.
      1 trace_access_nil _)); simpl in LEFT_ASSU.
      1 trace_access_nil: forall s, trace_access nil s (Terminating s)
      1 trace_access_nil _)).
      1 trace_access_Error _ _ (ThreadLocal_ActionInterpret_resource _ Inv0) _ _ _ H3)).
      1 trace_access_Error: forall a tr s, state_enable a s Error -> trace_access (cons a tr) s Error
      1 trace_access (cons a tr) s ms ->
      1 TRACE_ACC ASSU; induction tr; intros.
      1 trace {Ac: Action} (a: action): trace := cons a nil.
      1 trace A B C xs ->
      1 trace {A B C} tr :=
      1 trace A B C [(h, inr [x])].
      1 trace A B C [(h, inr [])].
      1 trace A B C [(h, inl i)].
      1 trace A B C [].
      1 trace A ((Backup, inr l) :: tr) ->
      1 trace (a1 :: A1 ++ a2 :: A2) -> pow R (S (length A1)) a1 a2.
      1 Trace a
      1 trace A [].
      1 Trace 6 8 "of".
      1 Trace 6 8.
      1 trace3).  
      1 trace2 Vundef m2''')
      1 trace2 Vundef m'),
      1 trace2trace; rewrite stream_map_empty_stream.
      1 trace2trace ctr) (lift_function snd mcs).
      1 trace2trace ctr
      1 trace2trace
      1 trace2; simpl in *; eauto; try reflexivity.
      1 trace2 m' FUN
      1 trace2 FUN
      1 trace23) as 
      1 Trace2 :
      1 trace2;*)
      1 trace2
      1 trace 2;
      1 trace1 : \tr 1%:M = n%:R. Proof. exact: mxtrace_scalar. Qed.
      1 Trace1], [subTrace2])*)
      1 trace1 : rel_trace = Events.Event_acq_rel lev1 dpm1 lev1' :: nil)
      1 trace1 mulr1n /=.
      1 trace1 _ H_a.
      1 trace1 degree_irr1.
      1 Trace1 :
      1 trace0 : \tr 0 = 0. Proof. exact: raddf0. Qed.
      1 trace0 mul0r.
      1 trace]. *)
      1 trace:=
      1 trace))))))).
      1 trace)))))))).
      1 trace))))))))).
      1 trace)))))))))).
      1 trace) :
      1 trace) 
      1 trace =>
      1 reify Σ Γ (subst [tRel 0] 0 B) ;;
      1 reify Σ Γ (subst0 [tRel 0] B) ;;
      1 Reify x := Reify' x.
      1 Reify' x := constr:(ltac:(mrun (@Reify x))).
      1 reify x))
      1 reify x :=
      1 reify_with_consts var find_const plug_const term in
      1 reify_with_consts var find_const plug_const term :=
      1 reify_with_consts find_const plug_const term in
      1 Reify_with_consts find_const plug_const term :=
      1 reify wf_reflect ].
      1 reify wf_reflect
      1 reify weak decidability 
      1 Reify v in tac rv) Denote ().
      1 Reify v) in
      1 reify var Γ f in
      1 reify var Γ e in
      1 reify var Γ e :=
      1 reify_Var {x} : reify_of x | 100 := Var x.
      1 reify var x in exact v)).
      1 reify var v in
      1 reify var uconstr:(@nil _) e in
      1 reify (var : Type) (term : nat) : M (@expr var)
      1 reify (var_tl_tag (n :: ctx) (@nat_of ctx x))
      1 reify_var_tl n ctx x
      1 reify var term; M.abs_fun var r.
      1 reify var term := Compilers.reify var term.
      1 reify var term).
      1 reify (var_tag n) (@Var nat n).
      1 reify var (rx (var NAT)) in
      1 reify var (rx (@NatExpr.Var varNAT v)) in
      1 reify var rx :=
      1 reify_var n
      1 reify (var_hd_tag (n :: ctx) n)
      1 reify_var_hd n ctx
      1 reify (var : constr) (term : constr) := reify_helper var term [].
      1 Reify.v] and [reify_plugin.ml4] for the implementation code. *)
      1 reifyValue env t :=
      1 Reify v0 in
      1 reify" v
      1 reify_type_via_reify_package package.
      1 reify_type ty := type.reify ltac:(reify_base_type) constr:(base.type) ty.
      1 reify_type ty := Compilers.reify_type ty.
      1 reify type" ty''
      1 reify_type t := (ltac:(let rt := reify_type t in exact rt)) (only parsing).
      1 reify_type_of x) x) (only parsing) : expr_scope.
      1 reify_type_of op) rop op with
      1 reify_type_of e := (reify_type ((fun t (_ : t) => t) _ e)) (only parsing).
      1 reify_TypeCode ty :=
      1 reify_TypeCode E in
      1 reify_TypeCode D in
      1 reify_TypeCode C in
      1 Reify.TypeClassesBodyHOAS.
      1 Reify.TypeClassesBodyFlatPHOAS
      1 Reify.TypeClasses
      1 reify_type :=
      1 reify ty := Compilers.reify_base_type ty.
      1 reify turns a "vplGoal lc g" into some "vplGoal (sem l m) g"
      1 reify true false (reflect true e bottom) st).
      1 reifyToTelescope H.*)
      1 reify top-level λs, we must add the [Abs] nodes
      1 Reify (to_associational (weight 51 1) 5) in
      1 reify {T} : normalized_of T -> Term var T
      1 reify t := (ltac:(let rt := reify_base_type t in exact rt)) (only parsing).
      1 reify the types *)
      1 Reify the instructions *)
      1 reify that function.  If you reified a function but forgot to
      1 reifyTerm v constr:(id ∘ f) in
      1 reifyTerm v constr:(f) in
      1 reifyTerm v constr:(f ∘ id) in
      1 reifyTerm v constr:(f ∘ g) in
      1 reify_Term var term in eexact term') : typeclass_instances.
      1 reify_Term var term
      1 reifyTerm vars _t in
      1 reifyTerm vars s in
      1 reifyTerm vars _s :=
      1 reify_Term var f in
      1 reify_Term var c in
      1 reify_Term var b in
      1 reify_Term var a in
      1 reifyTerm tt constr:(id[x]) in
      1 reify term:" term'
      1 reify_terms_and_then tacGoal :=
      1 reify_terms_and_then ltac:(fun env g => change (@exprD _ env g)).
      1 Reify (term : nat) : M Expr
      1 reify_Term_lit5 var A B C D E Rterm
      1 reify_Term_lit2 var A B Rterm
      1 reify_Term_lit1 var A Rterm
      1 reify_Term_lit0 var Rterm
      1 reify_Term_lit0 var (@Rsplit_string_for_production) in
      1 reify_Term_lit0 var (@Rchar_at_matches) in
      1 reifyTerm env t :=
      1 reifyTerm env Q in
      1 reifyTerm env P in
      1 reifyTerm cs t :=
      1 reifyTerm cs G in
      1 reifyTerm cs g in
      1 reifyTerm cs F in
      1 reifyTerm cs f in
      1 Reify term := Compilers.Reify term.
      1 reifyTerm -----------------------   2.9%   2.9%       0    0.125s
      1 Reify term).
      1 Reify term :=
      1 reifyTerm
      1 Reify.TemplateCoq.
      1 reify] tactic handles goals of the form
      1 reify) tactic3(do_reify) tactic3(post_reify) constr(n) constr(ref_PHOAS) :=
      1 Reify (sum_upto (1 * 2 + 3) (fun x => x)) in
      1 reify successor!  We might redefine [reify] as
      1 Reify (subborrowx 64) in
      1 Reify (subborrowx 51) in
      1 reify (S_tag (S (nat_of x))) (fun var => @NatS var (reified_nat_of x var)).
      1 reify (@S_tag ctx (S (@nat_of ctx x)))
      1 reify_S `{reify_of x rx}
      1 reify simple expressions of natural numbers
      1 reify_sig :=
      1 reifySHCOL dynwin_SHCOL1 100 [(BasicAst.MPfile ["DynWin"; "DynWin"; "Helix"], "dynwin_SHCOL1")] "dynwin_MSHCOL1").
      1 reifySHCOL dynwin_SHCOL1 100
      1 reifySHCOL {A:Type} (expr: A)
      1 reify_sfunction pcT stT types f in
      1 reify_sfunction pcT stT types f :=
      1 reify_sexpr s ; clear x.   *)
      1 reify_sexpr l *)
      1 reify_sexpr isConst s types funcs pcType stateType sfuncs uvars vars k :=
      1 reify_sexpr ( Ex x, Ex y, Ex z, [| x = y + z|]).  *)
      1 reify_sexpr ( Ex x: bool, [| (if x then true else false) = x|]).  *)
      1 reify_sexpr ( Ex x:bool, Ex y : nat, [| (if x then y else y) = y|]).  *)
      1 reify_sexpr ( Ex x : bool, Ex y, Ex z, [| (if x then 1 else 2) = y + z|]).  *)
      1 reify_sexpr ( Ex x:bool, Ex y : bool, [| (if x then y else false) = andb x y|]).  *)
      1 reify_sexpr (Ex x : (bool -> bool), [| x true = false |]).  *)
      1 reify_sexpr ( [| 1 + 1 = 2 |] * 0 * [| 12 = 6 + 6 |] ). *)
      1 reify_sexpr ( [| 1 + 1 = 2 |] * 0 * [| 12 = 6 + 6 |] ).  *)
      1 reify_sexpr (0 * 0 * 0).  *)
      1 reify_sexpr (0 ).  *)
      1 reify_set (X \cup Y) in
      1 reify_set E2 in
      1 reify_set E1 in
      1 reify_set E :=
      1 ReifySepExpr (Import SEP : SepExpr).
      1 reify_S ctx x
      1 Reify (scmul (weight 51 1) 5) in
      1 reify_s || apply wf_reify_d | ]
      1 Reify.Sandbox.
      1 reify_rvalue ltac:(isConst) r types funcs uvars vars ltac:(fun uvars funcs r =>
      1 reify_rvalue ltac:(isConst) l types funcs uvars vars ltac:(fun uvars funcs l =>
      1 reify_rvalue isConst r types funcs uvars vars ltac:(fun uvars funcs r =>
      1 reify_rvalue isConst r types funcs uvars vars k :=
      1 reify_rvalue isConst r2 types funcs uvars vars ltac:(fun uvars funcs r2 =>
      1 reify_rvalue isConst r1 types funcs uvars vars ltac:(fun uvars funcs r1 =>
      1 Reify_rhs) (TypeClasses.post_Reify_rhs) n refP;
      1 Reify_rhs) (TypeClassesBodyHOAS.post_Reify_rhs) n refP)
      1 Reify_rhs) (TypeClassesBodyFlatPHOAS.post_Reify_rhs) n refP
      1 Reify_rhs) (TemplateCoq.post_Reify_rhs) n refP) max_n is_flat speed.
      1 Reify_rhs _ := Reify_rhs_of ltac:(Reify) ().
      1 Reify_rhs (); reflexivity : typeclass_instances.
      1 Reify_rhs) (QuoteFlat.post_Reify_rhs) n refP) max_n is_flat speed;
      1 Reify_rhs) (Parametricity.post_Reify_rhs) n refP) max_n_reif_after_beta is_flat speed;
      1 Reify_rhs) (Parametricity.post_Reify_rhs) n refP) max_n is_flat speed;
      1 Reify_rhs_of_with_denote Reify Denote _ :=
      1 Reify_rhs_of_with_denote Reify Denote ().
      1 Reify_rhs_of Reify (); post_Reify_rhs ().
      1 Reify_rhs_of_cps_with_denote Reify_cps Denote _ :=
      1 Reify_rhs_of_cps_with_denote Reify_cps Denote ().
      1 Reify_rhs_of_cps_with_denote
      1 Reify_rhs_of_cps Reify_cps (); post_Reify_rhs ().
      1 Reify_rhs) (OCaml.post_Reify_rhs) n refP) max_n is_flat speed.
      1 Reify_rhs nat_of untag do_lock_letin do_lock_natmul :=
      1 Reify_rhs) (Mtac2.post_Reify_rhs) n refP) max_n is_flat speed.
      1 Reify_rhs _ := make_pre_Reify_rhs nat_of untag true false.
      1 Reify_rhs _ := make_pre_Reify_rhs (@nat_of nil) (@untag nil) true false.
      1 Reify_rhs _ := make_do_Reify_rhs ltac:(fun _ => Denote)
      1 Reify_rhs) (LtacTCPrimPair.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacTCGallinaCtx.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacTCExplicitCtx.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacTacInTermPrimPair.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacTacInTermGallinaCtx.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacTacInTermExplicitCtx.post_Reify_rhs) n refP;
      1 Reify_rhs) (LtacPrimUncurry.post_Reify_rhs) n refP) max_n is_flat speed.
      1 Reify_rhs) (Ltac2.post_Reify_rhs) n refP) max_n is_flat speed;
      1 Reify_rhs) (Ltac2LowLevel.post_Reify_rhs) n refP) max_n_low_level is_flat speed;
      1 Reify_rhs _ := ltac2:(do_Reify_rhs_fast ()).
      1 Reify RHS in
      1 Reify_rhs_fast: ")
      1 Reify_rhs_fast () :=
      1 Reify_rhs _ := do_Reify_rhs_of_with_denote Reify denote ().
      1 Reify_rhs _ := do_Reify_rhs_of Reify ().*)
      1 Reify_rhs _ := do_Reify_rhs_of ltac:(Reify) ().
      1 Reify_rhs denote reified_nat_of postprocess :=
      1 Reify_rhs constr:(base.type) ident ltac:(reify_base_type) ltac:(reify_ident) (@base.interp) (@ident_interp) ().
      1 Reify_rhs _ := Compilers.Reify_rhs ().
      1 Reify_rhs) (CanonicalStructuresPHOAS.do_Reify_rhs) (CanonicalStructuresPHOAS.post_Reify_rhs) n refP;
      1 Reify_rhs) (CanonicalStructuresHOAS.do_Reify_rhs) (CanonicalStructuresHOAS.post_Reify_rhs) n refP;
      1 Reify_rhs) (CanonicalStructuresFlatPHOAS.do_Reify_rhs) (CanonicalStructuresFlatPHOAS.post_Reify_rhs) n refP;
      1 Reify_rhs) (CanonicalStructuresFlatHOAS.do_Reify_rhs) (CanonicalStructuresFlatHOAS.post_Reify_rhs) n refP;
      1 Reify_rhs: ")
      1 Reify_rhs ();
      1 Reify_rhs ().
      1 Reify_rhs () :=
      1 Reify_rhs
      1 reify := reify_terms_and_then ltac:(fun env g => pose env; pose g).
      1 Reify.Reify src_n
      1 Reify.reify _)) => simple apply (@expr.Wf_reify) : wf_extra.
      1 Reify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify (machine_wordsize:Z) @ GallinaReify.Reify n @ GallinaReify.Reify nreductions)
      1 REIFY.reify_sexpr ltac:(isConst) SF typesV funcs pcT stT preds uvars vars
      1 REIFY.reify_sexpr ltac:(isConst) R typesV funcs pcT stT preds uvars vars ltac:(fun uvars funcs preds R =>
      1 REIFY.reify_sexpr ltac:(isConst) L typesV funcs pcT stT preds uvars vars ltac:(fun uvars funcs preds L =>
      1 REIFY.reify_sexpr isConst R types funcs pcType stateType preds (@nil tvar) vars ltac:(fun _uvars funcs preds R =>
      1 REIFY.reify_sexpr isConst R types funcs pcType stateType preds (@nil tvar) vars ltac:(fun _ funcs preds R =>
      1 REIFY.reify_sexpr isConst Q types funcs pc state preds (@nil type) (@nil type) ltac:(fun uvars funcs preds Q =>
      1 REIFY.reify_sexpr isConst P types funcs pc state preds (@nil type) (@nil type) ltac:(fun uvars funcs preds P =>
      1 REIFY.reify_sexpr isConst L types funcs pcType stateType preds (@nil tvar) vars ltac:(fun _uvars funcs preds L =>
      1 REIFY.reify_sexpr isConst L types funcs pcType stateType preds (@nil tvar) vars ltac:(fun _ funcs preds L =>
      1 REIFY := ReifySepExpr.ReifySepExpr SE.
      1 Reify.Reify_rhs_gen Reify prove_ExprEta_InlineConst_Linearize_Compile_correct interp_op ltac:(fun tac => tac ()).
      1 Reify.Reify_rhs_gen Reify prove_ExprEta_Compile_correct interp_op ltac:(fun tac => tac ()).
      1 Reify.Reify (Qnum src_limbwidth) @ GallinaReify.Reify (Z.pos (Qden src_limbwidth))
      1 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify n @ GallinaReify.Reify (machine_wordsize:Z) @ GallinaReify.Reify m_enc)
      1 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify n)
      1 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify n @ GallinaReify.Reify idxs @ GallinaReify.Reify x)
      1 Reify.Reify (Qnum limbwidth) @ GallinaReify.Reify (Z.pos (Qden limbwidth)) @ GallinaReify.Reify s @ GallinaReify.Reify c @ GallinaReify.Reify n @ GallinaReify.Reify idxs)%Expr.
      1 Reify.Reify (Qnum dst_limbwidth) @ GallinaReify.Reify (Z.pos (Qden dst_limbwidth))
      1 Reify.Reify N @ GallinaReify.Reify R @ GallinaReify.Reify N' @ GallinaReify.Reify (machine_wordsize:Z))
      1 Reify.Reify n)
      1 Reify.Reify [muLow;1]
      1 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify sat_limbs @ GallinaReify.Reify n @ GallinaReify.Reify m)
      1 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify sat_limbs @ GallinaReify.Reify m)
      1 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify n @ GallinaReify.Reify m @ GallinaReify.Reify m' @ GallinaReify.Reify divstep_precompmod)
      1 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify n)
      1 Reify.Reify (machine_wordsize:Z) @ GallinaReify.Reify 1 @ GallinaReify.Reify s @ GallinaReify.Reify n)
      1 Reify.Reify machine_wordsize @ GallinaReify.Reify n @ GallinaReify.Reify m @ GallinaReify.Reify m')%Expr.
      1 Reify.Reify M
      1 Reify.Reify [M])
      1 REIFY.reify_hints unfoldTac pcT stateT isConst bwd types funcs preds ltac:(fun funcs preds bwd' => (
      1 REIFY.reify_hints unfoldTac pcT stateT isConst bwd types funcs preds ltac:(fun funcs preds bwd' =>
      1 REIFY := ReifyHints.Make UNF.LEM.
      1 Reify.Reify dst_n)
      1 reify := (@reify base.type ident var abstract_domain' annotate bottom').
      1 reify := (@reify base_type ident _ abstract_domain' annotate bottom').
      1 reify := (@reify base.type ident _ abstract_domain' annotate bottom').
      1 Reify.Reify_as _ _)) => simple apply (@expr.Wf_Reify) : wf_extra.
      1 Reify.Reify_as GallinaReify.reify type_base] in *;
      1 Reify.Reify_as GallinaReify.reify type_base].
      1 Reify.Reify_as GallinaReify.base.reify : wf_extra interp_extra.
      1 Reify.Reify_as _ _) ] => apply expr.Wf_Reify_as
      1 Reify.Reify 1%nat
      1 reify) (@reflect) (@type.interp) (@type.related) (@type.related_hetero) in *
      1 reify reflect] in *; fold (@reify) (@reflect) in *.
      1 reify reflect] in *; cbv [Let_In] in *.
      1 reify reflect] in *.
      1 reify reflect fst snd UnderLets.interp ident_interp related_bounded_value abstract_domain value].
      1 reify_rec term :=
      1 reify_rec term
      1 reify_rec (let (x, _) := ev in x)
      1 reify_rec (let (_, x) := ev in x)
      1 reify_rec (fun dummy : unit => v) in
      1 reify_rec body in
      1 reify_rec
      1 reify _ r)).
      1 reify _ r)))
      1 Reify.QuoteFlat.
      1 reify quantified formulas of natural numbers
      1 REIFY.prove fwd | HINTS_REIFY.prove bwd ])) ;
      1 REIFY.prove fwd | HINTS_REIFY.prove bwd ]
      1 reify_ [Prop] into
      1 reify_preprocess_extra term ::=
      1 Reify P in
      1 reify (part_semantics2 g)); eauto.
      1 Reify P :=
      1 reify (O_tag ctx 0) (fun var _ _ => @NatO var).
      1 reify (O_tag 0) (@NatO).
      1 reify_option {t} v
      1 reify_option retv))
      1 reify_option option_rect UnderLets.splice_option] in *
      1 reify_option option_rect] in *
      1 reify_option base.type.base base.base_interp ident ident.buildIdent (@ident.interp) ident.buildInterpIdentCorrect t v.
      1 reify_of y (Var ry) -> reify_of (f y) (rf ry)}
      1 reify_of (x * y) (rx * ry).
      1 reify_of x).
      1 reify_of var x _)) in
      1 reify_of var x _) in
      1 reify_of - ! : typeclass_instances.
      1 reify_of - ! - : typeclass_instances.
      1 reify_of ! : typeclass_instances.
      1 reify_of (term : nat) := rterm : @expr var.
      1 reify_of (term : nat) (rterm : @expr var) := {}.
      1 reify_of (term : nat) := rterm : @expr nat.
      1 reify_of (S x) (NatS rx).
      1 reify_of _ (@?rx var) => rx
      1 reify_of _ ?rx => rx
      1 Reify_of reify x :=
      1 reify_of O NatO.
      1 reify_of (f y)}
      1 reify_of (dlet y := x in f y) := (elet ry := rx in rf ry)%expr.
      1 reify_of (dlet y := x in f y) (elet ry := rx in rf ry).
      1 reify_O ctx
      1 Reify.OCamlReify.
      1 Reify.OCaml.
      1 reifyObj v constr:(y) in
      1 reifyObj cs o :=
      1 reifyObj (C : Category) (y z : C) (f : y ~> z) : True.
      1 reify_norm_type_of v) v)
      1 reify_norm_type_of e := (reify_norm ((fun t (_ : t) => t) _ e)) (only parsing).
      1 reify_norm t := (ltac:(let t' := eval cbv in t in let rt := reify_base_type t' in exact rt)) (only parsing).
      1 reify_norm_base_type_of e := (reify_norm_base ((fun t (_ : t) => t) _ e)) (only parsing).
      1 reify_norm_base t := (ltac:(let t' := eval cbv in t in let rt := reify_base t' in exact rt)) (only parsing).
      1 reify { nat_of : tagged_nat ; reified_nat_of :> Expr }.
      1 reify { nat_of : tagged_nat ctx ;
      1 reify_NatMul `{reify_of x rx, reify_of y ry}
      1 reify [Nat.mul];
      1 reify [nat]
      1 Reify (mulx 64) in
      1 reify (@mul_tag ctx (@nat_of ctx x * @nat_of ctx y))
      1 Reify ((mulmod machine_wordsize n m m')) in
      1 reify_mul ctx x y
      1 Reify.Mtac2.
      1 ReifyMSHCOL.
      1 reifyMSHCOL
      1 reify mentioned in that
      1 reify (meaning term).
      1 reifyMapTerm env t :=
      1 reify_lvalue isConst l types funcs uvars vars k :=
      1 Reify.LtacTCPrimPair Reify.LtacTCGallinaCtx Reify.LtacTCExplicitCtx
      1 Reify.LtacTacInTermPrimPair Reify.LtacTacInTermGallinaCtx Reify.LtacTacInTermExplicitCtx.
      1 Reify.LtacPrimUncurry.
      1 Reify.Ltac2 Reify.Ltac2LowLevel.
      1 reify_loc isConst l types funcs uvars vars k :=
      1 reify_list xs)
      1 reify_list {var} (ls : list (expr (var:=var) NAT)) : expr (var:=var) (LIST NAT)
      1 reify_list var))).
      1 reify_list {t} v
      1 reify_list _)] |- _ ] => rewrite expr.interp_reify_list in H
      1 Reify (List.map (fun x => x * x) (1 :: 2 :: 3 :: nil)) in
      1 reify_list in H
      1 reify_list base.type.base base.base_interp ident ident.buildIdent (@ident.interp) ident.buildInterpIdentCorrect t v.
      1 reify_list _ |- _ ] => apply (f_equal (expr.interp (@ident_interp))) in H
      1 reify_list _)] |- _ ]
      1 reify_let_in v f
      1 reify (let_in_tag (nllet x := untag (nat_of v) in nat_of (f x)))
      1 reify (letin_tag
      1 reify_LetIn `{rx : reify_of x}
      1 reify_LetIn `{reify_of x rx}
      1 reify_letin ctx v f
      1 reify its arguments, coq will tell you that the reified function
      1 reify it, and apply [tautTrue] to the reified
      1 reify interp_reflect;
      1 reify interp_reflect
      1 reify_instrs ltac:(isConst) i types funcs uvars vars ltac:(fun uvars funcs sis =>
      1 reify_instrs isConst is types funcs uvars vars ltac:(fun uvars funcs is =>
      1 reify_instrs isConst is types funcs uvars vars k :=
      1 reify_instr isConst i types funcs uvars vars ltac:(fun uvars funcs i =>
      1 reify_instr isConst i types funcs uvars vars k :=
      1 reifying the goal. *)
      1 reifying the expression [1 + 2], either [O],
      1 reifying the effect of a tactic. *)
      1 reifying the
      1 reifying [nat] expressions.  We might write: *)
      1 reifying ([gO], [gS], [gNatMul], [gLetIn]) and over Ltac2
      1 reifying [F]. *)
      1 reifying [eapply] *)
      1 Reifying.20terms.20with.20ltac.20.2F.20if-then-else.20.2F.20complex.20match *)
      1 ReifyIL.
      1 reify_ident_via_reify_package package.
      1 reify_ident_preprocess_extra term ::=
      1 reify_ident :=
      1 reify_hints unfoldTac pcType stateType isConst Ps types funcs preds k :=
      1 reify_hints unfoldTac pcType stateType isConst P2 types funcs preds ltac:(fun funcs preds P2 =>
      1 reify_hints unfoldTac pcType stateType isConst P1 types funcs preds ltac:(fun funcs preds P1 =>
      1 reify_hints unfoldTac pcT stateT isConst fwd types funcs preds ltac:(fun funcs preds fwd' =>
      1 reify_hints unfoldTac pcT stateT isConst bwd types funcs preds ltac:(fun funcs preds bwd' =>
      1 reify_hint' pcType stateType isConst P types funcs preds vars ltac:(fun funcs preds P =>
      1 reify_hint' pcType stateType isConst P types funcs preds vars k :=
      1 reify_hint' pcType stateType isConst P types funcs preds vars k
      1 reify_hint pcType stateType isConst P types funcs preds vars k :=
      1 reify_hint pcType stateType isConst P types funcs preds (T' :: vars) k
      1 reify_hint pcType stateType isConst (fun _ : ReifyExpr.VarType unit => T) types funcs preds (@nil tvar) ltac:(fun funcs preds P =>
      1 reify_helper y ctx;
      1 reify_helper v ctx;
      1 reify_helper {var : Type} (term : nat)
      1 reify_helper var term ctx in
      1 reify_helper var fx ctx in
      1 reify_helper var c ctx in
      1 reify_helper term var_context.nil.
      1 reify_helper (term : nat)
      1 reify_helper fx (var_context.cons x vx ctx);
      1 reify_helper : @expr var.
      1 reify_helper_cls (var : Type) (term : nat)
      1 reify_helper_cls ?var ?term ?ctx ]
      1 reify_helper_cls _ _ _)
      1 reify_helper_cls
      1 reify_helper a b z d :=
      1 reify_helper a' b' (Binary Eplus a' (Unary Eopp b')) fct
      1 reify_helper a' b' (Binary Eplus a' b') fct
      1 reify_helper a' b' (Binary Emult a' (Unary Einv b')) fct
      1 reify_helper a' b' (Binary Emult a' b') fct
      1 reify_has_parse p ltac:(fun r => exact r).
      1 reify_has_parse has_parse cont :=
      1 Reify_goal.
      1 Reify_goal :=
      1 Reify g in
      1 reify_gen_cache wf_gen_cache.
      1 reify_gen_cache discriminated.
      1 Reify (fun y : list Z => repeat y 2) in
      1 Reify (fun y : (list Z * list Z)
      1 Reify (fun y : (list Z) => List.nth_default (-1) y 0) in
      1 Reify (fun y : list Z => (hd 0%Z y, tl y)) in
      1 Reify (fun x y => x * x * y * y) in
      1 Reify (fun x y => (fun f a b => f a b) (fun a b => a + b) (x + y) (x * y))%Z in
      1 reify ((fun x => pow x n) f) nb
      1 Reify ((fun x => 2^x) 255)%Z in
      1 Reify (fun (f : Z -> Z -> Z) x y => f (x + y) (x * y))%Z in
      1 Reify (fun f g => mulmod (weight 51 2) (2^255) [(1,19)] 10 f g) in
      1 Reify (fun f g => mulmod (weight 51 1) (2^255) [(1,19)] 5 f g) in
      1 Reify (fun f (g : list Z)
      1 Reify (fun (f g : list Z)
      1 Reify ((fun f g => dlet _ := ident.comment ("foo", f, g) in carry_mulmod limbwidth_num limbwidth_den s c n idxs f g)) in
      1 Reify (fun f => carry_mulmod 51 1 (2^255) [(1,19)] 5 (seq 0 5 ++ [0; 1])%list%nat f f) in
      1 Reify (fun f
      1 reify_function types f in
      1 reify_function types f :=
      1 reify function" f
      1 reify_function except that it works on separation logic functions.
      1 Reify (fun a b
      1 reify f (S nb) in
      1 reify (f (reflect (RVar x))))
      1 reify f O in
      1 reify_float_expr constr:([_x]) f_model in exact e').
      1 reify_first_order; eauto.
      1 reify_first_order
      1 reify fct nb :=
      1 reify_faster_2arg _ :=
      1 reify_faster_1arg _ :=
      1 reify_faster_1arg (). *)
      1 reify_faster _ :=
      1 reifyExpr v constr:(f ≈ f ∘ id) in
      1 ReifyExpr.VarType unit => T) types k
      1 ReifyExpr.VarType (T * unit) => B (@openUp _ T (@fst _ _) x)) in
      1 ReifyExpr.VarType T => B (@openUp _ T (fun x => x) x)) in
      1 reifyExpr tt constr:(True ∨ True) in
      1 reifyExpr tt constr:(True ∧ True) in
      1 reifyExpr tt constr:(True → True) in
      1 reifyExpr tt constr:(True) in
      1 reifyExpr tt constr:(False) in
      1 reify_expr (test_dep 1 true).
      1 reify_expr (test_dep_0 1 true).
      1 reify_exprs isConst es types funcs uvars vars k :=
      1 ReifyExpr.reify_expr ltac:(isConst) sp_v typesV funcs uvars vars ltac:(fun uvars funcs sp_v =>
      1 ReifyExpr.reify_expr ltac:(isConst) rv_v typesV funcs uvars vars ltac:(fun uvars funcs rv_v =>
      1 ReifyExpr.reify_expr ltac:(isConst) rp_v typesV funcs uvars vars ltac:(fun uvars funcs rp_v  =>
      1 ReifyExpr.reify_expr isConst H types funcs (@nil tvar) vars ltac:(fun _ funcs H =>
      1 reify_expr (Regs st Rp). *)
      1 ReifyExpr.reflectType types T' in
      1 ReifyExpr.openUp _ T (@snd _ _) x) (@ReifyExpr.openUp _ T' (@fst _ _) x)) in
      1 ReifyExpr.openUp _ T (@fst _ _) x) (@ReifyExpr.openUp _ T' (@snd _ _) x)) in
      1 reify_expr isConst e types funcs uvars vars k :=
      1 reify_expr isConst a types funcs uvars vars ltac:(fun uvars funcs a =>
      1 reify_expr (fun x => negb (negb x) = x). *)
      1 reify_expr (fun (x : nat )=> x).  *)
      1 reify_expr (fun n => n + n = n + n).  *)
      1 reify_expr (forall (x : bool), x = x).  *)
      1 ReifyExpr.extend_all_types Ts types in
      1 reifyExpr cs t :=
      1 reifyExpr cs G in
      1 ReifyExpr.collectTypes_exprs ltac:(isConst) regs Ts ltac:(fun Ts =>
      1 ReifyExpr.collectTypes_expr ltac:(isConst) H types ltac:(fun types =>
      1 ReifyExpr Bedrock.ReifySepExpr Bedrock.ReifyHints.
      1 reify_expr ((1 + 3 = 2 + 2) -> False).  *)
      1 reify_expr (1 + 3 = 2 + 2).  *)
      1 reify_expr (1 + 3).  *)
      1 reify_expr ((1 + 1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 +1 + 3 = 2 + 2) -> False).  *) *)
      1 reify_expr (1). *)
      1 ReifyExpr.  *)
      1 reifyExpr
      1 Reify.Exports.
      1 Reify. (* export for the instances for recursing under binders *)
      1 Reify exp in
      1 reify (empty_ext []) gamma Mphi with
      1 reify (empty_ext _) gamma Mphi); try exact (notSolvable _).
      1 reify (empty_ext []) gamma Mphi); try exact (notSolvable _).
      1 reify (empty_ext empty_global_env) gamma Mphi with
      1 reify; eauto. }
      1 reify; eauto.
      1 reify; [ eapply wf_reflect | ]; eauto; apply bottom_Proper.
      1 reify each and change the goal to refer to the reified versions, finishing
      1 reify do_reify post_reify n ref_PHOAS :=
      1 Reify_cps v ltac:(
      1 Reify_cps term ltac:(fun rt => tac (rt var)).
      1 reify_correct : forall t v r,
      1 reify_correct.
      1 reify constr:(base.type) ident ltac:(reify_base_type) ltac:(reify_ident) var term.
      1 Reify constr:(base.type) ident ltac:(reify_base_type) ltac:(reify_ident) term.
      1 reify := Compilers.reify_ident.
      1 ReifyCommon.error_cant_elim_deps e
      1 Reify (combine [1; 2] [1; 2]) in
      1 REIFY.collectTypes_sexpr ltac:(isConst) SF Ts k
      1 REIFY.collectTypes_sexpr ltac:(isConst) R Ts ltac:(fun Ts =>
      1 REIFY.collectTypes_sexpr ltac:(isConst) L Ts ltac:(fun Ts =>
      1 REIFY.collectTypes_sexpr isConst Q rt ltac:(fun rt =>
      1 REIFY.collectTypes_sexpr isConst P (@nil Type) ltac:(fun rt =>
      1 REIFY.collectTypes_hints unfoldTac isConst fwd (Reflect.Tnil) ltac:(fun Ts =>
      1 REIFY.collectTypes_hints unfoldTac isConst fwd (Reflect.Tnil) ltac:(fun rt =>
      1 REIFY.collectTypes_hints unfoldTac isConst bwd Ts ltac:(fun Ts => (
      1 REIFY.collectTypes_hints unfoldTac isConst bwd rt ltac:(fun rt =>
      1 Reify (cmovznz 64) in
      1 reify_cls var f)
      1 reify_cls
      1 Reify ((carry_mulmod limbwidth_num limbwidth_den s c n []%nat)) in
      1 Reify ((carry_mulmod limbwidth_num limbwidth_den s c n idxs)) in
      1 Reify.CanonicalStructuresPHOAS.
      1 Reify.CanonicalStructuresHOAS
      1 Reify.CanonicalStructuresFlatPHOAS
      1 Reify.CanonicalStructuresFlatHOAS
      1 reify_cache_gen nocore ] ];
      1 Reify.BenchmarkUtil. (* don't qualify BenchmarkUtil.big when naming it *)
      1 Reify.BenchmarkUtil.
      1 reify_base_via_reify_package package.
      1 reify_base_type_via_reify_package package.
      1 reify_base_type_of x) x) (only parsing) : ident_scope.
      1 reify_base_type_of e := (reify_base ((fun t (_ : t) => t) _ e)) (only parsing).
      1 reify_base_type :=
      1 reify_base ty := Compilers.reify_base ty.
      1 reify_base t := (ltac:(let rt := reify_base t in exact rt)) (only parsing).
      1 Reify.base.reify _)) => simple apply (@expr.Wf_base_reify) : wf_extra.
      1 Reify.base.reify ident.ident_Literal ident.buildIdent] in *; hammer; intros; inversion_option; (simplify_ident; [ ]).
      1 Reify.base.reify ident.ident_Literal ident.buildIdent] in *
      1 Reify.base.Reify_as _ _)) => simple apply (@expr.Wf_base_Reify) : wf_extra.
      1 Reify.BaselineStats.
      1 Reify.base.
      1 reify_base :=
      1 Reify] available, it is easy to finish our reflective tactic.  We
      1 reify_aux fct (Nil expr) O with
      1 reify_aux fct l i :=
      1 reify; assumption.
      1 Reify_as expr.Wf_base_Reify_as expr.Wf_reify expr.Wf_base_reify : wf_extra.
      1 Reify_as @expr.interp_reify @expr.interp_reify_list @expr.interp_reify_option @expr.Interp_reify @expr.Interp_APP : interp_extra.
      1 Reify_as Compilers.base base_interp ident buildIdent (reify_type_of v) (fun _ => v)) (only parsing).
      1 Reify_as Compilers.base base_interp ident buildIdent (base.reify_type_of v) (fun _ => v)) (only parsing).
      1 Reify_as base.type.base base.base_interp ident ident.buildIdent (@ident.interp) ident.buildInterpIdentCorrect t v.
      1 reify_args_for_apply6 reify_Term var ret x y z a b c :=
      1 reify_args_for_apply6 reify_Term var ret x y z a b c
      1 reify_args_for_apply3 reify_Term var ret x y z :=
      1 reify_args_for_apply2 reify_Term var ret x y*)
      1 reify_args_for_apply2 reify_Term var ret x y :=
      1 reify_args_for_apply1 reify_Term var ret x :=
      1 reify_args_for_apply0 reify_Term var ret :=
      1 reify) args.
      1 reify; apply formula_sound; vm_compute; auto.
      1 reify annotate_with_state true (* this forces a let-binder here *) x' tt;
      1 reify annotate_with_state is_let_bound t e b_in))) arg1)).
      1 reify annotate_with_state is_let_bound t e b_in))) arg1))
      1 reify annotate_with_state is_let_bound s) as interp_reify_s;
      1 reify annotate_with_state is_let_bound d) as interp_reify_d;
      1 reify annotate_with_state false s v bottom_for_each_lhs_of_arrow);
      1 reify annotate_with_state false G s) as wf_reify_s;
      1 reify annotate_with_state false G d) as wf_reify_d;
      1 reify annotate_with_state false _ fx dv)))
      1 reify annotate_with_state false e' st).
      1 reify annotate_with_state false (base.type.list T) ls_arg tt;
      1 reify (annotate_with_state : bool) (is_let_bound : bool) {t} : value t -> type.for_each_lhs_of_arrow abstract_domain t -> UnderLets (@expr var t)
      1 reify (annotate_with_state : bool) (is_let_bound : bool) G {t}
      1 reify annotate_Proper type_base bottom'_Proper.
      1 reify an expression into a syntax tree
      1 reify and what we don't. *)
      1 reify and types that we
      1 reify_and_reflect_correct : forall t,
      1 reify_and_reflect_correct; firstorder.
      1 reify_and_reflect_correct; assumption.
      1 reify_and_let_binds_base_cps _ _ _ _) in (value of k).
      1 reify_and_change :=
      1 reify_and_change
      1 reify and apply things
      1 reify a nb in reify_aux f (e :: l) (S i)
      1 reify a multiplication, though, we get
      1 Reify (addcarryx 64) in
      1 Reify (addcarryx 51) in
      1 reify a computable binary relation representing a unary function
      1 reify a
      1 reify5 (types)" (Rterm, A, B, C, D, E)
      1 reify5" (Rterm, A', B', C', D', E')
      1 reify2" (Rterm, A, B)
      1 reify2 := (@reify base_type ident var2 abstract_domain' annotate2 bottom').
      1 reify2) (@reflect2) (@reify1) (@reflect1).
      1 reify1 _ _ _ _) _) (UnderLets.splice (reify2 _ _ _ _) _) ]
      1 reify1" Rterm
      1 reify1 := (@reify base_type ident var1 abstract_domain' annotate1 bottom').
      1 reify1 annotate_with_state is_let_bound t v1 s1) (@reify2 annotate_with_state is_let_bound t v2 s2)
      1 Reify (1 * 2 + 3) in
      1 reify0" Rterm
      1 reify. 
      1 reify' :=
      1 reify".
      1 reify |
      1 reify _ _ _ _))) _ ]
      1 reify _ :=
      1 reify *)
      1 profile to see if there are any perf implications *)
      1 Profile.progseq __FILE__ __LINE__". *)
      1 profile-ltac") -*- *)
      1 Profiled X -> X := @snd _ _.
      1 Profiled T x) = 0.
      1 Profiled T) (b: T -> SimplyProfiled U):
      1 Profiled q l))) <= length l.
      1 Profiled q l).
      1 Profiled p l)...
      1 Profiled p l).
      1 Profiled p l))) +
      1 Profiled) nil
      1 Profiled: Monad := MonoidMonadTrans.M NatAddMonoid IdMonad.ext.
      1 Profiled monad: *)
      1 Profiled) (lower ++ pivot :: upper)
      1 Profiled (list T)) with
      1 Profiled (list T)) => cost r <= sqrd (length l)).
      1 Profiled (list T)) :=
      1 profiled_leb (x y: nat): SimplyProfiled bool := (1, leb x y).
      1 profiled_leb numbers.
      1 Profiled in H.
      1 Profiled (gt SimplyProfiled counted_cmp t) x)).
      1 Profiled (gt SimplyProfiled counted_cmp pivot) t;
      1 Profiled_ext: extMonad SimplyProfiled.
      1 Profiled_ext.
      1 Profiled_ext)...
      1 Profiled (counted_cmp t) x)).
      1 Profiled counted_cmp t) (counted_cmp_excl t) x).
      1 Profiled (counted_cmp pivot) t;
      1 Profiled comparison := (1%nat, Ecmp _ x y).
      1 Profiled bool := (1, le x y).
      1 Profiled bool := (1, cmp x y). (* lift *)
      1 Profiled bool):
      1 Profiled bool)
      1 Profiled.
      1 Profile CutOff 0. (*Old: 0.579 total, 81% in inversion; New: 0.329s, 75% in inversion, but only 1/3 of nversion calls have been converted to using inversion lemmas.  *)*)
      1 Print Z.zselect.
      1 print x) = x.
      1 Print x ;; ret tt. *)
      1 Print x2.
      1 Print __x1_write.
      1 Print X'.
      1 Print x.
      1 Print x)).
      1 Print x >>=
      1 print_w X)
      1 print_w ?X ] |- _ ] =>
      1 print_w WriteByte (explode s) p v m.
      1 print_w, ReadByte, WriteByte. intros stn m m' k v.
      1 print_w, ReadByte, WriteByte; intros.
      1 print_w ReadByte (implode s) a m.
      1 print_w p) as [ [ [ ? ? ] ? ] ? ].
      1 print_w (p : addr) : addr * addr * addr * addr :=
      1 print_w p).
      1 print_w mem_set e p v m = Some m'
      1 print_w mem_get i p m' = Some v.
      1 print_w. inversion 1. clear.
      1 print_w in H4.
      1 print_w in *.
      1 print_w H.mem_set p0 p v m =
      1 print_when_fail :=
      1 print_when_fail
      1 print_w (a : W) := (a, a ^+ $1, a ^+ $2, a ^+ $3).
      1 print_w a) as [ [ [ ] ] ].
      1 print_w
      1 Print vvᵗ.
      1 Print vrev'ᵗ.
      1 print v in
      1 Print vectorspace.
      1 Print "variable already exists, not defining"
      1 Print use_mux_mut_refs__tuple_fun. *)
      1 Print "UnSafeCast" ;;
      1 Print unq >>= fun _ =>
      1 Print UnOp.
      1 Print Unnamed_thm1. *)
      1 Print Unnamed_thm0. *)
      1 Print univ_foo_back.
      1 Print univ_foo.
      1 print_universe u :=
      1 print_universe s
      1 print_unfold in e5.
      1 print_unfold in e2.
      1 print_unfold in e13.
      1 print_unfold.
      1 print" uconstr_list_sep(l, ",") :=
      1 Print typing_abs.
      1 Print typing.
      1 print_type_vars tvars, print_box_type Σ (todo "") tvars bt).
      1 print_type_vars tvars,
      1 print_type_vars (l : list name) :=
      1 print_type_scheme (p : Ast.Env.program) : string * string :=
      1 print_type_scheme ex9 = ("T n", "𝕋").
      1 print_type_scheme ex8 = ("T _", "t (option T) 𝕋").
      1 print_type_scheme ex7 = ("T n", "t (option T) 𝕋").
      1 print_type_scheme ex6 = ("T", "option T").
      1 print_type_scheme ex5 = ("_", "anon_list _").
      1 print_type_scheme ex4 = ("A", "list A").
      1 print_type_scheme ex3 = ("T", "list T").
      1 print_type_scheme ex2 = ("", "list nat").
      1 print_type_scheme ex1 = ("", "nat").
      1 print_type_of
      1 print_type n ++ ")")%string.
      1 print_type (n : name_with_type) : string
      1 print_type id ex9 =
      1 print_type id ex8 =
      1 print_type id ex7 =
      1 print_type id ex6 =
      1 print_type id ex5 =
      1 print_type id ex4 =
      1 print_type id ex3 =
      1 print_type id ex28 =
      1 print_type id ex27 = ("", "idT nat → idT nat").
      1 print_type id ex26 =
      1 print_type id ex25 =
      1 print_type id ex24 =
      1 print_type id ex23 =
      1 print_type id ex22 =
      1 print_type id ex21 =
      1 print_type id ex20 =
      1 print_type id ex2 =
      1 print_type id ex19 =
      1 print_type id ex18 =
      1 print_type id ex17 =
      1 print_type id ex16 =
      1 print_type id ex15 =
      1 print_type id ex14 =
      1 print_type id ex13 =
      1 print_type id ex12 =
      1 print_type id ex11 =
      1 print_type id ex10 =
      1 print_type id ex1 =
      1 print_type e := first [ let x := type of e in idtac x | idtac "Untyped:" e ].
      1 Print typecheck_environ.
      1 print_type
      1 print t with view_app_construct t := {
      1 print (T : Type) (x : forall y : T, Type) (h : o = m) (w : T) :
      1 Print t ;; this print slows complilation down *)
      1 print (t : term) : term × list term
      1 Print ("Trying to unfold constant" ++ cname) ;;
      1 Print true_galore'.
      1 Print tree.
      1 Print tree'.
      1 Print totoᵗ.
      1 Print Topology.
      1 Print] to peek at the ones we already defined!). *)
      1 Print =<< tm_double 5000).
      1 Print =<< tm_double 4000).
      1 Print =<< tm_double 3000).
      1 Print =<< tm_double 2000).
      1 Print =<< tm_double 1000).
      1 Print ("tmDependentArgs not supported");;*)ret 0
      1 Print ("tmDependentArgs currently assumes that abstractions on head position mean there are no parametric arguments");;*)ret 0
      1 Print tm_ack. *) *)
      1 Print tm'.
      1 print t := let t' := (eval lazy in t) in idtac t'.
      1 print this marker as [end defer], to informally indicate to the user that
      1 Print This.Is.A.Long.Namespace.stuff. (* = 2 *)
      1 Print This.Is.A.Long.Namespace.stuff. (* = 1 *)
      1 Print This.
      1 print things in Ltac2, using tools from the Message library. *)
      1 print the type of an expression.  We can also use [Check] to ask
      1 print these syntax
      1 print the proof it generates that 256 is even.  The final proof term has
      1 print them out: *)
      1 print the input bounds at the end; they're very relevant *) syntax_tree)%list
      1 Print the function. *)
      1 print the Elpi and Coq proof state,
      1 Print the base type of [finType] in the Canonical Structure. *)
      1 Print the base type of [eqType] in the Canonical Structure. *)
      1 Print test_typecheck_in_ctx.
      1 Print test_sum_impl__tuple_fun. *)
      1 Print test_result__tuple_fun. *)
      1 Print testFun.
      1 printTestCase (String.append (Show.show a) newline) (c a))).
      1 printTestCase str c) s <-> semCheckableSize c s.
      1 printTestCase str c) <-> semCheckable c.
      1 printTestCase (show' x') (pf x'))).
      1 printTestCase (show x ++ newline) (pf x H)).
      1 printTestCase (show x ++ newline) (pf x)).
      1 printTestCase (show x ++ newline) (pf x)
      1 printTestCase semCallback_idSize.
      1 printTestCase semCallback_id.
      1 printTestCase {prop : Type} `{Checkable prop}
      1 PrintTestCase_idSize {C} `{Checkable C} (str : String.string) (c : C) s :
      1 PrintTestCase_idSize. by auto.
      1 PrintTestCase_idSize. by apply H'.
      1 PrintTestCase_idSize. *)
      1 PrintTestCase_id {C} `{Checkable C} (str : String.string) (c : C) :
      1 printTestCase {A C} `{Checkable C} `{Show A} (c : A -> C) :
      1 print_term Σ Γ true false t.
      1 print_term Σ Γ' (tProj p' c') ^
      1 print_term Σ Γ' (tProj p' c') ++
      1 print_term Σ Γ (tProj p c) ^
      1 print_term Σ Γ (tProj p c) ++
      1 print_term Σ Γ top := Tree.to_string ∘ PrintTermTree.print_term Σ true Γ top.
      1 print_term Σ Γ t' ^ nl ^ "and:" ^ nl ^ print_term Σ Γ u' ^
      1 print_term Σ Γ t' ++ "\nand:\n" ++ print_term Σ Γ u' ++
      1 print_term Σ Γ' (tFix mfix' idx) ^
      1 print_term Σ Γ' (tFix mfix' idx) ++
      1 print_term Σ Γ' (tFix mfix' idx') ^
      1 print_term Σ Γ' (tFix mfix' idx') ++
      1 print_term Σ Γ' (tFix (mfix1' ++ v :: mfix2')%list idx) ++
      1 print_term Σ Γ' (tFix (mfix1' ++ v :: mfix2') idx) ^
      1 print_term Σ Γ (tFix (mfix1 ++ u :: mfix2)%list idx) ++
      1 print_term Σ Γ (tFix (mfix1 ++ u :: mfix2) idx) ^
      1 print_term Σ Γ' (tCoFix mfix' idx) ^
      1 print_term Σ Γ' (tCoFix mfix' idx') ^
      1 print_term Σ Γ' (tCoFix mfix' idx') ++
      1 print_term Σ Γ (tCoFix mfix idx) ++
      1 print_term Σ Γ' (tCoFix (mfix1' ++ v :: mfix2') idx) ^
      1 print_term Σ Γ (tCoFix (mfix1 ++ u :: mfix2) idx) ^
      1 print_term Σ Γ' (tCase (ind, par) p' c' (brs1' ++ (m',br') :: brs2')) ++
      1 print_term Σ Γ (tCase (ind, par) p c (brs1 ++ (m,br) :: brs2)) ++
      1 print_term Σ Γ' (tCase (ind', par') p' c' brs') ++
      1 print_term Σ Γ (tCase (ind, par) p c brs) ++
      1 print_term Σ Γ (decl_type decl)
      1 print_term Σ Γ br' ++
      1 print_term Σ Γ br ++
      1 print_term Σ Γ body
      1 print_term Σ Γ A ++ " is not an arity"))
      1 print_term Σ Γ2 (tProd na' A2 B2) ++
      1 print_term Σ Γ2 (tLambda na' A2 t2) ++
      1 print_term Σ Γ1 (tProd na A1 B1) ++
      1 print_term Σ Γ1 (tLambda na A1 t1) ++
      1 print_term Σ' with_universes nil true cb.(cst_type) ^
      1 print_term Σ' with_universes nil true b ^ "." ^ nl)
      1 print_term Σ true Γ top false).
      1 print_term Σ' true nil true false cb.(cst_type) ^
      1 print_term Σ' true nil true false b ^ "." ^ nl)
      1 print_term Σ true ids true false t.
      1 print_term Σ [] true false t.
      1 print_term Σ [] t ^ nl ^
      1 print_term Σ [] t ^ " is not an arity"
      1 print_term Σ [] t'
      1 print_term (Σ : global_env) (t : term) : bytestring.String.t :=
      1 print_term Σ all Γ top inapp t :=
      1 print_term Γ true ty ^ ")"))
      1 print_term Γ true ty ^ " := " ^
      1 print_term Γ true t ^
      1 print_term Γ true false ty ^ ")")%bs)
      1 print_term Γ true false ty ^ " := " ^
      1 print_term Γ true false dom ^ ", " ^ print_term (na':: Γ) true false codom)
      1 print_term Γ true false dom ^
      1 print_term Γ true false b ^ ")")%bs)
      1 print_term Γ true dom ^
      1 print_term Γ true def ^ " in " ^ nl ^
      1 print_term Γ true c ^ ":"  ^ print_term Γ true t)
      1 print_term Γ true c.2.
      1 print_term Γ true c ^ ")"
      1 print_term Γ true b ^ ")"))
      1 print_term Γret true (preturn p) ^
      1 print_term Γret true false (preturn p) ^
      1 print_term Γpars true oie.(mind_entry_arity) ^ ":=" ^ nl ^
      1 print_term (Γ : list ident) (top : bool) (t : term) {struct t} : Tree.t :=
      1 print_term (Γ : list ident) (top : bool)(inapp : bool) (t : term) {struct t} : Tree.t :=
      1 print_term Γinds true (tSort oib.(ind_sort)) ^ ":=" ^ nl ^
      1 print_term Γ false f ^ " " ^ print_list (print_term Γ false) " " l)
      1 print_term Γ false dom ^ ", " ^ print_term (na' :: Γ) true codom)
      1 print_term Γ false dom ^ " → " ^ print_term (na' :: Γ) true codom)
      1 print_term Γ false c ^ ".(" ^ pdecl.(proj_name) ^ ")"
      1 print_term Γctx true false br.(bbody)) brs in
      1 print_term (Γ : context) (top : bool) (inapp : bool) (t : term) {struct t} : Tree.t :=
      1 PrintTermTree.pr Σ.
      1 PrintTermTree.print_term Σ all Γ top inapp t).
      1 PrintTermTree.print_program true short prefix p).
      1 PrintTermTree.print_program short prefix p).
      1 PrintTermTree.print_env true short prefix Σ).
      1 PrintTermTree.print_env short prefix Σ).
      1 PrintTermTree.print_context_gen Σ (PrintTermTree.print_term Σ true) Γ Δ).2.
      1 print_term (p.1, Monomorphic_ctx) [] true p.2 in
      1 print_term (p.1, Monomorphic_ctx) [] true (eta_expand p.1.(declarations) [] p.2) in
      1 print_term (na':: Γ) true false body)
      1 print_term (na' :: Γ) true false body)
      1 print_term : list ident -> bool -> bool -> term -> t).
      1 print_term (empty_ext []) [] true T) >>= tmPrint).   *)
      1 print_term (empty_ext []) [] true
      1 print_term (empty_ext empty_global_env) [] true
      1 print_term_annotated Γ hd hda ^ ") "
      1 print_term_annotated Γ arg arga ^ ") : " ^ print_box_type bt
      1 print_term_annotated (P.empty_ext (PCUICProgram.trans_env_env (TemplateToPCUIC.trans_global_env p.1))) [] t0 annot).
      1 print_term_annotated (na :: Γ) body bodya ^ ") : " ^ print_box_type bt
      1 print_term_annotated
      1 print_template_program_with_guard {cf} {nor} :=
      1 print_template_program_with_guard
      1 print_template_program p with
      1 print_template_program cf nor fake_abstract_guard_impl.
      1 print_template_program {cf : checker_flags} (p : Ast.program) φ Hφ
      1 print_template_program {cf : checker_flags} {nor : normalizing_flags} {guard : abstract_guard_impl}
      1 Print TC.Solver. *)
      1 Print tCase.
      1 Print TB.
      1 Print tape. *)
      1 print t). all: intros [_ ef].
      1 Print t).
      1 print t ;;
      1 prints what it does using the API :builtin:`coq.term->string`.
      1 prints whatever was generated in the form of a list. *)
      1 Print _ s v)) : itree ((impExcE sensitivity_lat) +' stateE +' (IOE sensitivity_lat)) unit)
      1 Print _ s v)) : itree ((impExcE sensitivity_lat) +' Reg +' Memory +' (IOE sensitivity_lat)) unit)
      1 Print s val)
      1 Print s v)
      1 Print sum_set.
      1 Print SubspaceTopology.
      1 Print stuff.
      1 Print StructField.
      1 Print str_struct_new__tuple_fun. *)
      1 print_string ("| x" ^ x ^ y ^ " => \"" ^ x ^ y ^ "\"\n")
      1 print_string v;
      1 print_string this_mutant; *) (* Debugging *)
      1 print_string "-";printP_mon coef !name_var));
      1 Print : string -> printE unit.
      1 print (string_list_of_nats_with_lines l lines).
      1 print (string_list_of_nats_with_lines_and_points l lines symb_points).
      1 print_string "+" else ();
      1 print_string "0"
      1 print_string "";""".
      1 print_string "":="";
      1 print(strify(getattr(model, name)))
      1 Print s'';;tmMsg "With remainder:";;tmPrint R;;
      1 Print stlc.
      1 prints the _type_ of any term that we ask it to
      1 prints the term it found, or better the first
      1 prints the term and its type.
      1 prints the _statement_ of the [plus_comm] theorem in the same
      1 prints the received event and 
      1 prints the number of goals it receives, as well as
      1 prints the given string. *)
      1 prints the error message and bails out.
      1 prints the current goal.
      1 print_stats big n refP) max_stats_n is_flat speed;
      1 print_stats big n ref_PHOAS :=
      1 print statements below to see generated bedrock2 *)
      1 prints stuff *)
      1 prints somethinglike this:
      1 Print _ s _ => s end.
      1 Print s _ )) => s
      1 Print _ s _ ) ) => s
      1 Print _ s r);; Ret (inl tt)  ).
      1 Print _ s r) ) ≈
      1 print('''%s quote_%s (x : %s) : Preterm
      1 Print squaremod.
      1 print_spec_short (k : string) (s : spec) : string
      1 print_spec_short k s ++ "]")%string spec.(anon_opt_args))
      1 print_spec_short k s ++ "...]"]%string
      1 print_spec_short k s) spec.(anon_args))
      1 print_spec_parts : (list key + string) * spec * doc -> string * list string
      1 print_spec_parts (inr k, s, d)) (specs.(anon_args) ++ specs.(anon_opt_args) ++ match specs.(anon_opt_repeated_arg) with Some v => [v] | None => nil end))) in
      1 print_spec_parts (inl k, s, d)) (specs.(named_args) ++ help_specs))
      1 print_spatial_model (norm (print_wf_set selected) 
      1 Print span_set.
      1 Print span" *)
      1 Print sorted_insert__tuple_fun.
      1 Print somefloat.
      1 prints nothing interesting, while after the call it also prints the following
      1 Print sle_irrelevant_syn.
      1 Print sle.
      1 prints its arguments.
      1 print; simpl; intuition.
      1 Print simpl_compb.
      1 Print sig]
      1 Print shrinkList.
      1 Print "SHPointwise" ;;
      1 Print Showexp. *)
      1 Print Show.
      1 Print "SHInductor" ;;
      1 Print "SHCompose" ;;
      1 Print "SHBinOp" ;;
      1 prints "[H1]".  By applying [idtac] with an argument, a convenient
      1 Print SFltb.
      1 Print sensitivity_lat s v)) )
      1 Print sensitivity_lat l1 v);; Ret (inl tt).
      1 prints :e:`"Hello"`
      1 Print SectMiniOrderedType.
      1 prints each and every step,
      1 prints a prime number then terminates with code 0''.
      1 prints all the derivations being
      1 Print "SafeCast" ;;
      1 Print s)).
      1 prints: 
      1 prints.) *)
      1 print-rule i:prop.
      1 print-rule (age P N) :- coq.say P "is" N "years old".
      1 print-rule.
      1 print_RTL: Z -> RTL.program -> unit.
      1 print_RTL => "PrintRTL.print_if".
      1 Print RinvImpl.Rinv.
      1 Print Rewriter.Compilers.RewriteRules.nbe_rewrite_head.
      1 Print Rewriter.Compilers.RewriteRules.Compile.repeat_rewrite.
      1 print results by dumping out the first four
      1 Print respect2.
      1 print := repr_optimize (lf ++ rf) nil ; default := ld |}
      1 Print reifx'.
      1 print_reg_state st := let st' := (eval cbv in (annotate_reg_state st)) in idtac st'.
      1 Print refine_pick_forall_Prop.
      1 Print reduced_thm. *)
      1 print_recursivity_kind mie.(mind_entry_finite) ^ " " ^
      1 print_recursivity_kind decl.(ind_finite) ^ " " ^
      1 Print record.expand.
      1 Print Rdefinitions.RbaseSymbolsImpl.Rmult_def.
      1 Print randomFunc_withDups.
      1 Print randomFunc.
      1 Print r.
      1 Print quotient.
      1 print quotes around strings
      1 print('Quote Definition %s := %s.' % (qi, i))
      1 Print qU.
      1 Print qn;;
      1 Print qII.
      1 Print Qeq_bool.
      1 print_ptr_type n ++ ")")%string.
      1 print_ptr_type (n : name_with_type) : string
      1 print_ptr_cast (n : name_with_type) : string
      1 Print pseudoidᵗ.
      1 print_program with_universes (short : bool) (prefix : nat) (p : program) : t :=
      1 print_program := Tree.to_string ∘ PrintTermTree.print_program.
      1 print_program (trans_env Σ,t).
      1 print_program (short : bool) (prefix : nat) (p : program) : t :=
      1 print_program (p : program) : t :=
      1 Print prod.
      1 print (print_RTL 8)
      1 print (print_RTL 7)
      1 print (print_RTL 6)
      1 print (print_RTL 5)
      1 print (print_RTL 4)
      1 print (print_RTL 3)
      1 print (print_RTL 2)
      1 print (print_RTL 1)
      1 print (print_RTL 0)
      1 print print_Mach
      1 print print_LTL
      1 print printer prog = prog.
      1 print print_Cminor
      1 print print_Clight
      1 print_prim {term} (soft : term -> Tree.t) (p : prim_val) : Tree.t :=
      1 print_prim {term} (soft : term -> Tree.t) (p : @prim_val EAst.term) : Tree.t :=
      1 print_prim (print_term Γ true false) i)
      1 print_prim (print_term Γ false false) p)
      1 Print PRF_DRBG_G3_bad_4.*)
      1 Print PRF_DRBG_G2.
      1 Print PRF_DRBG_f_G2.            (* OracleComp D (Bvector eta) (list (Bvector eta)) *)
      1 Print PRF_DRBG_f_G2.
      1 Print PRF_DRBG_f.
      1 Print PRF_A. Print PRF_DRBG_f_G2.
      1 Print pred_strong4.
      1 Print pred_R.
      1 print predicate out of a small-footprint
      1 printP_rec p' f
      1 printP_rec p f=
      1 printP_rec  p 1;
      1 printP_rec p' 0
      1 printP_rec  p' 0
      1 print (P Q : Prop) (H : P -> Q) (p : P) : Q.
      1 print P, p, (H p). (* .in .messages *)
      1 printP p =
      1 Print possible_limbs.
      1 printP_mon_m d l =
      1 printP_mon_m b (List.tl l)   else
      1 printP_mon d l =
      1 printP_mon coef !name_var);
      1 printP_mon b (List.tl l) else
      1 print p in
      1 Print "Pick" ;;
      1 print.pformat(self.to_dict())
      1 Print peano.peano.
      1 print_pattern in e1.
      1 print_parse_inv:
      1 Print p2. (* Notation p2 := (readme.p2 nat 3 x) *)
      1 print out the things resulting from [Compute] to
      1 print out extra information about the smallest value that ran second *)
      1 print our new, broken, semantics ;-) *)
      1 Print oracleMap. *)
      1 Print). (* Optimized to remove match on Props *)
      1 Print Open.
      1 Print Opaque Dependencies identity_typing. *)
      1 print_one_inductive_body Σ wf) (ExAst.ind_bodies mib)).
      1 print_one_inductive_body npars body : Tree.t :=
      1 print_one_inductive_body
      1 print_one_ind_entry (short : bool) Γ (mie : mutual_inductive_entry) (oie : one_inductive_entry) : t :=
      1 print_one_cstr_entry Γ (mie : mutual_inductive_entry) (c : ident × term) : t :=
      1 Print Oi_oc'.
      1 Print oc_compMap. *)
      1 Print ObjInv.
      1 Print Num2Bits.
      1 Print nth_R.
      1 print) n = Some (Some v)
      1 Print Notation (Pr [ _ ]). *)
      1 Print normal_form'. *)
      1 Print normal_form'.
      1 print_no_prop_level := string_of_level ∘ NoPropLevel.to_level.
      1 print_no_prop_level levels
      1 print_no_prop_level l2 ++ ")".
      1 print_no_prop_level l1 ++ ", " ++ string_of_nat n ++ ", "
      1 Print nK_False.
      1 Print nK_bool.
      1 print_nf ("Translating " ^ string_of_kername kn) ;;
      1 print_nf ("Translating " ++ string_of_kername kn) ;;
      1 print_nf ("Translating " ++ global_decl_ident decl) ;;
      1 print_nf ("toto5 " ^ id) ;;
      1 print_nf ("toto4 " ^ id) ;;
      1 print_nf ("toto2 " ^ id) ;;
      1 print_nf ("toto1" ^ id) ;;
      1 print_nf tA' ;;
      1 print_nf  (string_of_kername kn ^ " has been translated.") ;;
      1 print_nf  (string_of_kername kn ++ " has been translated.") ;;
      1 print_nf  (kn ++ " has been translated.") ;;
      1 print_nf (id ^ "is an axiom, not a definition") ;;
      1 Print next_nat.
      1 print_newline => "print_newline".
      1 print_newline : io.
      1 print_native_stats big n refP) max_native_n is_flat speed;
      1 print_native_stats big n ref_PHOAS :=
      1 Print nat_enum_cls.
      1 print_name (tvar_name tvar))
      1 print names.
      1 print_name r0 ++ " = " ++ print_cast r0 ++ name)%string, outnames' ++ innames)
      1 print_name (nth i Γ nAnon) ^ " : " ^ print_box_type bt
      1 print_name (n : name_with_type) : string := fst n.
      1 print_name na ^ " := (" ^ print_term_annotated Γ val vala ^ ") in" ^ nl
      1 print_name na ^ " -> (" ^ print_term_annotated (na :: Γ) body a ^ ")) : "
      1 print_name na
      1 print_name n)
      1 print_name l).
      1 print_name := erase_type_tests.print_name.
      1 Print n;;
      1 Print myp_add.
      1 Print myb_finm.
      1 Print myb_cntm.
      1 Print mux_mut_refs_u64__tuple_fun. *)
      1 print_mults : stateiotree unit :=
      1 print_mults_sats_spec :
      1 print_mults_pre : StateIOSpecPre :=
      1 print_mults_pre print_mults_post) (interp_state handleIOStateE print_mults).
      1 print_mults_pre in Hpre.
      1 print_mults_post : StateIOSpecPost unit :=
      1 print_mults_post. setoid_rewrite append_nil.
      1 print_mults in Href. setoid_rewrite interp_state_bind in Href.
      1 Print MTree_map.
      1 Print MTree_equal.
      1 Print "MSHPointwise" ;;
      1 Print "MSHPick" ;;
      1 Print "MSHIUnion" ;;
      1 Print "MSHIReduction" ;;
      1 Print "MSHInductor" ;;
      1 Print "MSHEmbed" ;;
      1 Print "MSHCompose" ;;
      1 Print "MSHBinOp" ;;
      1 Print msg
      1 Print move.  *)
      1 Print Montgomery256.montred256.
      1 Print Module X.
      1 Print Module Type HT.
      1 Print Module Type GT.
      1 Print Module Type FT.
      1 Print Module Type d3_Locked.
      1 Print Module NextModule2.
      1 Print Module H.
      1 Print Module G.
      1 Print Module d3.
      1 Print ModOpsAx.carry_squaremod.
      1 Print Model.
      1 Print mm_recognisable_n.
      1 Print mlist_equal_ok.
      1 Print mk_foo.
      1 print_mie Σ with_universes short := Tree.to_string ∘ PrintTermTree.print_mie Σ with_universes short.
      1 print_mie Σ with_universes (short : bool) (mie : mutual_inductive_entry) : t :=
      1 print_mib Σ with_universes short := Tree.to_string ∘ PrintTermTree.print_mib Σ with_universes short.
      1 print_mib Σ with_universes (short : bool) (mib : mutual_inductive_body) : t :=
      1 Print MetaCoq.Erasure.Typed_CertifyingEta_Examples_Ex2_partial_app2_expanded. *)
      1 print : message -> unit := "ltac2" "print".
      1 print (Message.of_string "yes")
      1 print (Message.of_string "weqtransportbUAH").
      1 print (Message.of_string "weqtopathsUAH").
      1 print (Message.of_string "univfromtwoaxioms").
      1 print (Message.of_string "univalenceUAH").
      1 print (Message.of_string "sectohfibertosec").
      1 print (Message.of_string "no")
      1 print (Message.of_string "isweqtransportf10").
      1 print (Message.of_string "isweqtransportb10").
      1 print (Message.of_string "eqweqmap").
      1 print (Message.of_string "DEBUG lemma l1").
      1 print (Message.of_string "DEBUG funextsecImplication").
      1 print (Message.of_string "DBUG1").
      1 print (Message.of_ident @X0).
      1 print (Message.of_ident @X0').
      1 print (Message.of_ident @weqtopathsStatement).
      1 print (Message.of_ident @weqtopaths).
      1 print (Message.of_ident @T2).
      1 print (Message.of_ident @T1).
      1 print (Message.of_ident @n).
      1 print (Message.of_ident @l1).
      1 print (Message.of_ident @IHn).
      1 print (Message.of_ident h)
      1 print (Message.of_ident @ee).
      1 print (Message.of_constr e)
      1 print (Message.of_constr constr:(T2)).
      1 print (Message.of_constr constr:(T1)).
      1 print (Message.of_constr constr:(idweq)).
      1 print (Message.of_constr constr:(e)).
      1 print (Message.of_constr '(3+4)).
      1 print (Message.concat (Message.of_ident h)
      1 Print mbtree_equal_ok.
      1 Print mbtree_equal.
      1 Print max_lin_indep.
      1 Print MAXIMAL_PRINCIPLE.
      1 Print maximal.
      1 print_match_prelhs in e1 as h1.
      1 print_match_prelhs :
      1 print_match_pattern in e1 as h. 2: auto.
      1 print_match_pattern in e1 as e7. 2: auto.
      1 print_match_pattern in e1 as e10. 2: auto.
      1 print_match_pattern :
      1 print_match_lhs in e1. 2: auto.
      1 print_match_lhs :
      1 Print ("MAST" ++ (AstUtils.string_of_term mast)) ;; *)
      1 Print map_term. *)
      1 print := map (@Some _) ls
      1 Print "MApply2Union" ;;
      1 print_Mach => "PrintMach.print_if".
      1 print_Mach: Mach.program -> unit.
      1 print_LTL => "PrintLTL.print_if".
      1 print_LTL: LTL.program -> unit.
      1 Print Ltac prog_skip.
      1 Print Ltac pose_string_ids.
      1 Print Ltac fcf_skip.
      1 Print Ltac dist_skip.
      1 Print Ltac case_eq.*)
      1 print_ltac (but it can't find Std.intros so that fails).
      1 Print Ltac2 test_boole.
      1 Print Ltac2 solve_with. (* note type is 'a -> unit *)
      1 Print Ltac2 Message.of_string.
      1 Print Ltac2 Ltac2.Std.intros.
      1 Print Ltac2 explain_abc.
      1 Print Ltac2 command; it runs
      1 Print Ltac2 B.
      1 print := ls
      1 print loop notations before a [return] *)
      1 Print LoopBodyOk.
      1 Print logits_all_tokens.
      1 Print logits.
      1 print_list_with_lines_and_points l lines symb_points :=
      1 print_list_with_lines_and_points (1::5::10::18::nil) (6::11::nil) (("o", (1::nil))::("●", (10::nil))::nil).
      1 print_list_with_lines (1::5::10::18::nil) (6::11::nil).
      1 print_list_with_lines (1::5::10::18::nil) (11::nil).
      1 print_list_with_lines ((1,1)::(2,3)::(4,5)::nil) (2::3::nil).
      1 print_list_with_lines ((1,1)::(2,3)::(4,5)::nil) (1::3::nil).
      1 print_list string_of_level " " u ^ "}"
      1 Print listR_inv.
      1 print_list (pr_term Γargs true) " " c.(cstr_indices).
      1 print_list (print_term Γ false false) " " args ^ "]")
      1 print_list (print_term Γargs true) " " c.(cstr_indices).
      1 print_list (print_one_ind Σ' with_universes short names mib) (nl ^ "with ") mib.(ind_bodies) ^ "." ^ nl).
      1 print_list (print_one_ind Σ' short names mib) (nl ^ "with ") mib.(ind_bodies) ^ "." ^
      1 print_list (print_one_inductive_body decl.(ind_npars)) (nl ^ " with ") decl.(ind_bodies).
      1 print_list (print_one_ind_entry Σ' with_universes short names mie) (nl ^ "with ") mie.(mind_entry_inds) ^ "." ^ nl).
      1 print_list (print_one_cstr_entry Γpars mie) nl (combine oie.(mind_entry_consnames) oie.(mind_entry_lc)).
      1 print_list (print_def (print_term Γ true) (print_term (fresh_names Σ Γ ctx') true))
      1 print_list (print_def (print_term Γ true false) (print_term (fresh_names Σ Γ ctx') true false))
      1 print_list (print_def (print_term (ctx' ++ Γ)%list true false)) (nl ^ " with ") defs.
      1 print_list (print_decl g) nl (List.rev g).
      1 print : list (option T)
      1 print : list (nat * T)
      1 print List.map seq List.option_all].
      1 print_list l := print (string_list_of_nats (fun _ => "") (fun _ => "*") l).
      1 print_list l := print_grid (string_list_of_coords (fun _ => "") l).
      1 Print list_is_empty__tuple_fun. *)
      1 Print list_head__tuple_fun. *)
      1 Print list_head_impl__tuple_fun. *)
      1 print_list (fun x => x.(proj_name)) ", " body.(ind_projs)
      1 print_list (fun '(l1, d, l2) => string_of_level l1 ^ " " ^
      1 print_list (fun '(l1, d, l2) => string_of_level l1 ++ " " ++
      1 print_list (fun '(l1, d, l2) =>
      1 print_list (fun cstr => "| " ^ (cstr.(cstr_name) : ident) ^ " " ^
      1 print_list (fun '(b, cstr) => (cstr.(cstr_name) : String.t) ^ " " ^ b)
      1 print_list (fun '(b, cdecl) => cdecl.(cstr_name) ^ " " ^ b)
      1 print_list (fun '(b, cb) => cb.(cstr_name) ^ " " ^ b)
      1 print_list : forall es m, SS.Subset (Union.union_list (List.map free_vars (List.map (fun e => const_folding_expr e m) es))) (Union.union_list (List.map free_vars es)).
      1 Print list_equal.
      1 print_list {A} (f : A -> t) (sep : t) (l : list A) : t :=
      1 print_list (1::5::7::30::nil).
      1 print_list (1::5::7::15::nil).
      1 print_list.
      1 Print lin_indep'.
      1 print_linear in e1.
      1 Print lin_dep.
      1 print l in
      1 print_level := string_of_level.
      1 print_level levels
      1 print_level l2 ^ ")".
      1 print_level l1 ^ ", " ^ string_of_Z n ^ ", "
      1 Print Length_Step_steps. *)
      1 Print Language.Compilers.ToString.OfPHOAS.bound_to_string.
      1 Print ladderstep_body.
      1 Print : label -> value -> IOE unit.
      1 Print Labels l1 v);; Ret (inl tt).
      1 Print {Labels}.
      1 print l =
      1 print l :=
      1 print_key_list (k : list key) : string
      1 print_key_list k
      1 print_key k)%string.
      1 print_key (k : key) : string
      1 print_key k)
      1 print k1 k2 (brs : list (nat × term)) :=
      1 print k1 k2 brs =
      1 print(" ".join([\'| x%02x => %d\' % (x,x) for x in range(256)]))' *)
      1 print := join lf rf ; default := ld |}
      1 Print "IUnion" ;;
      1 Print itvl. *)
      1 print i ts = interp i ts.
      1 print i ts' 
      1 print i ts := 
      1 print it, but hey *)
      1 Print ITA.
      1 Print "ISumUnion" ;;
      1 Print is too slow *)
      1 Print is_subspace.
      1 Print is_pred.
      1 Print IsMonoid.
      1 Print is_lin_comb_prop.
      1 Print IsDisjointUnion.
      1 Print is_chain.
      1 Print is_bla.
      1 Print is_basis.
      1 print, is a variable that, when
      1 Print "IReduction" ;;
      1 print_intx : ident := 76%positive.
      1 print_intx : ident := 61%positive.
      1 printInt"("tmp")
      1 printIntS := SPEC("n") reserving 0
      1 printInt") = Some (fst st)
      1 printInt"("Sn")
      1 print_intr : ident := 58%positive.
      1 printInt", printIntS)
      1 print_int :: _print_intr :: _putchar :: _getchar ::
      1 PrintInt.ok ok0.
      1 print_int n;
      1 PrintInt.m m0.
      1 PrintInt.mainS] ]]
      1 print_int : ident := 77%positive.
      1 print_int : ident := 62%positive.
      1 print_int : ident := 59%positive.
      1 printInt"("i")
      1 print in the middle of things.
      1 PrintInt : forall st st',
      1 PrintIntDriver Bedrock.AMD64_gas.
      1 PrintInt Bedrock.Platform.Bootstrap.
      1 print('Instance %s_quotable : Quotable %s := quote_%s.' % (qtype_name, type_name, qtype_name))
      1 Print Instances Proper.
      1 Print insert_remove__tuple_fun. *)
      1 print in H; clear IHfootprint.
      1 printing wrapper. An A : qualifier q T  *)
      1 Printing Width 50.
      1 Printing Width 250.
      1 Printing Width 160.
      1 Printing Width 140.
      1 Printing Width 100000. Print Rewrite HintDb push_eval. | sed s'/^.*->//g' | grep -o ' eval \(([^)]\+)\|[^ ]*\) \(([^)]\+)\|[^ ]*\) [^ )]*' | grep -o '[A-Za-z0-9_\.][A-Za-z0-9_\.]\+$' | sort | uniq *)
      1 printing used to be inconsistent before *)
      1 Printing Universes. Print Module Test.
      1 Printing true test.
      1 Printing true slow.
      1 Printing true quick.
      1 Printing true medium.
      1 printing too *)
      1 printing (the right-hand side is pretty-printed as
      1 Printing the proof term shows the unsurprising list that is found.  Here is
      1 printing the proof term. *)
      1 printing the expression tree in a
      1 printing the error message. *)
      1 printing the coercions is in fact the desired behaviour.
      1 printing  *|_|* %\textvisiblespace% #␣# *)
      1 printing_test" constr(name) constr(big) tactic3(do_print) constr(n) :=
      1 printing_test
      1 printing terms, including
      1 printing) : tap_scope.
      1 printing support, but note that it is explicitly
      1 printing [s] forever. *)
      1 printing, s1 at level 26, right associativity, at level 26, format "lbl :  '/' s1") : C_scope.
      1 printing, s1 at level 100, right associativity, at level 100, format "lbl :  '/' s1") : C_scope. (* messing up the level for Iris compatibility -WM) *)
      1 printing, right associativity, at level 99, f_val at level 200, format "p_val -> f_val") : expr_scope.
      1 printing, right associativity, at level 99, f_val at level 200
      1 printing, QuickChick uses a [Show] typeclass, like Haskell. *)
      1 printing otherwise.
      1 printing only*)
      1 printing only *)
      1 printing, one needs to use a tree structure
      1 Printing of IEEE numbers                     *)
      1 printing of floats business is highly dubious,
      1 printing not implemented)" (* TODO *)
      1 printing (n=" n ") for" name "with" big ":";
      1 printing namespaces *)
      1 Printing.ml" scheduled_thread.
      1 printing, maybe add print config? *)
      1 printing) : itree_scope.
      1 printing...  It
      1 printing is without. *)
      1 printing is for the
      1 Printing is_flat speed :=
      1 printing: in spite of carrying
      1 Printing Implicit. -- to see the need for following step. *)
      1 Printing Implicit. Show.
      1 Printing Implicit. Set Printing All.
      1 Printing Implicit. setoid_rewrite interp_memory_trigger. cbn.
      1 Printing Implicit. *) 
      1 printing) : ident_scope.
      1 printing hint ```x```,
      1 printing hint,
      1 Printing Goal Names. (* Coqide doesn’t use it yet, will be in 8.13 *)
      1 Printing Generation Indist DerivedGen.
      1 Printing Generation.
      1 printing Gallina
      1 printing functions on command-lines options indicating how verbose to
      1 printing functions *)
      1 printing function *)
      1 printing for [{[+ x +]}]. *)
      1 printing, format "x __exp") : subst_scope.
      1 printing, format "'with_state'  '/' '[hv ' state ']'  '//' 'for'  ( x  :=  init ;;  x  <?  max ;;  x ++ )  '//' '[v  ' {{  '//' body ']' '//' }}").
      1 printing, format "'with_state'  '/' '[hv ' state ']'  '//' 'for'  ( x  :=  init ;;  x  <?  max ;;  x  +=  step ) '//' '[v  ' {{  '/' body ']' '//' }}").
      1 printing, format "'[hv  ' ! a1 ']'", at level 30, right associativity) : expr_scope.
      1 printing, format "'[hv  ' ! a1 ']'", at level 20, right associativity) : expr_scope.
      1 printing, format "[Functions: '//' f1  :=  '[' f1_body ']' ]") : fun_syntax.
      1 Printing false test.
      1 Printing false slow.
      1 Printing false quick.
      1 Printing false medium.
      1 printing ExX $\exists$ *)
      1 printing) : expr_scope.
      1 Printing Existential Instances. 
      1 printing Ex $\exists$ *)
      1 Printing entire programs
      1 printing el ∊ *)
      1 printing" do_print ())
      1 Printing Depth 70.
      1 Printing Depth 1000000.
      1 Printing Depth 1000.
      1 Printing Depth 100. *)
      1 printing deprecation warning when used)
      1 Printing Coercions.*)
      1 Printing Coercions. *)
      1 printing by default (so the above examples are printed as
      1 printing boxes that print the type of a long definition on a       *)
      1 Printing" big
      1 printing, at level 9) : expr_scope.
      1 printing, at level 1) : subst_scope.
      1 printing, at level 10, left associativity).
      1 printing, at level 10, format "'INSTR' '//' i"). *) *)
      1 printing, at level 10, format "'CODE' '//' c"). *) *)
      1 printing assembly code, as follows:
      1 Printing as C code *)
      1 printing and assembling. *)
      1 printing AlX $\forall$ *)
      1 Printing All], to disable all syntactic niceties and show every node of
      1 Printing All. Print API.expr. *)
      1 Printing All does not add anything
      1 Printing All.*)
      1 Printing All.  *)
      1 printing Al $\forall$ *)
      1 printing ---> $\supset$ *)
      1 printing =?> $\stackrel{?}{\mapsto}$ *)
      1 printing |] $\rceil$ *)
      1 printing ==*> $\mapsto$ *)
      1 printing =*> $\mapsto$ *)
      1 printing ===> $\Longrightarrow$ *)
      1 printing *<- $*\leftarrow$ *)
      1 printing <-* $\leftarrow{}*$ *)
      1 printing [| $\lceil$ *)
      1 printing ++ $+\kern-0.3em+$ *)
      1 printing ^+ $\hat{+}$ *)
      1 printing * $*$ *)
      1 Printing. *)
      1 Printing 
      1 printing*)
      1 printing). *)
      1 printing === ≡ *)
      1 printing <<= ⊆ *)
      1 Print ("infHead:",res,R');;*)
      1 Print inferred_type'.
      1 print_inferred_list (rsort_uniq compare_clause 
      1 print_inductive (Σ : global_env_ext) (wf : ∥ wf_ext Σ ∥)
      1 printInductive (name  : ident): TemplateMonad unit :=
      1 print_inductive (empty_ext (PCUICProgram.trans_env_env Σ)) assume_wellformed inder
      1 print_inductive_body mind
      1 print_inductive_body decl :=
      1 print_ind_prog (p : Ast.Env.program) : string :=
      1 print_ind_prog ex9 = <$
      1 print_ind_prog ex8 = <$
      1 print_ind_prog ex7 = <$
      1 print_ind_prog ex6 = <$
      1 print_ind_prog ex5 = <$
      1 print_ind_prog ex4 = <$
      1 print_ind_prog ex3 = <$
      1 print_ind_prog ex2 = <$
      1 print_ind_prog ex14 = <$
      1 print_ind_prog ex13 = <$
      1 print_ind_prog ex12 = <$
      1 print_ind_prog ex11 = <$
      1 print_ind_prog ex10 = <$
      1 print_ind_prog ex1 = <$
      1 Print in_dec. *) (* looks gnarly *)
      1 print_ind_ctor (ind : inductive) (c : nat) : string :=
      1 print_ind_ctor ind c ^ " : " ^ print_box_type bt
      1 Print iff_morphism.
      1 Print iff_inverse_impl_binary_morphism.
      1 print_ids ids'
      1 print_ids ids :=
      1 print_identity. auto. auto.
      1 print : ident := 80%positive.
      1 print : ident := 65%positive.
      1 printible syntax tree used in bounds analysis)" ++ String.NewLine]%string)
      1 print.iacr.org/2015/677.pdf> *)
      1 print.iacr.org/2015/1060.pdf> "Complete
      1 Print IA.
      1 Print HookedTransformer.HookedTransformer.logits.
      1 Print HookedTransformer.Hook
      1 Print HintDb xxx.
      1 Print Hint.
      1 Print hello_world__bodies.
      1 Print hasDups.*)
      1 print_grid (string_list_of_coords (fun x =>
      1 print_grid grid :=
      1 print_grid (.
      1 Print Grammar foo2.
      1 Print Grammar foo.
      1 Print goodFooNarrow.
      1 Print go_expr_test.
      1 print_goal; shelve_unifiable.
      1 print_goal := match goal with |- ?g => idtac (* "goal:" g*) end.
      1 print_goal := match goal with
      1 print_goal; erewrite (@asimpl_t_ext _ tt sigma); [|t]; asimpl_pre) end).
      1 print_goal; erewrite (@asimpl_f_ext _ _ _ _ phi sigma); [|t]; asimpl_pre)
      1 print_goal; eapply multi_step ;
      1 print_goal_cbn :=
      1 print_goal].
      1 print_goal:= 
      1 print_goal" :=
      1 print_goal _ :=
      1 print_goal :=
      1 print_goal ().
      1 print goal*)
      1 print_global_context := Tree.to_string ∘ PrintTermTree.print_global_context.
      1 print_global_context (g : global_context) :=
      1 Print Gi_rf.*)
      1 Print G_ideal.*)
      1 Print getcMethDef.
      1 Print Gen_loop_rb_intermediate.*)
      1 Print Gen_loop_oc.*)
      1 Print genGoodNarrow. 
      1 Print Generate_v_oc_instantiate.*)
      1 Print generates.
      1 Print Generate_rb_intermediate_oc.*) (* like the above but with no k sampling *)
      1 Print Generate_noV_oc_k.*)
      1 printf, your witness type does not match the format string.
      1 print f = x.
      1 printf w w' :=
      1 printf_witness H w;
      1 printf_witness Hsub w :=
      1 printf, which is annoying because it's
      1 Print funspec_sub. do_funspec_sub. Search  red in Sub simpl in Sub. destruct Sub. intros r. eapply eqp_prop. andp_subp. eapply prop_andp_subp. normalize.
      1 Print funspec.
      1 print => "fun (f: 'a -> unit) (x: 'a) -> f x; x".
      1 print := fun b ofs =>
      1 Print Full_set.
      1 printf "%t" rhs'
      1 printf "%t" res;
      1 printf_string : string -> _IO unit := fun _ => tt.
      1 printf_string : string -> _IO unit.
      1 printf_string (String.concat String.NewLine msg);
      1 printf_string (String.concat "" lines);
      1 printf_string =>
      1 Printf.sprintf ""%s:%s"" section name".
      1 Printf.sprintf ""%s:%s:%d:%d"" section locf locl locc".
      1 printf_spec_sub(CS := cs) FILEid) in
      1 printf_specs prog :=
      1 printf_specs' {FS : FileStruct} (defs: list (ident * globdef (fundef function) type)) : list (ident*funspec) :=
      1 printf_specs' d') in
      1 printf_spec_parametrized, printf_spec_parametrized in H;
      1 printf_spec_parametrized (fmtz: list Z) :=
      1 printf_spec_parametrized fmtz).
      1 printf_spec_parametrized FILEid (fmtz: list Z) :=
      1 printf_spec_parametrized FILEid fmtz).
      1 Printf.printf ""%s"" s".
      1 Printf.printf ""%f%!"" f".
      1 printf_placeholder_spec) :: make_printf_specs' defs'
      1 printf_placeholder_spec id) :: make_printf_specs' defs'
      1 printf_placeholder_spec : funspec :=
      1 printf_placeholder_spec FILEid : funspec :=
      1 printf_placeholder_spec FILEid)
      1 printf_placeholder_spec)
      1 printf outv w w' :=
      1 Print form_direct_sum.
      1 print : forall s, SS.Subset (free_vars (optimizer s)) (free_vars s).
      1 print : forall s m, SS.Subset (free_vars (fst (fst (const_folding s m)))) (free_vars s).
      1 print : forall s m, free_vars (fst (elim_dead s m)) <= free_vars s.
      1 print : forall e m, SS.Subset (free_vars (const_folding_expr e m)) (free_vars e).
      1 Print Foo.x2.
      1 Print foo "tests/test_link_order9".
      1 Print foo "tests/test_link_order8".
      1 Print foo "tests/test_link_order7".
      1 Print foo "tests/test_link_order6".
      1 Print foo "tests/test_link_order5".
      1 Print foo "tests/test_link_order4".
      1 Print foo "tests/test_link_order3".
      1 Print foo "tests/test_link_order2".
      1 Print foo "tests/test_link_order1".
      1 Print Foo.t_equal.
      1 Print foobar.
      1 Print Foo.
      1 Print foo.*)
      1 printf :: _memset :: _memcmp :: ___builtin_debug :: ___builtin_nop ::
      1 printf :: _memset :: _memcmp :: ___builtin_debug ::
      1 print_flush ();;
      1 printf_list_string_with_newlines (strs : list String.string) : unit
      1 printf_list_string_with_newlines stdout strs.
      1 printf_list_string_with_newlines stdout msg)
      1 printf_list_string_with_newlines msg;
      1 printf_list_string_with_newlines (chan : out_channel) (strs : list String.string) : unit
      1 printf_list_string [" s; user: "%string];
      1 printf_list_string (strs : list String.string) : unit
      1 printf_list_string stdout strs.
      1 printf_list_string stdout lines)
      1 printf_list_string [" s"%string; String.NewLine];
      1 printf_list_string [descr; ": real: "%string];
      1 printf_list_string (chan : out_channel) (strs : list String.string) : unit
      1 printf_list_string chan nil
      1 printf_list_string chan lines)
      1 printf_list_string chan
      1 print := firstn 2 (footprint bedrock_types_r)
      1 print_first_match :
      1 Print). (* finds (MPdot (MPfile ["FMapInterface"; "FSets"; "Coq"]) "S") if unqualified *)
      1 Print filter_term. *)
      1 Print fifth_root. (* 37, as 37^5 = 69343957, obviously *)
      1 Print field_compatible. (*???*)
      1 printf : ident := 70%positive.
      1 printf : ident := 55%positive.
      1 printf : ident := 53%positive.
      1 printf) hack *)
      1 printf' gv Pre id sub outv w w' :=
      1 printf' gv Pre id sub outv w w'
      1 printf' gv Pre id (printf_spec_sub(CS := cs)) nullval w w'
      1 Printf.fprintf chan ""%c%!"" c".
      1 Printf.fprintf chan ""%!""".
      1 printf_float (fsub uend ustart);
      1 printf_float (fsub rend rstart);
      1 printf_float : float -> unit := fun _ => tt.
      1 printf_float : float -> unit.
      1 printf_float =>
      1 Print fexp.
      1 Print fe25519_to_bytes.
      1 Print fe25519_sub.
      1 Print fe25519_square.
      1 Print fe25519_scmula24.
      1 Print fe25519_opp.
      1 Print fe25519_mul.
      1 Print fe25519_from_bytes.
      1 Print fe25519_add.
      1 printf" _) _ _ _)) :: defs' => 
      1 print(f'Definition {name} := ')
      1 print(f"""Definition lift{i}_{''.join(str(k+1) for k in subset)} {{F}} (R : relation{'' if len(subset) == 1 else len(subset)} F) : relation{i} (fun {make_args(i, subset)} => F {' '.join(LETTERS_NO_F[:len(subset)])})
      1 printf_char : out_channel -> Ascii.ascii -> unit := fun _ _ => tt.
      1 printf_char : out_channel -> Ascii.ascii -> unit.
      1 printf_char chan) (String.list_ascii_of_string ls))
      1 printf_char =>
      1 printf "before: %t" f;*)
      1 printf and fprintf").
      1 printf "after: %t" f;*)
      1 printf :: _abort :: ___builtin_debug ::
      1 Print F.
      1 printf. *)
      1 printf" _) 
      1 print_extracted_coq_string : string -> unit.
      1 print_extracted_coq_string =>
      1 Print expanded_g.
      1 Print expanded_f.
      1 Print ex_intro.
      1 Print even_256.
      1 Print even_256'.
      1 Print evalDist.
      1 Print eval1.
      1 Print ev_4'.
      1 Print ev_4''.
      1 Print ev_4'''.
      1 Print ev.
      1 printE unit := run_spawn main_thread.
      1 printE : Type -> Type :=
      1 printer, which works the same as interp *)
      1 printer, to report counterexamples found
      1 Printers.Nat2D.
      1 Printers.Helpers.
      1 printers (defined in Caml). *)
      1 printer prog in prog.
      1 printer printP;;
      1 printer of these error messages will always know the
      1 Printer.ml] that inserts additional moves
      1 printer i:gref, i:list prop.
      1 Printer "elpi2html.elpi" "elpi2html.elpi". (* this one is from elpi *)
      1 printer ClassGR Rules. 
      1 printer ClassGR Rules
      1 printer ClassGR Instances :- 
      1 printer: A -> unit) (prog: A),
      1 printer a la Maple *)
      1 printer.
      1 printer _ [].
      1 printer **)
      1 printer       *)
      1 Print EquivalenceSet.
      1 Print Equality.mixin_of.
      1 print eqn:e8.
      1 print eqn:e3.
      1 print eqn:e2. cbn in e0.
      1 print eqn:e11.
      1 Print eq_list.
      1 print_eq in e as ?.
      1 Print eq_class.
      1 print_eq :
      1 printE +' printE) unit :=
      1 print_env with_universes short prefix (fst p) ^ nl ^ print_term (empty_ext (fst p)) with_universes nil true (snd p).
      1 print_env with_universes (short : bool) (prefix : nat) Σ :=
      1 print_env true 10 X.π2.π1.(wf_env_ext_reference).(reference_impl_env_ext) *)
      1 print_env short prefix (fst p) ^ nl ^ print_term (empty_ext (fst p)) true nil true false (snd p).
      1 print_env := print_global_context.
      1 print_env p.1.
      1 print_env; exact true).
      1 print_env (e : env) : io :=
      1 print_env e
      1 print_env_aux with_universes short prefix Σ (Tree.string "").
      1 print_env_aux with_universes short n Σ (print_mib Σ with_universes short mib ^ acc)
      1 print_env_aux with_universes short n Σ'.1
      1 print_env_aux with_universes (short : bool) (prefix : nat) (Σ : global_env) (acc : t) : t :=
      1 print_env_aux short prefix Σ (Tree.string "").
      1 print_env_aux (short : bool) (prefix : nat) (Σ : global_env) (acc : t) : t :=
      1 print_env :=
      1 Print entry ;;
      1 print_endline (show (quickCheckWith args test));;
      1 print_endline ""OK!""; exit 0".
      1 print_endline ""IO test failed!""; exit 1".
      1 print_endline (generate_lemmas mod_sum_three (typecheck_circuit (add_to_delta d_empty num2bits) mod_sum_three));; *)
      1 print_endline (generate_lemmas escalar_product (typecheck_circuit d_empty escalar_product));; *)
      1 print_endline (generate_lemmas cor (typecheck_circuit d_empty cor));; *)
      1 print_endline ("Checking " ++ name ++ "...");;
      1 Print encodemod.
      1 Print "Embed" ;;
      1 printE -< E} (s:string) : itree E unit :=
      1 printed via the [Numeral Notation] command, by conversion from/to
      1 printed to the console using a match statement on the idtac variable.
      1 printed (this means that the top level
      1 printed the name is shown. (Even though the
      1 printed PowerPC assembly code, this allocation
      1 printed PowerPC assembly code, this
      1 printed out using a `try` block to handle any exceptions that may occur during evaluation.
      1 printed. Only the name of
      1 printed just afterwards:
      1 printed by coq as (fun _ _ _ => tt), but the information about the
      1 printed as `x`) has type `nat`.
      1 printed as well as
      1 printed as we encounter them
      1 printed as 'R', which sometimes 
      1 printed ASM assembly code, this freeing is just an increment of [sp]:
      1 printed ASM assembly code, this freeing
      1 printed as _ for unused binders, it's still stored and pattern
      1 printed as a string. *)
      1 printed as:"]
      1 printed and the program
      1 Print easy_hd.
      1 Print e1 ;; tmPrint e2 ;; tmFail "Cannot elaborate Coq term to an ETT term"
      1 print(e(19259)); print(e(41781))" *)
      1 Print <DotSeparatedPath>".
      1 Print Distribution.
      1 print_disjoint p).
      1 print_disjoint a).
      1 Print diophantine_n.
      1 print different Notation for each case.      *)
      1 Print "Did not find an instance for ";;
      1 print. destruct (printer prog); auto.
      1 Print derive.param1.
      1 Print derive.
      1 Print demoList. *)
      1 print_defs Γ (defs : mfixpoint term) :=
      1 print_defs (print_term : list ident -> bool -> term -> t)
      1 print_defs (print_term : context -> bool -> bool -> term -> t) Γ (defs : mfixpoint term) :=
      1 Print (definition_entry_body d)
      1 print_def {A : Set} (f : A -> t) (def : def A) :=
      1 print_def {A : Set} (f : A -> string) (g : A -> string) (def : def A) :=
      1 print_decl Σ '(kn, d) :=
      1 print_db USA.
      1 print_db Italy.
      1 print_db France.
      1 print_ctor_type ∘ snd) ctor_types))%bs in
      1 print_ctor_type bt :=
      1 print_ctor (ExAst.ind_ctors oib)))%bs.
      1 print_ctor '(ctor_name, ctor_types, _) :=
      1 print_context Σ Γ Δ : string :=
      1 print_context Γ Δ : list ident * t :=
      1 print_context Γ mie.(mind_entry_params) in
      1 print_context Γ decls in
      1 print_context := (print_context_gen Σ (print_term Σ true)).
      1 print_context_names Γ Δ :=
      1 print_context_names Γ decls in
      1 print_context_names Γ br.(bcontext)
      1 print_context_gen Γ Δ :=
      1 print_context_gen Γ decls in
      1 print_context_gen print_term Γ br.(bcontext)
      1 print_context (); fail)
      1 print_context_decl Σ Γ (decl : context_decl) : string :=
      1 print_context: could not clear" H); print_context (); fail);
      1 print_context_and_goal _ :=
      1 print_context_and_goal ();
      1 print_context_and_goal () .. | | ].
      1 print_context_and_goal () .. ].
      1 print_context _ :=
      1 print_context ();
      1 print constrs (terms): *)
      1 print_constraint_type d ^ " " ^ string_of_level l2)
      1 print_constraint_set (ContextSet.constraints univs)))));;
      1 print_constraint_set (constraints_of_udecl udecl)))));;
      1 print_constraints.
      1 printConstant (name  : ident): TemplateMonad unit :=
      1 printConstant "Coq.Arith.PeanoNat.Nat.add").
      1 print_constant_body Σ kn decl :=
      1 print_constant_body Σ kn body
      1 Print comp_spec_eq_trans.*)
      1 Print composite. co_sizeof. simpl in *. inv H3. unfold sizeof in e.*)
      1 Print compFold. *)
      1 Print Comp.
      1 print code using this notation only when it was actually used *)
      1 print_Cminor => "PrintCminor.print_if".
      1 print_Cminor: Cminor.program -> unit.
      1 print_closedn in e as hc.
      1 print_closedn_eq t) as ef. revert ef.
      1 print_closedn_eq in e7 as h. destruct h as [hc _].
      1 print_closedn_eq in e4 as h. destruct h as [hc _].
      1 print_closedn_eq in e1 as [? ?]. subst.
      1 print_closedn_eq in e1 as [? ?].
      1 print_closedn_eq. }
      1 print_closedn :
      1 print_Clight => "PrintClight.print_if".
      1 print_Clight: Clight.program -> unit.
      1 Print center.
      1 print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type) 
      1 Print Cats.And.Dogs.x.
      1 Print cast. (* prints as rew [Fin.t] H in f *)
      1 print_cast (n : name_with_type) : string
      1 print_case_label Sskip rem%print_cases) (only printing, rem at level 26, right associativity, at level 26, format "lbl :  '/' rem") : print_cases_scope.
      1 print_case_label Sskip rem%print_cases) (only printing, rem at level 100, right associativity, at level 100, format "lbl :  '/' rem") : print_cases_scope. (* ditto -WM *)
      1 Print ("Can't extract ",s);;tmFail "The term contains variables as type parameters.");;
      1 print c ;;
      1 print : byte_scope.
      1 Print B.w.
      1 Print Build_UnOp.
      1 print (b : t) : list Byte.byte :=
      1 print : bs_scope.
      1 Print Bsign_Babs.
      1 print bs
      1 print) brs)
      1 print_branch Γ names prbr {struct names} :=
      1 print_branch Γ (List.rev br.(bcontext)) (fun Γ => print_term Γ true br.(bbody))) brs in
      1 print_branch (na' :: Γ) l prbr
      1 print_box_type Σ wf (map tvar_name (ExAst.ind_type_vars oib)) bt))%bs in
      1 print_box_type Σ (todo "assume wf") [] bt).
      1 print_box_type (Σ : global_env_ext) (wfextΣ : ∥ wf_ext Σ∥) (tvars : list name) :=
      1 print_box_type := erase_type_tests.print_box_type Σ (todo "assume wf_env") [].
      1 print_box_type := erase_type_tests.print_box_type.
      1 print_box_type (empty_ext (PCUICProgram.trans_env_env Σ)) assume_wellformed tvars bt)
      1 Print Box.Box.Box.Box.foo.
      1 Print bool_and__tuple_fun. *)
      1 Print bobmorane. (*
      1 print_binding v n) (print_env e)
      1 print_binding : var -> nat -> io.
      1 print_binding =>
      1 print (b : Byte.byte) : Byte.byte := b.
      1 Print basis.
      1 print_base_systems (b : list base_system) : string
      1 print_base_system (List.rev bs)) ++ ["or " ++ print_base_system b]%string)
      1 print_base_system (b : base_system) : string
      1 print_base_system b1 ++ " or " ++ print_base_system b2
      1 print_base_system b
      1 Print (baseName : String.t) : TM unit :=
      1 Print base_51_sub.
      1 Print base_51_carry_mul.
      1 Print base_25p5_sub.
      1 Print base_25p5_carry_mul.
      1 Print bar "tests/test_link_order_import3".
      1 Print Barrett256.barrett_red256.
      1 Print balances.
      1 Print B1.d.
      1 Print B1.c.
      1 Print B.
      1 Print B)
      1 print {A: Type} (printer: A -> unit) (prog: A) : A :=
      1 Print a;;tmFail "tInd is not supported (probably there is a type not in prenex-normal form)" 
      1 print_atend l a) as h.
      1 print_atend_eq :
      1 print_atend :
      1 Print ("AST" ++ (AstUtils.string_of_term ast)) ;; *)
      1 Print Assumptions Wilson_theorem.
      1 Print Assumptions VST_sound.
      1 Print Assumptions typing_ind_env.
      1 Print Assumptions typecheck_program. *)
      1 Print Assumptions top2bottom_correct.
      1 Print Assumptions TimeHierarchyTheorem.
      1 Print Assumptions the_loop.
      1 Print Assumptions Step10.
      1 Print Assumptions sr_red1. *)
      1 Print Assumptions sr_red1.
      1 Print Assumptions run_step.
      1 Print Assumptions red_confluence.
      1 Print Assumptions raft_linearizable.
      1 Print Assumptions qs_avg_complexity.
      1 Print Assumptions qs_avg_bigO.
      1 Print Assumptions principal_typing.
      1 Print Assumptions principal_type. *)
      1 Print Assumptions PRF_DRBG_Adv_small.
      1 Print Assumptions poly1305_ok. *)
      1 Print Assumptions pcuic_to_template. *)
      1 Print Assumptions PCP_BPCP.
      1 Print Assumptions OWP_HCP_PRG. 
      1 Print Assumptions Nth'_steps_nice. *)
      1 Print Assumptions MUREC_MM_HALTING. *)
      1 Print Assumptions montladder_compiles_correctly. *)
      1 Print Assumptions Montgomery256.prod_montred256_correct.
      1 Print Assumptions MM_VSU.*)
      1 Print Assumptions MM_R_VSU.
      1 Print Assumptions MM_HALTS_ON_ZERO_EILL_PROVABILITY.
      1 Print Assumptions MM_FRACTRAN_HALTING.
      1 Print Assumptions minValidityUndec.
      1 Print Assumptions minSatisfiabilityUndec.
      1 Print Assumptions minProvabilityUndec.
      1 Print Assumptions minKripkeValidityUndec. *)
      1 Print Assumptions minKripkeSatisfiabilityUndec.
      1 Print Assumptions minimizer_pred. *)
      1 Print Assumptions minimizer_coq. *)
      1 Print Assumptions minimizer_alt. *)
      1 Print Assumptions minFiniteValidityUndec.
      1 Print Assumptions minFiniteSatisfiabilityUndec.
      1 Print Assumptions lucas_lemma.
      1 Print Assumptions Loop_steps_nice. *)
      1 Print Assumptions Lob.lob.
      1 Print Assumptions LMGenNP_to_TMGenNP_mTM. *)
      1 Print Assumptions Imp2AsmCorrectness.compile_correct.
      1 Print Assumptions immedTestOk. *)
      1 Print Assumptions immedProgOk. *)
      1 Print Assumptions immedOk. *)
      1 Print Assumptions iBPCP_BSM_HALTING.
      1 Print Assumptions H10_undec.
      1 Print Assumptions GenNP_to_TMGenNP.
      1 Print Assumptions function_equality_ex2.
      1 Print Assumptions FSAT_PROP_ONLY_DEC. *)
      1 Print Assumptions FSAT_FULL_MONADIC_FSAT_11. *)
      1 Print Assumptions FSAT_FULL_MONADIC_DEC. *)
      1 Print Assumptions FRACTRAN_HALTING_on_exp_diophantine.
      1 Print Assumptions fo_form_fin_dec_SAT_discr_equiv. *)
      1 Print Assumptions FIN_DEC_SAT_FIN_DISCR_DEC_SAT. *)
      1 Print Assumptions FIN_DEC_EQ_SAT_FIN_DEC_SAT. *)
      1 Print Assumptions extract_correct. *)
      1 Print Assumptions expand_lets_sound. *)
      1 Print Assumptions exp_97_body. (* depends on [width] and  [word] :/ *)
      1 Print Assumptions exp_6_body. (* does not depend on [width] or [word] *)
      1 Print Assumptions eval_L_from. *)
      1 Print Assumptions eval_ind_canonical. *)
      1 Print Assumptions erases_correct. *)
      1 Print Assumptions erases_correct.
      1 Print Assumptions EILL_ILL_PROVABILITY.
      1 Print Assumptions DPRM_n.
      1 Print Assumptions divergerOk. *)
      1 Print Assumptions dio_rel_rt.
      1 Print Assumptions dio_rel_fall_lt.
      1 Print Assumptions dio_rel_expo.
      1 Print Assumptions dio_formula_elem. *)
      1 Print Assumptions det_eq_impl_dist_sem_eq.
      1 Print Assumptions cumul_Prod_inv.
      1 Print Assumptions CSL2FineBareAsm_safety.
      1 Print Assumptions CookLevin. *)
      1 Print Assumptions confluence.
      1 Print Assumptions] command.  *)
      1 Print Assumptions Clight_initial_safe.*)
      1 Print Assumptions chacha20poly1305_aead_encrypt_ok. *)
      1 Print Assumptions CD_TYP_undec.
      1 Print Assumptions CD_TC_undec.
      1 Print Assumptions CD_INH_undec.
      1 Print Assumptions BSM_MM_HALTS_ON_ZERO.
      1 Print Assumptions BSM_MM_HALTING.
      1 Print Assumptions BPCP_iBPCP.
      1 Print Assumptions bezout_generalized.
      1 Print Assumptions base_51_good.
      1 Print Assumptions base_25p5_good.
      1 Print Assumptions Barrett256.prod_barrett_red256_correct.
      1 Print Assumptions AsmOptimization.simple_correct.
      1 Print Assumptions alpha_nat_divisibility_2.
      1 Print Assumptions alpha_nat_divisibility_1.
      1 print as [p τ] eqn:e1.
      1 print as [pl al] eqn:e2.
      1 Print a specific string if the property fails. *)
      1 print as [no (max_bitwidth := _)] *)
      1 PrintAsm.ml].
      1 print_args Γ nas br {struct nas} :=
      1 print_args Γ (List.rev nas) (fun Γ => print_term Γ true false br)) brs in
      1 print_args (vass na :: Γ) nas br
      1 print_args : True. (* .in *)
      1 print_args ltac_term_list:(l).
      1 Print argsEnviron.
      1 print_args 1 x "a b" (1 = 0). (* .in .messages *)
      1 print_args.
      1 print" are applicable *)         
      1 Print ArbitraryUnion.
      1 Print applyN.
      1 Print "Apply2Union" ;;
      1 print all
      1 print a in
      1 Print A.i.
      1 print a (full) program to an html file
      1 print 'a', for example. Then one can apply a
      1 print), a few constructors for Ltac2
      1 Print : aexp -> com
      1 Print add_term. *)
      1 Print add1.
      1 print #|?a| #|?b| _ = (?u, ?v)
      1 Print ab_star_parser_ocaml.
      1 printable characters?
      1 print a).2|) (pattern_list_footprint l).1 ++ [ (pattern_footprint a).1 ], (pattern_footprint a).2 ++ (pattern_list_footprint l).2).
      1 Print A2.B2.f.
      1 Print A');;
      1 Print 2-D grid of nats *)
      1 print0; simpl; intros; auto.
      1 print0; auto. simpl.
      1 Print]
      1 Print. *)
      1 Print);;
      1 Print). *) *)
      1 Print) ;; *)
      1 Print _ _ _) ) ] =>
      1 print}}.
      1 print`
      1 print('.')
      1 print"
      1 inspect x).
      1 inspect (variance_universes univs v) := {
      1 inspect (Universe.is_sprop u) := {
      1 inspect (unfold_one_case (Γ ,,, stack_context π) ci p c brs _) := {
      1 inspect. unfold erase_clause_1_clause_2.
      1 inspect the whole
      1 inspect the proof state a bit deeper:
      1 inspect the body of a function λProlog
      1 inspect => rind eqrind.
      1 inspect resulting closure.
      1 inspect (reduce_to_sort Γ K _) := {
      1 inspect (reduce_to_sort (X:=X) Γ T.π1 _) :=
      1 inspect (@reduce_to_sort _ _ X_type X _ Γ T HT) => {
      1 inspect (reduce_to_sort _ x obl2')) eqn:hi';
      1 inspect (@reduce_to_prod _ _ X_type X _ Γ T HT) => {
      1 inspect (reduce_term RedFlags.nodelta X_type X Γ t (fun Σ h => (tywt (isT Σ h)))) :=
      1 inspect (reduce_term RedFlags.nodelta X_type X Γ t (fun Σ0 h => (tywt (isT Σ0 h)))) :=
      1 inspect (reduce_term RedFlags.nodelta X_type X Γ t (fun Σ0 h => (typwt _ (typ Σ0 h)))) := {
      1 inspect (reduce_stack RedFlags.nodelta _ X (Γ ,,, stack_context ρ2) rt2 (appstack l2 []) _) := {
      1 inspect (reduce_stack RedFlags.nodelta _ X (Γ ,,, stack_context ρ1) rt1 (appstack l1 []) _) := {
      1 inspect (reduce_stack RedFlags.default _ X Γ t [] h) := {
      1 inspect (reduce_stack RedFlags.default _ X
      1 inspect (reduce c (Proj p :: π) _) := {
      1 inspect (reduce c (Fix_app mfix idx args :: ρ) _) := {
      1 inspect (reduce c (Case_discr ci p brs :: π) _) := {
      1 inspect (PCUICEnvironment.cst_body cst) := {
      1 inspect (option_map (lift0 (S n) ∘ decl_type) (nth_error Γ n)) :=
      1 inspect (nth_error Γ n) := {
      1 inspect_nth_error_rename (r:=r) eqbr) as [prf ->]; simp rho.
      1 inspect_nth_error_rename {r brs u res} (eq : nth_error brs u = res) :
      1 inspect (nth_error (rename_branches r brs) u) =
      1 inspect (nth_error (map_terms rho Γ args _) (p.(proj_npars) + p.(proj_arg))) := {
      1 inspect (nth_error (map_terms rho Γ args _) (pars + narg)) := {
      1 inspect (nth_error idecl.(ind_projs) p.(proj_arg)) := {
      1 inspect (nth_error idecl.(ind_ctors) k) := {
      1 inspect (nth_error d.π2.π1.(ind_projs) p.(proj_arg)) :=
      1 inspect (nth_error decl.π2.π1.(ind_ctors) k) :=
      1 inspect (nth_error decl.(ind_bodies) ind.(inductive_ind)) := {
      1 inspect (nth_error decl.(ind_bodies) ind.(inductive_ind)) :=
      1 inspect (nth_error brs n) := {
      1 inspect (nth_error brs c) =>
      1 inspect (nth_error brs c') := {
      1 inspect (nth_error args (p.(proj_npars) + p.(proj_arg))) := {
      1 inspect => nth eq'.
      1 inspect (map_terms pattern_footprint l _) := {
      1 inspect (lookup_rewrite_decl k) := {
      1 inspect (@lookup_ind_decl p.(proj_ind)) :=
      1 inspect (leqb_term t1 t2) := {
      1 inspect (is_propositional u || abstract_env_eq X u Universe.type0) := {
      1 inspect (is_propositional u) := {
      1 inspect (isconv_term _ X Γ le t ht u hu) := {
      1 inspection of hypothesis and conclusion formulas of current goals, where we
      1 inspect; intros opt e'.
      1 inspect; intros o eq. cbn in eq.
      1 inspecting the definition of [fact_init], we can draw conclusions about
      1 inspecting intermediate states! *)
      1 inspecting all possible pairs of elements of a rlist. *)
      1 Inspecting a Db
      1 inspecting:
      1 inspect (hnf (X_type := X_type) Γ T (fun Σ h => (tywt (isT Σ h)))) :=
      1 inspect (hnf (X_type := X_type) Γ t (fun Σ h => (tywt (isT Σ h)))) := {
      1 inspect HN1_2, show that resulting type is essentially a renaming of s *)
      1 inspect => [[f'' π''] eq'']. simp reduce_to_ind.
      1 inspect => [[f' π'] eq']. simp reduce_to_ind.
      1 inspect (forallb (abstract_env_level_mem X) u) := {
      1 inspect (forallb2 (bcompare_decls eqb eqb) Δ Δ') :=  {
      1 inspect (first_match k (all_rewrite_rules rd) t) := {
      1 inspect => [[f args] eq].
      1 inspect (eqb_universe_instance_gen (abstract_env_eq X) u u') := {
      1 inspect (eqb_universe_instance_gen (abstract_env_eq X) p1.(puinst) p2.(puinst)) := {
      1 inspect (eqb_term (tProj p c) (tProj p' c')) := {
      1 inspect (eqb_termp_napp_gen leq (abstract_env_eq X) (abstract_env_leq X)
      1 inspect (eqb_termp_napp_gen le (abstract_env_eq X) (abstract_env_leq X) (abstract_env_compare_global_instance _ X) 0 t u) := {
      1 inspect (eqb m m') := {
      1 inspect (eqb (ind, par) (ind', par')) := {
      1 inspect (eqb ci ci') := {
      1 inspect (eqb_binder_annot u.(dname) v.(dname)) := {
      1 inspect (elim_kn t))) Γ.
      1 inspect (elim_kn t))) Γ)
      1 inspect (elim_kn ?t))) ?Γ ] =>
      1 inspect (elim_kn t) := {
      1 inspected term and generating the
      1 inspected.
      1 inspected,
      1 inspect => //. destruct x.
      1 inspect (decompose_stack π) := {
      1 inspect (decompose_app x) :=
      1 inspect (decompose_app (tApp orig_hd orig_arg)) := {
      1 inspect (decompose_app t) := {
      1 inspect bt as lists, we can switch to this principle 
      1 inspect_bool true := left eq_refl;
      1 inspect_bool; simp erase.
      1 inspect_bool (is_erasableb X_type X Γ T wt) :=
      1 inspect_bool (is_erasableb X_type X Γ t Ht) :=
      1 inspect_bool (is_erasableb X_type Xext [] t wt)) eqn:heq.
      1 inspect_bool (is_erasableb X_type Xext [] (tConstruct i n ui) Hyp0)).
      1 inspect_bool false := right eq_refl.
      1 inspect_bool _ = _ |- context [ @is_erasableb _ _ _ _ _ ?wt'] ] =>
      1 inspect_bool _ = _ |- context [ @is_erasableb _ _ ?normalization_in' _ _ ?wt'] ] =>
      1 inspect_bool (b : bool) : { b } + { ~~ b } :=
      1 inspect {A} (x : A) : { y : A | x = y } := exist _ x eq_refl.
      1 inspect {A} (x : A) (P : { y : A | y = x } -> Type) :
      1 inspect (AUContext.repr (inst, cstrs)) := {
      1 inspect.  At each leaf, which represents at most three points, we store the minimum square distance. *)
      1 inspect as [[f a] decapp].
      1 inspect as [[br|] eqnth]; cbv zeta; simp rho; rewrite eqnth //; cbv zeta; simp rho => //.
      1 inspect as [[br|] eqbr]=> //; simp rho;
      1 inspect (arities_contexts mind (PCUICEnvironment.ind_bodies mib)) in
      1 inspect => [[app st] eqst]. simp reduce_to_ind => //.
      1 inspect. apply hp.
      1 inspect (abstract_env_lookup X prim_ty) := {
      1 inspect (abstract_env_lookup X ind.(inductive_mind)) := {
      1 inspect (abstract_env_lookup X ind.(inductive_mind)) :=
      1 inspect (abstract_env_lookup X cst) := {
      1 inspect (abstract_env_lookup X cst) :=
      1 inspect (abstract_env_lookup X c') := {
      1 inspect (@abstract_env_ext_wf_universeb _ _ _ _ X u) := {
      1 inspect (abstract_env_check_constraints X (subst_instance_cstrs u cstrs)) := {
      1 inspect (
      1 dump the gory details of subgoal structure into this tutorial.  Instead, we give a high-level account of what each subgoal means and how it is dealt with. *)
      1 dumps the full env (and not only the bound variables from the env) into closures, this is a problem: we get only related, not the same closures
      1 Dump of all relevant service/topic state. *)
      1 debug (v : list string)
      1 Debug Verbosity 1.
      1 debug_vars vars s) k = find_label lbl s k.
      1 debug_vars vars s) k e le m)
      1 debug_vars (vars: list (ident * type)) (s: statement) :=
      1 debug_vars vars' body')) |}.
      1 debug_var s vars
      1 debug_vars. destruct (Compopts.debug tt); auto.
      1 debug_vars. destruct (Compopts.debug tt).
      1 debug_vars.
      1 Debugvarproof.transf_program_match.
      1 Debugvarproof.transf_program_correct.
      1 Debugvarproof.
      1 Debugvar] pass. *)
      1 debug_var id ty) s.
      1 debug_var id ty) k e le m)
      1 debug_var (id_ty: ident * type) (s: statement) :=
      1 debug_var (id: ident) (ty: type) :=
      1 debug variable is set).
      1 debug_var; eauto.
      1 debug_var. eapply step_builtin with (optid := None).
      1 Debugvar: analysis diverges")
      1 debug_var:
      1 DEBUG: use idtac here*)
      1 Debug "use-alias".
      1 Debug "update_fblock" (t2-t1) ;;
      1 Debug "update_fblock_d" (t2-t1) ;;
      1 debug -> (unit -> constr) list -> ident list option -> unit := "ltac2" "tac_trivial".
      1 debug: unit -> bool.
      1 debug tt).
      1 Debug "truncate" (t2-t1) ;;
      1 debug _ _ _ => True
      1 Debug "tree_sync" (t2-t1) ;;
      1 Debug ("Translate" ++ id);;
      1 Debug ("Translate " ^ id);;
      1 Debug ("Translate " ++ id);;
      1 debug "tInd" (match i with mkInd s _ => s end)
      1 debug (time "Debugging info for local variables" Debugvar.transf_program)
      1 debug_term msg := tVar ("debug: " ^ msg).
      1 debug_term msg := tVar ("debug: " ++ msg).
      1 debug_temp with (v := v').
      1 debug_temp id ty) s.
      1 debug_temp id ty) k e le m)
      1 debug_temp id ty)
      1 debug_temp (id: ident) (ty: type) :=
      1 debug_temp; eauto.
      1 debug_temp. eapply step_builtin with (optid := None).
      1 debug_temp:
      1 debug "tConst" s
      1 debug "tConstruct" (match i with mkInd s _ => s end)
      1 debug ["TC", "Debug"].
      1 debug "tCase" (match (fst ik) with mkInd s _ => s end)
      1 Debug "tactic-unification".*)
      1 debug tactics *)
      1 debug such situations, it can be helpful to print the current internal
      1 Debug);"; ""]%string)%list ++ (List.map (fun s => "    " ++ s)%string (to_strings internal_private prefix body)) ++ ["}"%string]%list.
      1 debug_strength_reduction_correct; eauto. intros (vargs' & P).
      1 debug_strength_reduction_correct:
      1 debug_strength_reduction ae al) vl'.
      1 debug_strength_reduction ae al in
      1 debug_strength_reduction ae al) (b1 :: vl'))
      1 debug_strength_reduction (ae: AE.t) (al: list (builtin_arg reg)) :=
      1 debug_stamps s {A : Type} (r : Result) (x : A) :=
      1 debug_stamps "Conjoin result: " r *) res
      1 debug_stamps "Before_adding: " result (
      1 debug_stamps "After_adding: " res  *)
      1 debug_stamps "Adding_stamps: " r ( *)
      1 Debug (s: string) (n: nat) : prog unit
      1 debug_setvar lm (snd (transfer lm before i)) c' in
      1 debug_setvar lm (snd (transfer lm before i)) c'
      1 debug_setvar (lm: labelmap) (before: option avail) (c: code) :=
      1 debug_setvar i with
      1 debug_setvar (i: instruction) :=
      1 debug_setvar ef with
      1 debug_setvar (ef: external_function) :=
      1 debug_setvar ef
      1 Debug s a) p ~= p tt.
      1 debug_run tac := tac ().
      1 debug_run ltac:(fun _ => idtac "SymexLines start");
      1 debug_run ltac:(fun _ => idtac "SymexLines end")
      1 debug_run ltac:(fun _ => idtac "LoadOutputs start");
      1 debug_run ltac:(fun _ => idtac "LoadOutputs end")
      1 debug_run ltac:(fun _ => idtac "LoadArray start");
      1 debug_run ltac:(fun _ => idtac "LoadArray end")
      1 debug_run ltac:(fun _ => idtac "get callee_saved_registers start");
      1 debug_run ltac:(fun _ => idtac "get callee_saved_registers end")
      1 debug_run ltac:(fun _ => idtac "build_merge_stack_placeholders start");
      1 debug_run ltac:(fun _ => idtac "build_merge_stack_placeholders end")
      1 debug_run ltac:(fun _ => idtac "build_merge_base_addresses start");
      1 debug_run ltac:(fun _ => idtac "build_merge_base_addresses end")
      1 debug_run ltac:(fun _ => idtac "build_inputs start");
      1 debug_run ltac:(fun _ => idtac "build_inputs end")
      1 debug rule
      1 Debug "rename" (t2-t1);;
      1 Debug "read_fblock" (t2-t1) ;;
      1 Debug: Quoting executed in: 0.0130159854889s
      1 Debug: Quoting
      1 debug_printf "remove dead from %t" body;
      1 debug_printf fmt := if debug () then Printf.printf fmt else Message.Format.kfprintf (fun x => ()) fmt.
      1 debug_printf" fmt(format) := debug_printf fmt.
      1 debug_printf "dropping %i %i %t" n k c;
      1 debug_printf "dropped %i %i %t" n k res;
      1 debug_params vars s) k = find_label lbl s k.
      1 debug_params. rewrite find_label_store_params. rewrite find_label_add_debug_vars. eexact A.
      1 debug_params params s) k e le m)
      1 debug_params (params: list (ident * type)) (s: statement) :=
      1 debug_param s params
      1 debug_params f.(fn_params)
      1 debug_params. destruct (Compopts.debug tt); auto.
      1 debug_params. destruct (Compopts.debug tt).
      1 debug_params. auto. eapply forall2_val_casted_inject; eauto. eexact Q.
      1 debug_param (id_ty: ident * type) (s: statement) :=
      1 debug p1 i1 t1, EF_debug p2 i2 t2 => 
      1 debug_opt : Set := debug : bool.
      1 debug o:list string.
      1 debug _ _ _ => OK e
      1 DEBUG_MYPRED"
      1 debug. mydestr. split; constructor.
      1 debug modes to avoid side channels";
      1 debug/ml/VarDRaftDebug.ml" seq vard_raft_base_params vard_raft_multi_params vard_raft_failure_params.
      1 Debug.ml" level3.
      1 Debug.ml" level2.
      1 Debug.ml" level1.
      1 Debug.ml" level0.
      1 debug l' with
      1 debug lp:{{
      1 Debug "lookup" (t2-t1) ;;
      1 debug (l: list (builtin_arg loc)) : option debuginfo :=
      1 debug kind text targs => mksignature targs Tvoid cc_default
      1 debug kind text targs => do_ef_debug kind text targs
      1 debug (kind: positive) (text: ident) (targs: list typ)
      1 debug. It is not very transparent and difficult to guide it in right direction.
      1 debug -> int option -> (unit -> constr) list -> ident list option -> unit := "ltac2" "tac_eauto".
      1 debug -> int option -> (unit -> constr) list -> ident list option -> unit := "ltac2" "tac_auto".
      1 debug info with
      1 debug_info (v: ident) (info: list (builtin_arg loc)) (s: avail) :=
      1 debug_info v args s
      1 debuginfo) (s: avail) : avail :=
      1 debug info.  Prefer an actual location to a constant.
      1 debug info is safe to evaluate in any context. *)
      1 debug info is a [builtin_arg loc] expression that safely evaluates
      1 debuginfo i i0); auto. constructor; auto.
      1 debuginfo i1 i2 then vi1 :: join s1' s2' else join s1' s2'
      1 debuginfo i1 i2 then diff s1' s2' else vi1 :: diff s1' s2'
      1 debuginfo (i1 i2: debuginfo) : {i1=i2} + {i1 <> i2}.
      1 debuginfo i0 i1); auto with coqlib.
      1 debuginfo i0 i1).
      1 debuginfo. apply ident_eq.
      1 debuginfo := { a : builtin_arg loc | safe_builtin_arg a }.
      1 debuginfo.
      1 debuginfo).
      1 debug id (typeof a1) (simpl_expr cenv a2))
      1 debug id ty a) k e le m)
      1 debug_idtac" string(x) := idtac (*x*).
      1 debug_idtac "!asimpl_var_id_r";
      1 debug_idtac "asimpl_var_id_l_ca";
      1 debug_idtac "asimpl_var_id_l";
      1 debug_idtac "!asimpl_up_scons";
      1 debug_idtac "!asimpl_subst_merge";
      1 debug_idtac "!asimpl_scons_up_f";
      1 debug_idtac "!asimpl_scons_up";
      1 debug_idtac "asimpl_scons_comp";
      1 debug_idtac "asimpl_id_id_r";
      1 debug_idtac "asimpl_id_id_l";
      1 debug_idtac "asimpl_funcomp_assoc";
      1 debug (id: ident) (ty: type) (a: expr) :=
      1 debug : ident := 67%positive.
      1 debug : ident := 64%positive.
      1 debug : ident := 61%positive.
      1 debug : ident := 44%positive.
      1 Debug "hash mismatch" 0;;
      1 debug_goal :=
      1 debugging, we display goals that should not remain *)
      1 debugging tool for "leaking information out of [match]es," we see that
      1 debugging, so we can disable ProcPhi iff needed*)
      1 debugging scripts using it is, frankly, not very pleasant.  But it
      1 debugging purposes *)
      1 debugging, is a greedy process by
      1 debugging hook, do the following: 
      1 debugging feature can be used via
      1 debugging because it highlights the differences *)
      1 debugging and error reporting *)
      1 debugging and enhance clarity.
      1 Debugging
      1 debugging.
      1 debugging
      1 Debug "get_attr" (t2-t1) ;;
      1 debugger Ffield instead of using second version *)
      1 DEBUG: fuzzed!".
      1 Debug "ftruncate" (t2-t1) ;;
      1 debug : forall T' (p: unit -> prog T') s a,
      1 debug : forall n : nat, power nat trivial n 1 = n.
      1 Debug "file_sync" (t2-t1) ;;
      1 Debug "file_get_sz" (t2-t1) ;;
      1 debug fiat_p256_square_optimised_seed6.example.
      1 debug fiat_p256_square_optimised_seed46.example.
      1 debug fiat_p256_square_optimised_seed103.example.
      1 debug fiat_p256_mul_optimised_seed4.example.
      1 debug fiat_p256_mul_optimised_seed12.example.
      1 debug fiat_p256_mul_optimised_seed11.example.
      1 debug fiat_25519_carry_square_optimised_seed20.example.
      1 debug fiat_25519_carry_square_optimised_seed10.example.
      1 debug fiat_25519_carry_square_optimised.example.
      1 debug () := false.
      1 debugfail ltac:(_nonzero_tac fld));
      1 Debug "elpitime". 
      1 DebugE +' FailureE) _ (Some (m', x)) (interp_helix (denoteNExpr σ nexp) m) ->
      1 DebugE +' FailureE) _ (Some (mf_to, n)) (interp_helix (denoteNExpr σ to) mi_to))
      1 debug eauto with xxx]. Abort.
      1 debug. eauto. rewrite typeof_simpl_expr. eauto.
      1 debug _ _ _ => e3 | _ => e2 end); split.
      1 debug. destruct (Compopts.debug tt); auto.
      1 Debug "delete" (t2-t1);;
      1 debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.
      1 debug Debugvarproof.match_prog)
      1 debug _ _ _ => debug_strength_reduction ae al
      1 Debug Debug On. *)
      1 Debug "DEBUG_MYPRED".
      1 Debug "create" (t2-t1) ;;
      1 Debug: Checking executed in: 0.0271821022034s
      1 debug :: ___builtin_write16_reversed ::
      1 debug] builtins, some arguments can be removed. *)
      1 debug :: ___builtin_nop :: ___builtin_write16_reversed ::
      1 debug boringssl_nasm_full_mul_p256.example.
      1 Debug "BFILE.dwrite" (t2 - t1);; *)
      1 Debug "BFILE.datasync" (t2 - t1);; *)
      1 DEBUG: attempt at fuzzing binary op:" Op,
      1 debug_args_satisf; eauto. intros (v1' & C & D).
      1 debug_args_satisf; eauto.
      1 debug_args_satisf:
      1 debug_args_eval; eauto.
      1 debug_args_eval:
      1 debug_args env al args' e
      1 debug_args env al al' e1
      1 debug_args
      1 debug annotations introduced by the transformation. *)
      1 debug annotations at the beginning and end of live ranges
      1 debug annotations, add constant values to the original info
      1 Debug annotations. *)
      1 debug annotations *)
      1 debug, and it can seamlessly
      1 debug _ _ _ => add_equations_debug_args env args args' e2
      1 debug _ _ _ => add_equations_debug_args env args args' e1
      1 Debug {A} : A -> TemplateMonad unit :=
      1 debug 5%positive id (AST.Tptr :: nil))
      1 debug 4%positive v nil) nil BR_none :: c.
      1 debug 3%positive v nil) (proj1_sig i :: nil) BR_none :: c.
      1 debug 2%positive txt targs => Some txt
      1 debug 2%positive id (typ_of_type ty :: nil))
      1 debug_1 (a: builtin_arg loc) : option debuginfo :=
      1 debug ${i%.*}.example."; echo "Proof. Time native_compute. exact eq_refl. Abort."; echo 'Redirect "log" Compute parse '"${i%.*}.example."; done *)
      1 Debug. 
      1 Debug _ _) _ |- _ ] =>
      1 Debug _ _) _ ] =>
      1 debug]
      1 debug:
      1 debug. *)
      1 debug.  
      1 debug, 
      1 debug _ _ _, _ =>
      1 debug _ _ _), _ =>
      1 debug _ _ _ =>
      1 debug ]
      1 debug =>
#+end_example


* vedas

reinterpret the occurances of these coq ast constructors in a body of projects
as names of parts of the vedas gods and dieties in modern mythos theory,
try and find connections between the types of asts and the types of archtypes.
the smallest partical is represented by mukraprathi which is the
equivalent to the universal type, the smallest unit of knowledge, the topological k-cube.



Term | Count
-----|-------
tIntro | 180
tCast | 190
tVar | 234
tBox | 241
tInd | 324
tConst | 329
tEvar | 359
tConstruct | 374
tCoFix | 411
tFix | 469
tProj | 496
tCase | 549
tLambda | 598
tLetIn | 606
tProd | 678
tRel | 679
tApp | 790
tSort | 796

** output 1
#+begin_src output

* `tIntro`: This ast constructor could represent the introduction to a story or narrative, similar to the Vedic god of creation, Brahma.
* `tCast`: This ast constructor could represent the casting of spells or incantations, similar to the Vedic goddess of magic and healing, Lakshmi.
* `tVar`: This ast constructor could represent a variable or symbol used in a spell or ritual, similar to the Vedic god of knowledge and wisdom, Saraswati.
* `tBox`: This ast constructor could represent a container or receptacle, such as an altar or offering dish, similar to the Vedic god of abundance and prosperity, Dhanapati.
* `tInd`: This ast constructor could represent an individual or entity, such as a person or animal, similar to the Vedic god of love and beauty, Venus.
* `tConst`: This ast constructor could represent a constant value or force, such as gravity or electromagnetism, similar to the Vedic god of the cosmos and the universe, Shiva.
* `tEvar`: This ast constructor could represent an eternal or everlasting entity, such as the soul or the self, similar to the Vedic goddess of love and devotion, Parvati.
* `tConstruct`: This ast constructor could represent a complex structure or system, such as a machine or an organization, similar to the Vedic god of engineering and craftsmanship, Vishnu.
* `tCoFix`: This ast constructor could represent a conjunction or connection between two entities, such as cause and effect or subject and object, similar to the Vedic goddess of truth and justice, Satya.
* `tFix`: This ast constructor could represent a permanent or enduring state or condition, similar to the Vedic god of time and eternity, Kali.
* `tProj`: This ast constructor could represent a projection or manifestation of an idea or concept, similar to the Vedic goddess of creativity and inspiration, Devi.
* `tCase`: This ast constructor could represent a situation or circumstance that requires a particular action or response, similar to the Vedic god of wisdom and counsel, Atmanirupa.
* `tLambda`: This ast constructor could represent a function or procedure that takes input values and produces output results, similar to the Vedic goddess of knowledge and understanding, Vidya Devi.
* `tLetIn`: This ast constructor could represent a statement or assertion about a given value or variable, similar to the Vedic god of language and communication, Agastya.
* `tProd`: This ast constructor could represent a product or result of a mathematical operation, such as addition or multiplication, similar to the Vedic goddess of mathematics and science, Ada Devi.
* `tRel`: This ast constructor could represent a relationship or connection between two entities, such as parent-child or sibling-sibling, similar to the Vedic goddess of love and family, Lakshmi.
* `tApp`: This ast constructor could represent an application or implementation of a function or procedure in a specific context, similar to the Vedic goddess of knowledge and wisdom, Saraswati.
* `tSort`: This ast constructor could represent a sorting or ordering operation on a sequence of values, such as quicksort or mergesort, similar to the Vedic god of mathematics and science, Ada Devi.
#+end_src
#+begin_src output

* tIntro: This constructor can be seen as representing the "Introduction" section of the Vedas, which serves to set the tone and provide background information for the rest of the text. In modern mythos theory, this may correspond to the "Mythic Archetype" or the "Hero's Journey," which is a common narrative structure found in many mythologies.
* tCast: This constructor can be seen as representing the "Cast of Characters" section of the Vedas, which introduces the main gods and deities that will be featured in the text. In modern mythos theory, this may correspond to the "Goddess" or "Trickster" archetype, depending on the particular story being told.
* tVar: This constructor can be seen as representing the "Variables" section of the Vedas, which lists out the different terms and concepts used in the text. In modern mythos theory, this may correspond to the "Symbolism" or "Metaphor" archetype, which explores the hidden meanings behind words and actions.
* tBox: This constructor can be seen as representing the "Containers" section of the Vedas, which describes the various vessels and objects used in religious rituals. In modern mythos theory, this may correspond to the "Symbolism" or "Metaphor" archetype, which explores the hidden meanings behind objects and symbols.
* tInd: This constructor can be seen as representing the "Individuals" section of the Vedas, which describes the various gods and deities in more detail. In modern mythos theory, this may correspond to the "Hero" or "Trickster" archetype, depending on the particular story being told.
* tConst: This constructor can be seen as representing the "Constants" section of the Vedas, which lists out the fundamental principles and values that underlie the text. In modern mythos theory, this may correspond to the "Wisdom" or "Philosophy" archetype, which explores the deeper meaning behind life and existence.
* tEvar: This constructor can be seen as representing the "Goddess" section of the Vedas, which focuses on the various female deities and their roles in Hindu mythology. In modern mythos theory, this may correspond to the "Goddess" archetype, which explores the feminine aspect of the divine.
* tConstruct: This constructor can be seen as representing the "Constructions" section of the Vedas, which describes the various religious structures and institutions that are mentioned in the text. In modern mythos theory, this may correspond to the "Culture" or "Society" archetype, which explores the values and beliefs that shape human behavior.
* tCoFix: This constructor can be seen as representing the "Co-fixing" section of the Vedas, which describes how different elements are combined to form a larger whole. In modern mythos theory, this may correspond to the "Hero's Journey" archetype, which explores the process of personal growth and transformation.
* tFix: This constructor can be seen as representing the "Fixing" section of the Vedas, which describes how individual elements are brought into balance and harmony. In modern mythos theory, this may correspond to the "Harmony" or "Peace" archetype, which explores the ideal state of existence.
* tProj: This constructor can be seen as representing the "Projects" section of the Vedas, which describes various religious initiatives and endeavors. In modern mythos theory, this may correspond to the "Mission" or "Quest" archetype, which explores the pursuit of a goal or purpose.
* tCase: This constructor can be seen as representing the "Cases" section of the Vedas, which describes various scenarios and situations that are encountered in religious practice. In modern mythos theory, this may correspond to the "Problem" or "Challenge" archetype, which explores how individuals and communities overcome obstacles.
* tLambda: This constructor can be seen as representing the "Lambda" section of the Vedas, which describes various mathematical concepts
#+end_src
#+begin_src output

In Vedas mythology, gods and deities are often represented by specific types of asts (abstract syntax trees) in modern mythos theory. The smallest partical is represented by "mukraprathi", which is equivalent to the universal type, the smallest unit of knowledge, and the topological k-cube.

Here are some possible connections between the types of asts and the types of archetypes:

* tInd (indentation) could be associated with the archetype of "The Magician", who uses symbols and signs to create order from chaos.
* tFix (fixed value) could be associated with the archetype of "The Mother", who provides stability and nourishment.
* tCoFix (compound fixed value) could be associated with the archetype of "The Father", who creates and sustains the world.
* tProj (projected value) could be associated with the archetype of "The Trickster", who uses illusions and deception to achieve their goals.
* tRel (relation) could be associated with the archetype of "The Lover", who seeks connection and understanding with others.
* tApp (application) could be associated with the archetype of "The Teacher", who imparts knowledge and helps others grow.
* tSort (sorting) could be associated with the archetype of "The Creator", who organizes and structures the world.
* tBox (box) could be associated with the archetype of "The Guardian", who protects and preserves the values within.
* tConstruct (construct) could be associated with the archetype of "The Builder", who creates new worlds and possibilities.
* tCast (casting) could be associated with the archetype of "The Warrior", who uses their powers to defend and conquer.
* tVar (variable) could be associated with the archetype of "The Alchemist", who transforms and transmutates the elements.
* tLambda (lambda function) could be associated with the archetype of "The Seer", who sees beyond the physical world and accesses higher knowledge.
* tLetIn (let-in expression) could be associated with the archetype of "The Healer", who brings forth new life and vitality.
* tProd (product) could be associated with the archetype of "The Creator", who brings new worlds and possibilities into existence.
* tEvar (enumerated variable) could be associated with the archetype of "The Collector", who gathers and organizes information and knowledge.
* tConstruct could be associated with the archetype of "The Builder", who creates new worlds and possibilities.

It's important to note that these associations are just speculative and may not hold true for all interpretations of the ast constructors in Vedas mythology.
#+end_src
#+begin_src output

* Mukraprathi (the universal type): In Hindu mythology, the universe is personified as the god Brahma. Similarly, in modern mythos theory, the concept of the "universal type" can be associated with the archetype of the Creator or Godhead.
* tIntro: The "Introduction" ast node could potentially represent the introduction or creation story of a particular deity in Hindu mythology. For example, the introduction of Shiva could be associated with the ast node tInd.
* tCast: The "Casting" ast node could represent the act of casting spells or rituals in Hindu mythology. This could be associated with the archetype of the Magician or Healer.
* tVar: The "Variable" ast node could represent the concept of variables or changeable elements in Hindu mythology. For example, the god Vishnu is often depicted as the embodiment of change and transformation.
* tBox: The "Box" ast node could potentially represent the concept of boundaries or limits in Hindu mythology. This could be associated with the archetype of the Goddess or Guardian.
* tInd: The "Independent" ast node could represent the concept of independence or autonomy in Hindu mythology. For example, the goddess Kali is often depicted as a fierce and independent deity.
* tConst: The "Construction" ast node could represent the act of building or creating something in Hindu mythology. This could be associated with the archetype of the Builder or Artisan.
* tEvar: The "Evar" ast node could potentially represent a particular deity or goddess in Hindu mythology, such as Durga or Kali.
* tConstruct: The "Construct" ast node could represent the act of constructing or building something in Hindu mythology. This could be associated with the archetype of the Builder or Artisan.
* tCoFix: The "Co-fix" ast node could potentially represent a partnership or alliance between two deities or entities in Hindu mythology. For example, the partnership between Shiva and Parvati is often depicted as a powerful union.
* tFix: The "Fix" ast node could represent a state of permanence or stability in Hindu mythology. This could be associated with the archetype of the Godhead or the eternal.
* tProj: The "Project" ast node could represent a particular project or mission in Hindu mythology. For example, the god Rama's mission to defeat the demon king Ravana is a well-known story in Hindu mythology.
* tCase: The "Case" ast node could potentially represent a specific case or situation in Hindu mythology. This could be associated with the archetype of the Seeker or Quests.
* tLambda: The "Lambda" ast node could potentially represent a particular deity or goddess in Hindu mythology, such as Kali or Durga.
* tLetIn: The "Let-in" ast node could represent a process or act of incorporation or absorption in Hindu mythology. This could be associated with the archetype of the Goddess or Guardian.
* tProd: The "Product" ast node could potentially represent a particular product or creation in Hindu mythology, such as a weapon or a temple.
* tRel: The "Relation" ast node could represent a relationship between two deities or entities in Hindu mythology, such as a parent-child relationship or a romantic relationship.
* tApp: The "Application" ast node could potentially represent an application of a particular concept or idea in Hindu mythology. This could be associated with the archetype of the Seeker or Quests.
* tSort: The "Sort" ast node could represent a sorting or categorization process in Hindu mythology, such as sorting souls after death. This could be associated with the archetype of the Goddess or Guardian.
#+end_src
#+begin_src output

The occurrences of these COQ AST constructors in a body of projects can be reinterpreted as names of parts of the Vedas gods and deities in modern mythos theory. Here are some possible connections:

* tIntro: "Introduction" - this could represent the introduction of new concepts or ideas, which may be associated with the god Indra, who is often depicted as bringing light and knowledge to the world.
* tCast: "Cast" - this could represent the act of casting spells or incantations, which may be associated with the god Brahma, who is often depicted as the creator of the universe.
* tVar: "Variable" - this could represent the concept of variables, which are used to store and manipulate data in programming, which may be associated with the god Vishnu, who is often depicted as the preserver of the universe.
* tBox: "Box" - this could represent containers or structures, which may be associated with the god Shiva, who is often depicted as the destroyer of the universe.
* tInd: "Ind" - this could represent individuality or independence, which may be associated with the god Indra, who is often depicted as the ruler of the heavens and the embodiment of individuality.
* tConst: "Constant" - this could represent fixed values or constants, which may be associated with the god Dharma, who is often depicted as the embodiment of righteousness and justice.
* tEvar: "Equivalent" - this could represent equivalence or similarity, which may be associated with the god Vishnu, who is often depicted as having multiple forms that are equivalent in power and importance.
* tConstruct: "Construct" - this could represent the act of building or creating something, which may be associated with the god Brahma, who is often depicted as the creator of the universe.
* tCoFix: "Co-fix" - this could represent a combination of two or more elements that are fixed together, which may be associated with the god Shiva, who is often depicted as the destroyer of the universe.
* tFix: "Fix" - this could represent the act of fixing or securing something in place, which may be associated with the god Vishnu, who is often depicted as the preserver of the universe.
* tProj: "Project" - this could represent a plan or undertaking that involves multiple steps or stages, which may be associated with the god Indra, who is often depicted as the ruler of the heavens and the embodiment of individuality.
* tCase: "Case" - this could represent a specific set of circumstances or conditions that must be met in order for something to occur, which may be associated with the god Brahma, who is often depicted as the creator of the universe.
* tLambda: "Lambda" - this could represent an anonymous function or closure, which may be associated with the god Shiva, who is often depicted as the destroyer of the universe.
* tLetIn: "Let-in" - this could represent a value that is assigned to a variable, which may be associated with the god Vishnu, who is often depicted as the preserver of the universe.
* tProd: "Product" - this could represent the result of multiplying two or more values together, which may be associated with the god Indra, who is often depicted as the ruler of the heavens and the embodiment of individuality.
* tRel: "Relation" - this could represent a connection or association between two or more elements, which may be associated with the god Brahma, who is often depicted as the creator of the universe.
* tApp: "Application" - this could represent the act of using something for a specific purpose, which may be associated with the god Vishnu, who is often depicted as the preserver of the universe.
* tSort: "Sort" - this could represent the act of arranging or ordering elements in a specific way, which may be associated with the god Shiva, who is often depicted as the destroyer of the universe.
#+end_src
#+begin_src output

The types of constructors in the provided code snippet can be interpreted as names of parts of the vedas gods and deities in modern mythos theory. For example:

* tIntro could represent the goddess Saraswati, who is the patron of learning and knowledge.
* tCast could represent the god Shiva, who is known for his transformative powers.
* tVar could represent the goddess Durga, who is a powerful warrior and protector of humanity.
* tBox could represent the god Vishnu, who is often depicted as holding the universe within him in the form of a cosmic cube or box.
* tInd could represent the goddess Lakshmi, who is the goddess of wealth, prosperity, and abundance.
* tConst could represent the god Brahma, who is the creator of the universe.
* tEvar could represent the goddess Parvati, who is known for her fierce and powerful nature.
* tConstruct could represent the god Indra, who is the king of the gods and ruler of the heavens.
* tCoFix could represent the goddess Kali, who is a destroyer of evil and chaos.
* tFix could represent the god Ganesha, who is known for his wisdom and strength.
* tProj could represent the goddess Artemis, who is the patron of hunting and nature.
* tCase could represent the god Krishna, who is a trickster and devotee of Vishnu.
* tLambda could represent the goddess Athena, who is known for her wisdom and strategic thinking.
* tLetIn could represent the goddess Hera, who is the queen of the gods and wife of Zeus.
* tProd could represent the god Dionysus, who is the patron of wine, festivity, and madness.
* tRel could represent the god Apollo, who is known for his music, poetry, and prophecy.
* tApp could represent the goddess Aphrodite, who is the goddess of love, beauty, and pleasure.
* tSort could represent the god Hermes, who is the messenger of the gods and ruler of trade and commerce.

The connections between these types of constructors and their corresponding archtypes can be found in various mythological and spiritual traditions around the world. For example:

* The universal type represented by mukraprathi could be seen as a connection to the concept of Brahman or the absolute, which is a central idea in Hinduism and other Eastern religions.
* The topological k-cube represented by tBox could be seen as a connection to the concept of the hologram or the interconnectedness of all things in physics and spirituality.
* The different types of constructors could represent the various aspects and facets of the gods and goddesses, such as their strengths, weaknesses, powers, and roles in the world.
* The connections between these constructors and archtypes could provide insights into the nature of reality, consciousness, and the human experience.
#+end_src
#+begin_src output

The given counts indicate the occurrences of each ast construct in a body of projects. Here's a reinterpretation of these names as names of parts of the Vedas gods and deities:

* tIntro: Brahma - The creator god, who created the universe
* tCast: Shiva - The destroyer god, who destroys the universe to create a new one
* tVar: Vishnu - The preserver god, who maintains the balance of the universe
* tBox: Indra - The king of gods and the ruler of the sky
* tInd: Agni - The fire deity, who represents knowledge and transformation
* tConst: Varuna - The god of water and the regulator of the natural world
* tEvar: Yama - The god of death and the judge of the souls
* tConstruct: Vayu - The god of wind and the embodiment of change
* tCoFix: Kubera - The god of wealth and prosperity
* tFix: Bharata - The god of agriculture and the protector of the earth
* tProj: Narada - The god of music and the messenger of the gods
* tCase: Ardra - The goddess of love and passion
* tLambda: Lakshmi - The goddess of wealth, abundance, and prosperity
* tLetIn: Ganesha - The god of wisdom and knowledge, who removes obstacles
* tProd: Skanda - The god of war and the protector of the universe
* tRel: Shakti - The goddess of power and energy, who represents the feminine principle
* tApp: Vishvamurti - The god of the universe, who embodies all forms of existence
* tSort: Rudra - The god of destruction and transformation, who destroys to create a new world.

The small, indivisible partical is represented by mukraprathi, which can be seen as equivalent to the universal type or the topological k-cube. The types of asts seem to correspond to different aspects of the divine and human experience. For example, tIntro and tCast represent the cyclical nature of creation and destruction, while tVar represents the ongoing maintenance and balance of the universe. tBox represents the container of reality, while tInd represents knowledge and transformation. tConst represents the natural order of things, while tEvar represents the judgment and reward system. tConstruct represents change and growth, while tCoFix represents wealth and prosperity. tFix represents the protection and preservation of the earth, while tProj represents communication and messaging. tCase represents love and passion, while tLambda represents wisdom and knowledge. tLetIn represents overcoming obstacles, while tProd represents war and protection. tRel represents power and energy, while tApp represents the universe as a whole. Finally, tSort represents destruction and transformation to create a new world.
#+end_src
#+begin_src output

* tIntro: The name of the deity representing knowledge and wisdom in modern mythos theory.
* tCast: The name of the deity representing transformation or metamorphosis in modern mythos theory.
* tVar: The name of the deity representing variables or unknowns in modern mythos theory.
* tBox: The name of the deity representing containers or structures in modern mythos theory.
* tInd: The name of the deity representing indices or labels in modern mythos theory.
* tConst: The name of the deity representing constants or fixed values in modern mythos theory.
* tEvar: The name of the deity representing event variables in modern mythos theory.
* tConstruct: The name of the deity representing constructs or objects in modern mythos theory.
* tCoFix: The name of the deity representing cofixed values in modern mythos theory.
* tFix: The name of the deity representing fixed values in modern mythos theory.
* tProj: The name of the deity representing projections or transformations in modern mythos theory.
* tCase: The name of the deity representing cases or branches of a decision in modern mythos theory.
* tLambda: The name of the deity representing lambda functions or anonymous functions in modern mythos theory.
* tLetIn: The name of the deity representing let-in expressions or bindings in modern mythos theory.
* tProd: The name of the deity representing products or operations in modern mythos theory.
* tRel: The name of the deity representing relations or mappings in modern mythos theory.
* tApp: The name of the deity representing applications or function calls in modern mythos theory.
* tSort: The name of the deity representing sorting or ordering operations in modern mythos theory.
#+end_src

